<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Gemini","version":"7.7.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="第1章 Spark 概述1.1 Spark 是什么 Spark 是一种基于内存的快速、通用、可扩展的大数据分析计算引擎。   1.2 Spark and Hadoop">
<meta property="og:type" content="article">
<meta property="og:title" content="SparkCore笔记">
<meta property="og:url" content="http://yoursite.com/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="没有尾巴的小驴">
<meta property="og:description" content="第1章 Spark 概述1.1 Spark 是什么 Spark 是一种基于内存的快速、通用、可扩展的大数据分析计算引擎。   1.2 Spark and Hadoop">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://yoursite.com/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230703100926094.png">
<meta property="og:image" content="http://yoursite.com/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230808165158945.png">
<meta property="og:image" content="http://yoursite.com/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230703101852435.png">
<meta property="og:image" content="http://yoursite.com/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230703102013757.png">
<meta property="og:image" content="http://yoursite.com/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230808165613169.png">
<meta property="og:image" content="http://yoursite.com/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230703103646750.png">
<meta property="og:image" content="http://yoursite.com/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230703103728395.png">
<meta property="og:image" content="http://yoursite.com/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230703103711386.png">
<meta property="og:image" content="http://yoursite.com/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230703104007807.png">
<meta property="og:image" content="http://yoursite.com/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230703104122494.png">
<meta property="og:image" content="http://yoursite.com/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230703104146054.png">
<meta property="og:image" content="http://yoursite.com/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230703105636460.png">
<meta property="og:image" content="http://yoursite.com/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230703104450249.png">
<meta property="og:image" content="http://yoursite.com/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230703104520230.png">
<meta property="og:image" content="http://yoursite.com/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230703104752985.png">
<meta property="og:image" content="http://yoursite.com/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230703104849386.png">
<meta property="og:image" content="http://yoursite.com/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230703104947119.png">
<meta property="og:image" content="http://yoursite.com/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230703104935967.png">
<meta property="og:image" content="http://yoursite.com/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230703105008718.png">
<meta property="og:image" content="http://yoursite.com/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230705153212251.png">
<meta property="og:image" content="http://yoursite.com/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230705153250449.png">
<meta property="og:image" content="http://yoursite.com/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230705153321493.png">
<meta property="og:image" content="http://yoursite.com/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230705153720036.png">
<meta property="og:image" content="http://yoursite.com/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230705153803504.png">
<meta property="og:image" content="http://yoursite.com/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230705153950847.png">
<meta property="og:image" content="http://yoursite.com/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230705154022313.png">
<meta property="og:image" content="http://yoursite.com/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230705154429977.png">
<meta property="og:image" content="http://yoursite.com/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230705154452542.png">
<meta property="og:image" content="http://yoursite.com/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230705154542440.png">
<meta property="og:image" content="http://yoursite.com/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230705154917101.png">
<meta property="og:image" content="http://yoursite.com/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230705154947955.png">
<meta property="og:image" content="http://yoursite.com/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230705155340773.png">
<meta property="og:image" content="http://yoursite.com/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230705155415701.png">
<meta property="og:image" content="http://yoursite.com/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230705155656311.png">
<meta property="og:image" content="http://yoursite.com/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230705155727521-1688543848374-1.png">
<meta property="og:image" content="http://yoursite.com/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230705155908075.png">
<meta property="og:image" content="http://yoursite.com/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230705160051860.png">
<meta property="og:image" content="http://yoursite.com/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230710163412215.png">
<meta property="og:image" content="http://yoursite.com/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230710163840537.png">
<meta property="og:image" content="http://yoursite.com/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230710101418977.png">
<meta property="og:image" content="http://yoursite.com/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230710102026568.png">
<meta property="og:image" content="http://yoursite.com/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230710102045899.png">
<meta property="og:image" content="http://yoursite.com/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230710101358005.png">
<meta property="og:image" content="http://yoursite.com/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230808165004045.png">
<meta property="og:image" content="http://yoursite.com/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230710181744170.png">
<meta property="og:image" content="http://yoursite.com/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230710181651865.png">
<meta property="og:image" content="http://yoursite.com/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230710181819982.png">
<meta property="og:image" content="http://yoursite.com/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230710181845879.png">
<meta property="og:image" content="http://yoursite.com/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230710181914836.png">
<meta property="og:image" content="http://yoursite.com/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230710181942998.png">
<meta property="og:image" content="http://yoursite.com/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230807163350450.png">
<meta property="og:image" content="http://yoursite.com/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230804173336550.png">
<meta property="og:image" content="http://yoursite.com/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230804173435262.png">
<meta property="og:image" content="http://yoursite.com/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230804173514641.png">
<meta property="og:image" content="http://yoursite.com/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230804173818441.png">
<meta property="og:image" content="http://yoursite.com/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230907144557799.png">
<meta property="og:image" content="http://yoursite.com/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230907112107435.png">
<meta property="og:image" content="http://yoursite.com/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230908144937569.png">
<meta property="og:image" content="http://yoursite.com/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230908145543991.png">
<meta property="og:image" content="http://yoursite.com/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230912162533020.png">
<meta property="og:image" content="http://yoursite.com/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230912162819586.png">
<meta property="og:image" content="http://yoursite.com/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230912163455261.png">
<meta property="og:image" content="http://yoursite.com/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230915150713822.png">
<meta property="og:image" content="http://yoursite.com/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230915150757365.png">
<meta property="og:image" content="http://yoursite.com/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230920141352308.png">
<meta property="og:image" content="http://yoursite.com/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230920180926032.png">
<meta property="og:image" content="http://yoursite.com/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230920181115290.png">
<meta property="og:image" content="http://yoursite.com/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230920181227289.png">
<meta property="og:image" content="http://yoursite.com/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230920181432749.png">
<meta property="og:image" content="http://yoursite.com/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230920181641350.png">
<meta property="og:image" content="http://yoursite.com/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230920181831605.png">
<meta property="og:image" content="http://yoursite.com/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230920175435337.png">
<meta property="og:image" content="http://yoursite.com/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230920182229743.png">
<meta property="og:image" content="http://yoursite.com/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230920175947360.png">
<meta property="og:image" content="http://yoursite.com/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230920182359385.png">
<meta property="og:image" content="http://yoursite.com/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230920183046400.png">
<meta property="og:image" content="http://yoursite.com/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230920183224156.png">
<meta property="og:image" content="http://yoursite.com/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230921174728434.png">
<meta property="og:image" content="http://yoursite.com/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230921175401894.png">
<meta property="og:image" content="http://yoursite.com/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230921172651650.png">
<meta property="og:image" content="http://yoursite.com/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20231010154154383.png">
<meta property="og:image" content="http://yoursite.com/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20231010154250327.png">
<meta property="og:image" content="http://yoursite.com/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20240318154740609.png">
<meta property="og:image" content="http://yoursite.com/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20240318155127794.png">
<meta property="og:image" content="http://yoursite.com/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20240319101749536.png">
<meta property="og:image" content="http://yoursite.com/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20240318155648375.png">
<meta property="og:image" content="http://yoursite.com/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20240319153521432.png">
<meta property="article:published_time" content="2023-07-03T02:07:32.000Z">
<meta property="article:modified_time" content="2025-06-25T08:08:45.890Z">
<meta property="article:author" content="Rui Zhang">
<meta property="article:tag" content="Spark">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230703100926094.png">

<link rel="canonical" href="http://yoursite.com/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true
  };
</script>

  <title>SparkCore笔记 | 没有尾巴的小驴</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">没有尾巴的小驴</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">记录生活</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">22</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">22</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">52</span></a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.jpg">
      <meta itemprop="name" content="Rui Zhang">
      <meta itemprop="description" content="不在沉默中爆发，就在沉默中灭亡">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="没有尾巴的小驴">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          SparkCore笔记
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-07-03 10:07:32" itemprop="dateCreated datePublished" datetime="2023-07-03T10:07:32+08:00">2023-07-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-06-25 16:08:45" itemprop="dateModified" datetime="2025-06-25T16:08:45+08:00">2025-06-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Spark/" itemprop="url" rel="index"><span itemprop="name">Spark</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>129k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>1:57</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="第1章-Spark-概述"><a href="#第1章-Spark-概述" class="headerlink" title="第1章 Spark 概述"></a>第1章 Spark 概述</h1><h2 id="1-1-Spark-是什么"><a href="#1-1-Spark-是什么" class="headerlink" title="1.1 Spark 是什么"></a>1.1 Spark 是什么</h2><p><img src="/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230703100926094.png" alt="image-20230703100926094"></p>
<p>Spark 是一种基于内存的快速、通用、可扩展的大数据分析计算引擎。  </p>
<h2 id="1-2-Spark-and-Hadoop"><a href="#1-2-Spark-and-Hadoop" class="headerlink" title="1.2 Spark and Hadoop"></a>1.2 Spark and Hadoop</h2><p>在之前的学习中， Hadoop 的 MapReduce 是大家广为熟知的计算框架，那为什么咱们还要学习新的计算框架 Spark 呢，这里就不得不提到 Spark 和 Hadoop 的关系。</p>
<p>首先从时间节点上来看:  </p>
<p>➢ Hadoop</p>
<ul>
<li>2006 年 1 月，Doug Cutting 加入 Yahoo，领导 Hadoop 的开发</li>
<li>2008 年 1 月，Hadoop 成为 Apache 顶级项目</li>
<li>2011 年 1.0 正式发布</li>
<li>2012 年 3 月稳定版发布</li>
<li>2013 年 10 月发布 2.X (Yarn)版本</li>
</ul>
<p>➢ Spark</p>
<ul>
<li>2009 年，Spark 诞生于伯克利大学的 AMPLab 实验室</li>
<li>2010 年，伯克利大学正式开源了 Spark 项目</li>
<li>2013 年 6 月，Spark 成为了 Apache 基金会下的项目</li>
<li>2014 年 2 月，Spark 以飞快的速度成为了 Apache 的顶级项目</li>
<li>2015 年至今，Spark 变得愈发火爆，大量的国内公司开始重点部署或者使用 Spark  </li>
</ul>
<p>然后我们再从功能上来看:  </p>
<p>➢ Hadoop  </p>
<ul>
<li>Hadoop 是由 java 语言编写的，在分布式服务器集群上存储海量数据并运行分布式分析应用的开源框架</li>
<li>作为 Hadoop 分布式文件系统， HDFS 处于 Hadoop 生态圈的最下层，存储着所有的数据 ， 支持着 Hadoop 的所有服务 。 它的理论基础源于 Google 的TheGoogleFileSystem 这篇论文，它是 GFS 的开源实现。</li>
<li>MapReduce 是一种编程模型，Hadoop 根据 Google 的 MapReduce 论文将其实现，作为 Hadoop 的分布式计算模型，是 Hadoop 的核心。基于这个框架，分布式并行程序的编写变得异常简单。综合了 HDFS 的分布式存储和 MapReduce 的分布式计算， Hadoop 在处理海量数据时， 性能横向扩展变得非常容易。</li>
<li>HBase 是对 Google 的 Bigtable 的开源实现，但又和 Bigtable 存在许多不同之处。HBase 是一个基于 HDFS 的分布式数据库，擅长实时地随机读/写超大规模数据集。它也是 Hadoop 非常重要的组件。</li>
</ul>
<p>➢ Spark</p>
<ul>
<li>Spark 是一种由 Scala 语言开发的快速、通用、可扩展的大数据分析引擎</li>
<li>Spark Core 中提供了 Spark 最基础与最核心的功能</li>
<li>Spark SQL 是 Spark 用来操作结构化数据的组件。通过 Spark SQL，用户可以使用SQL 或者 Apache Hive 版本的 SQL 方言（HQL）来查询数据。</li>
<li>Spark Streaming 是 Spark 平台上针对实时数据进行流式计算的组件，提供了丰富的处理数据流的 API。  </li>
</ul>
<p>由上面的信息可以获知，Spark 出现的时间相对较晚，并且主要功能主要是用于数据计算，所以其实 Spark 一直被认为是 Hadoop 框架的升级版。</p>
<h2 id="1-3-Spark-or-Hadoop"><a href="#1-3-Spark-or-Hadoop" class="headerlink" title="1.3 Spark or Hadoop"></a>1.3 Spark or Hadoop</h2><p>Hadoop 的 MR 框架和 Spark 框架都是数据处理框架，那么我们在使用时如何选择呢？  </p>
<ul>
<li>Hadoop MapReduce 由于其设计初衷并不是为了满足循环迭代式数据流处理，因此在多并行运行的数据可复用场景（如：机器学习、图挖掘算法、交互式数据挖掘算法）中存在诸多计算效率等问题。所以 Spark 应运而生， Spark 就是在传统的 MapReduce 计算框架的基础上，利用其计算过程的优化，从而大大加快了数据分析、挖掘的运行和读写速度，并将计算单元缩小到更适合并行计算和重复使用的 RDD 计算模型。  </li>
<li>机器学习中 ALS、凸优化梯度下降等。这些都需要基于数据集或者数据集的衍生数据反复查询反复操作。 MR 这种模式不太合适，即使多 MR 串行处理，性能和时间也是一个问题。数据的共享依赖于磁盘。另外一种是交互式数据挖掘， MR 显然不擅长。而Spark 所基于的 scala 语言恰恰擅长函数的处理。</li>
<li>Spark 是一个分布式数据快速分析项目。它的核心技术是弹性分布式数据集（Resilient Distributed Datasets），提供了比 MapReduce 丰富的模型，可以快速在内存中对数据集进行多次迭代，来支持复杂的数据挖掘算法和图形计算算法。</li>
<li>Spark 和Hadoop 的根本差异是多个作业之间的数据通信问题 : Spark 多个作业之间数据通信是基于内存，而 Hadoop 是基于磁盘。</li>
<li>Spark Task 的启动时间快。 Spark 采用 fork 线程的方式，而 Hadoop 采用创建新的进程的方式。</li>
<li>Spark 只有在 shuffle 的时候将数据写入磁盘，而 Hadoop 中多个 MR 作业之间的数据交互都要依赖于磁盘交互。</li>
<li>Spark 的缓存机制比 HDFS 的缓存机制高效。  </li>
</ul>
<p>经过上面的比较，我们可以看出在绝大多数的数据计算场景中，Spark 确实会比 MapReduce更有优势。但是 Spark 是基于内存的，所以在实际的生产环境中，由于内存的限制，可能会由于内存资源不够导致 Job 执行失败，此时，MapReduce 其实是一个更好的选择，所以 Spark 并不能完全替代 MR。</p>
<p><img src="/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230808165158945.png" alt="image-20230808165158945"></p>
<h2 id="1-4-Spark-核心模块"><a href="#1-4-Spark-核心模块" class="headerlink" title="1.4 Spark 核心模块"></a>1.4 Spark 核心模块</h2><p><img src="/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230703101852435.png" alt="image-20230703101852435"></p>
<p>➢ Spark Core<br>Spark Core 中提供了 Spark 最基础与最核心的功能， Spark 其他的功能如： Spark SQL，Spark Streaming， GraphX, MLlib 都是在 Spark Core 的基础上进行扩展的。<br>➢ Spark SQL<br>Spark SQL 是 Spark 用来操作结构化数据的组件。通过 Spark SQL，用户可以使用 SQL或者 Apache Hive 版本的 SQL 方言（HQL）来查询数据。<br>➢ Spark Streaming<br>Spark Streaming 是 Spark 平台上针对实时数据进行流式计算的组件，提供了丰富的处理数据流的 API。<br>➢ Spark MLlib<br>MLlib 是 Spark 提供的一个机器学习算法库。 MLlib 不仅提供了模型评估、数据导入等额外的功能，还提供了一些更底层的机器学习原语。<br>➢ Spark GraphX<br>GraphX 是 Spark 面向图计算提供的框架与算法库。  </p>
<h1 id="第2章-Spark-快速上手"><a href="#第2章-Spark-快速上手" class="headerlink" title="第2章 Spark 快速上手"></a>第2章 Spark 快速上手</h1><p>在大数据早期的课程中我们已经学习了 MapReduce 框架的原理及基本使用，并了解了其底层数据处理的实现方式。接下来，就让咱们走进 Spark 的世界，了解一下它是如何带领我们完成数据处理的。  </p>
<h2 id="2-1-创建-Maven-项目"><a href="#2-1-创建-Maven-项目" class="headerlink" title="2.1 创建 Maven 项目"></a>2.1 创建 Maven 项目</h2><h3 id="2-1-1-增加-Scala-插件"><a href="#2-1-1-增加-Scala-插件" class="headerlink" title="2.1.1 增加 Scala 插件"></a>2.1.1 增加 Scala 插件</h3><p>Spark 由 Scala 语言开发的，所以本课件接下来的开发所使用的语言也为 Scala， 咱们当前使用的 Spark 版本为 3.0.0，默认采用的 Scala 编译版本为 2.12，所以后续开发时。我们依然采用这个版本。 开发前请保证 IDEA 开发工具中含有 Scala 开发插件  </p>
<p><img src="/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230703102013757.png" alt="image-20230703102013757"></p>
<h3 id="2-1-2-增加依赖关系"><a href="#2-1-2-增加依赖关系" class="headerlink" title="2.1.2 增加依赖关系"></a>2.1.2 增加依赖关系</h3><p>修改 Maven 项目中的 POM 文件，增加 Spark 框架的依赖关系。 本课件基于 Spark3.0 版本，使用时请注意对应版本。  </p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.spark<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spark-core_2.12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.0.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 该插件用于将 Scala 代码编译成 class 文件 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>net.alchim31.maven<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>scala-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                    <span class="comment">&lt;!-- 声明绑定到 maven 的 compile 阶段 --&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                    	<span class="tag">&lt;<span class="name">goal</span>&gt;</span>testCompile<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>maven-assembly-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">version</span>&gt;</span>3.1.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">descriptorRefs</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">descriptorRef</span>&gt;</span>jar-with-dependencies<span class="tag">&lt;/<span class="name">descriptorRef</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">descriptorRefs</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">executions</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">execution</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">id</span>&gt;</span>make-assembly<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">phase</span>&gt;</span>package<span class="tag">&lt;/<span class="name">phase</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">goals</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">goal</span>&gt;</span>single<span class="tag">&lt;/<span class="name">goal</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">goals</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">execution</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">executions</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-1-3-WordCount"><a href="#2-1-3-WordCount" class="headerlink" title="2.1.3 WordCount"></a>2.1.3 WordCount</h3><p><img src="/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230808165613169.png" alt="image-20230808165613169"></p>
<p>为了能直观地感受 Spark 框架的效果，接下来我们实现一个大数据学科中最常见的教学案例 WordCount  </p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建 Spark 运行配置对象</span></span><br><span class="line"><span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">"local[*]"</span>).setAppName(<span class="string">"WordCount"</span>)</span><br><span class="line"><span class="comment">// 创建 Spark 上下文环境对象（连接对象）</span></span><br><span class="line"><span class="keyword">val</span> sc : <span class="type">SparkContext</span> = <span class="keyword">new</span> <span class="type">SparkContext</span>(sparkConf)</span><br><span class="line"><span class="comment">// 读取文件数据</span></span><br><span class="line"><span class="keyword">val</span> fileRDD: <span class="type">RDD</span>[<span class="type">String</span>] = sc.textFile(<span class="string">"input/word.txt"</span>)</span><br><span class="line"><span class="comment">// 将文件中的数据进行分词</span></span><br><span class="line"><span class="keyword">val</span> wordRDD: <span class="type">RDD</span>[<span class="type">String</span>] = fileRDD.flatMap(_.split(<span class="string">" "</span>))</span><br><span class="line"><span class="comment">// 转换数据结构 word =&gt; (word, 1)</span></span><br><span class="line"><span class="keyword">val</span> word2OneRDD: <span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = wordRDD.map((_,<span class="number">1</span>))</span><br><span class="line"><span class="comment">// 将转换结构后的数据按照相同的单词进行分组聚合</span></span><br><span class="line"><span class="keyword">val</span> word2CountRDD: <span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = word2OneRDD.reduceByKey(_+_)</span><br><span class="line"><span class="comment">// 将数据聚合结果采集到内存中</span></span><br><span class="line"><span class="keyword">val</span> word2Count: <span class="type">Array</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = word2CountRDD.collect()</span><br><span class="line"><span class="comment">// 打印结果</span></span><br><span class="line">word2Count.foreach(println)</span><br><span class="line"><span class="comment">//关闭 Spark 连接</span></span><br><span class="line">sc.stop()</span><br></pre></td></tr></table></figure>

<p>练习与测试</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spark.core.wc</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.rdd.<span class="type">RDD</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Spark01_WordCount</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">// TODO 建立和Spark框架的连接</span></span><br><span class="line">    <span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">"local"</span>).setAppName(<span class="string">"WordCount"</span>)</span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(sparkConf)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 执行业务操作</span></span><br><span class="line">    <span class="comment">// 1. 读取文件，获取一行一行的数据</span></span><br><span class="line">    <span class="comment">// hello world</span></span><br><span class="line">    <span class="keyword">val</span> lines = sc.textFile(<span class="string">"datas"</span>)</span><br><span class="line">    <span class="comment">// 2. 将一行数据切割，进行分词</span></span><br><span class="line">    <span class="comment">// "hello world" =&gt; hello, world,hello,world</span></span><br><span class="line">    <span class="comment">// 扁平化：将整体拆分成个体的操作</span></span><br><span class="line">    <span class="keyword">val</span> words: <span class="type">RDD</span>[<span class="type">String</span>] = lines.flatMap(_.split(<span class="string">" "</span>))</span><br><span class="line">    <span class="comment">// 3. 将数据根据单词进行分组，便于分组</span></span><br><span class="line">    <span class="comment">// (hello,hello),(world,world)</span></span><br><span class="line">    <span class="keyword">val</span> wordGroup: <span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">Iterable</span>[<span class="type">String</span>])] = words.groupBy(word =&gt; word)</span><br><span class="line">    <span class="comment">// 4. 对分组后的数据进行转换</span></span><br><span class="line">    <span class="comment">// (hello,2),(world,2)</span></span><br><span class="line">    <span class="keyword">val</span> wordToCount = wordGroup.map &#123;</span><br><span class="line">      <span class="keyword">case</span> (word, list) =&gt; (word, list.size)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 5. 将转换结果采集到控制台打印出来</span></span><br><span class="line">    <span class="keyword">val</span> array = wordToCount.collect()</span><br><span class="line">    array.foreach(println)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 关闭连接</span></span><br><span class="line">    sc.stop()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spark.core.wc</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.rdd.<span class="type">RDD</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Spark02_WordCount</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">// TODO 建立和Spark框架的连接</span></span><br><span class="line">    <span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">"local"</span>).setAppName(<span class="string">"WordCount"</span>)</span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(sparkConf)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 执行业务操作</span></span><br><span class="line">    <span class="keyword">val</span> lines: <span class="type">RDD</span>[<span class="type">String</span>] = sc.textFile(<span class="string">"datas"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> words: <span class="type">RDD</span>[<span class="type">String</span>] = lines.flatMap(_.split(<span class="string">" "</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> wordToOne = words.map(word =&gt; (word, <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> wordGroup: <span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">Iterable</span>[(<span class="type">String</span>, <span class="type">Int</span>)])] = wordToOne.groupBy(t =&gt; t._1)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> wordToCount: <span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = wordGroup.map &#123;</span><br><span class="line">      <span class="keyword">case</span> (word, list) =&gt; &#123;</span><br><span class="line">        list.reduce(</span><br><span class="line">          (t1, t2) =&gt; &#123;</span><br><span class="line">            (t1._1, t1._2 + t2._2)</span><br><span class="line">          &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// val wordToCount = wordGroup.mapValues(_.map(_._2).sum)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> array: <span class="type">Array</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = wordToCount.collect()</span><br><span class="line">    array.foreach(println)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 关闭连接</span></span><br><span class="line">    sc.stop()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spark.core.wc</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.rdd.<span class="type">RDD</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Spark03_WordCount</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">// TODO 建立和Spark框架的连接</span></span><br><span class="line">    <span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">"local"</span>).setAppName(<span class="string">"WordCount"</span>)</span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(sparkConf)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 执行业务操作</span></span><br><span class="line">    <span class="keyword">val</span> lines: <span class="type">RDD</span>[<span class="type">String</span>] = sc.textFile(<span class="string">"datas"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> words: <span class="type">RDD</span>[<span class="type">String</span>] = lines.flatMap(_.split(<span class="string">" "</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> wordToOne: <span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = words.map(word =&gt; (word, <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Spark框架提供了更多功能，可以将分组和聚合使用一个方法实现</span></span><br><span class="line">    <span class="comment">// reduceByKey：Spar k框架提供的功能，相同的key的数据，可以对value进行reduce聚合</span></span><br><span class="line">    <span class="keyword">val</span> wordToCount: <span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = wordToOne.reduceByKey(_ + _)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> array: <span class="type">Array</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = wordToCount.collect()</span><br><span class="line">    array.foreach(println)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 关闭连接</span></span><br><span class="line">    sc.stop()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行过程中，会产生大量的执行日志，如果为了能够更好的查看程序的执行结果，可以在项目的 resources 目录中创建 log4j.properties 文件，并添加日志配置信息：  </p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">log4j.rootCategory</span>=<span class="string">ERROR, console</span></span><br><span class="line"><span class="meta">log4j.appender.console</span>=<span class="string">org.apache.log4j.ConsoleAppender</span></span><br><span class="line"><span class="meta">log4j.appender.console.target</span>=<span class="string">System.err</span></span><br><span class="line"><span class="meta">log4j.appender.console.layout</span>=<span class="string">org.apache.log4j.PatternLayout</span></span><br><span class="line"><span class="meta">log4j.appender.console.layout.ConversionPattern</span>=<span class="string">%d&#123;yy/MM/dd</span></span><br><span class="line"><span class="attr">HH</span>:<span class="string">mm:ss&#125; %p %c&#123;1&#125;: %m%n</span></span><br><span class="line"><span class="comment"># Set the default spark-shell log level to ERROR. When running the spark-shell,</span></span><br><span class="line"><span class="attr">the</span></span><br><span class="line"><span class="comment"># log level for this class is used to overwrite the root logger's log level, so</span></span><br><span class="line"><span class="attr">that</span></span><br><span class="line"><span class="comment"># the user can have different defaults for the shell and regular Spark apps.</span></span><br><span class="line"><span class="meta">log4j.logger.org.apache.spark.repl.Main</span>=<span class="string">ERROR</span></span><br><span class="line"><span class="comment"># Settings to quiet third party logs that are too verbose</span></span><br><span class="line"><span class="meta">log4j.logger.org.spark_project.jetty</span>=<span class="string">ERROR</span></span><br><span class="line"><span class="meta">log4j.logger.org.spark_project.jetty.util.component.AbstractLifeCycle</span>=<span class="string">ERROR</span></span><br><span class="line"><span class="meta">log4j.logger.org.apache.spark.repl.SparkIMain$exprTyper</span>=<span class="string">ERROR</span></span><br><span class="line"><span class="meta">log4j.logger.org.apache.spark.repl.SparkILoop$SparkILoopInterpreter</span>=<span class="string">ERROR</span></span><br><span class="line"><span class="meta">log4j.logger.org.apache.parquet</span>=<span class="string">ERROR</span></span><br><span class="line"><span class="meta">log4j.logger.parquet</span>=<span class="string">ERROR</span></span><br><span class="line"><span class="comment"># SPARK-9183: Settings to avoid annoying messages when looking up nonexistent</span></span><br><span class="line"><span class="attr">UDFs</span> <span class="string">in SparkSQL with Hive support</span></span><br><span class="line"><span class="meta">log4j.logger.org.apache.hadoop.hive.metastore.RetryingHMSHandler</span>=<span class="string">FATAL</span></span><br><span class="line"><span class="meta">log4j.logger.org.apache.hadoop.hive.ql.exec.FunctionRegistry</span>=<span class="string">ERROR</span></span><br></pre></td></tr></table></figure>

<h3 id="2-1-4-异常处理"><a href="#2-1-4-异常处理" class="headerlink" title="2.1.4 异常处理"></a>2.1.4 异常处理</h3><p>如果本机操作系统是 Windows，在程序中使用了 Hadoop 相关的东西，比如写入文件到HDFS，则会遇到如下异常：  </p>
<p><img src="/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230703103646750.png" alt="image-20230703103646750"></p>
<p>出现这个问题的原因，并不是程序的错误，而是 windows 系统用到了 hadoop 相关的服务，解决办法是通过配置关联到 windows 的系统依赖就可以了  </p>
<p><img src="/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230703103728395.png" alt="image-20230703103728395"></p>
<p><img src="/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230703103711386.png" alt="image-20230703103711386"></p>
<h1 id="第3章-Spark-运行环境"><a href="#第3章-Spark-运行环境" class="headerlink" title="第3章 Spark 运行环境"></a>第3章 Spark 运行环境</h1><p>Spark 作为一个数据处理框架和计算引擎，被设计在所有常见的集群环境中运行, 在国内工作中主流的环境为 Yarn，不过逐渐容器式环境也慢慢流行起来。接下来，我们就分别看看不同环境下 Spark 的运行</p>
<p><img src="/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230703104007807.png" alt="image-20230703104007807"></p>
<h2 id="3-1-Local-模式"><a href="#3-1-Local-模式" class="headerlink" title="3.1 Local 模式"></a>3.1 Local 模式</h2><p>之前一直在使用的模式可不是 Local 模式哟。所谓的 Local 模式，就是不需要其他任何节点资源就可以在本地执行 Spark 代码的环境，一般用于教学，调试，演示等，之前在 IDEA 中运行代码的环境我们称之为开发环境，不太一样。  </p>
<h3 id="3-1-1-解压缩文件"><a href="#3-1-1-解压缩文件" class="headerlink" title="3.1.1 解压缩文件"></a>3.1.1 解压缩文件</h3><p>将 spark-3.0.0-bin-hadoop3.2.tgz 文件上传到 Linux 并解压缩，放置在指定位置，路径中不要包含中文或空格，后续如果涉及到解压缩操作，不再强调。  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf spark-3.0.0-bin-hadoop3.2.tgz -C /opt/module</span><br><span class="line">cd /opt/module</span><br><span class="line">mv spark-3.0.0-bin-hadoop3.2 spark-local</span><br></pre></td></tr></table></figure>

<h3 id="3-1-2-启动-Local-环境"><a href="#3-1-2-启动-Local-环境" class="headerlink" title="3.1.2 启动 Local 环境"></a>3.1.2 启动 Local 环境</h3><p>1) 进入解压缩后的路径，执行如下指令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bin/spark-shell</span><br></pre></td></tr></table></figure>

<p><img src="/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230703104122494.png" alt="image-20230703104122494"></p>
<p>2) 启动成功后，可以输入网址进行 Web UI 监控页面访问  </p>
<p><img src="/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230703104146054.png" alt="image-20230703104146054"></p>
<h3 id="3-1-3-命令行工具"><a href="#3-1-3-命令行工具" class="headerlink" title="3.1.3 命令行工具"></a>3.1.3 命令行工具</h3><p>在解压缩文件夹下的 data 目录中，添加 word.txt 文件。在命令行工具中执行如下代码指令（和 IDEA 中代码简化版一致）  </p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc.textFile(<span class="string">"data/word.txt"</span>).flatMap(_.split(<span class="string">" "</span>)).map((_,<span class="number">1</span>)).reduceByKey(_+_).collect</span><br></pre></td></tr></table></figure>

<p><img src="/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230703105636460.png" alt="image-20230703105636460"></p>
<h3 id="3-1-4-退出本地模式"><a href="#3-1-4-退出本地模式" class="headerlink" title="3.1.4 退出本地模式"></a>3.1.4 退出本地模式</h3><p>按键 Ctrl+C 或 输入 Scala 指令  <code>:quit</code></p>
<h3 id="3-1-5-提交应用"><a href="#3-1-5-提交应用" class="headerlink" title="3.1.5 提交应用"></a>3.1.5 提交应用</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bin/spark-submit \</span><br><span class="line">--class org.apache.spark.examples.SparkPi \</span><br><span class="line">--master local[2] \</span><br><span class="line">./examples/jars/spark-examples_2.12-3.0.0.jar \</span><br><span class="line">10</span><br></pre></td></tr></table></figure>

<ol>
<li><p>–class 表示要执行程序的主类，此处可以更换为咱们自己写的应用程序</p>
</li>
<li><p>-master local[2] 部署模式，默认为本地模式，数字表示分配的虚拟 CPU 核数量</p>
</li>
<li><p>spark-examples_2.12-3.0.0.jar 运行的应用类所在的 jar 包，实际使用时，可以设定为咱们自己打的 jar 包</p>
</li>
<li><p>数字 10 表示程序的入口参数，用于设定当前应用的任务数量</p>
</li>
</ol>
<p><img src="/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230703104450249.png" alt="image-20230703104450249"></p>
<h2 id="3-2-Standalone-模式"><a href="#3-2-Standalone-模式" class="headerlink" title="3.2 Standalone 模式"></a>3.2 Standalone 模式</h2><p>local 本地模式毕竟只是用来进行练习演示的，真实工作中还是要将应用提交到对应的集群中去执行，这里我们来看看只使用 Spark 自身节点运行的集群模式，也就是我们所谓的独立部署（Standalone）模式。 Spark 的 Standalone 模式体现了经典的 master-slave 模式。集群规划：</p>
<p><img src="/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230703104520230.png" alt="image-20230703104520230"></p>
<h3 id="3-2-1-解压缩文件"><a href="#3-2-1-解压缩文件" class="headerlink" title="3.2.1 解压缩文件"></a>3.2.1 解压缩文件</h3><p>将 spark-3.0.0-bin-hadoop3.2.tgz 文件上传到 Linux 并解压缩在指定位置  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf spark-3.0.0-bin-hadoop3.2.tgz -C /opt/module</span><br><span class="line">cd /opt/module</span><br><span class="line">mv spark-3.0.0-bin-hadoop3.2 spark-standalone</span><br></pre></td></tr></table></figure>

<h3 id="3-2-2-修改配置文件"><a href="#3-2-2-修改配置文件" class="headerlink" title="3.2.2 修改配置文件"></a>3.2.2 修改配置文件</h3><p>1) 进入解压缩后路径的 conf 目录，修改 slaves.template 文件名为 slaves  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv slaves.template slaves</span><br></pre></td></tr></table></figure>

<p>2) 修改 slaves 文件，添加 work 节点  </p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">linux1</span></span><br><span class="line"><span class="attr">linux2</span></span><br><span class="line"><span class="attr">linux3</span></span><br></pre></td></tr></table></figure>

<p>3) 修改 spark-env.sh.template 文件名为 spark-env.sh  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv spark-env.sh.template spark-env.sh</span><br></pre></td></tr></table></figure>

<p>4) 修改 spark-env.sh 文件，添加 JAVA_HOME 环境变量和集群对应的 master 节点  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/opt/module/jdk1.8.0_144</span><br><span class="line">SPARK_MASTER_HOST=linux1</span><br><span class="line">SPARK_MASTER_PORT=7077</span><br></pre></td></tr></table></figure>

<p>注意： 7077 端口，相当于 hadoop 内部通信的 8020 端口，此处的端口需要确认自己的 Hadoop配置  </p>
<p>5) 分发 spark-standalone 目录  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xsync spark-standalone</span><br></pre></td></tr></table></figure>

<h3 id="3-2-3-启动集群"><a href="#3-2-3-启动集群" class="headerlink" title="3.2.3 启动集群"></a>3.2.3 启动集群</h3><p>1) 执行脚本命令：  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sbin/start-all.sh</span><br></pre></td></tr></table></figure>

<p><img src="/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230703104752985.png" alt="image-20230703104752985"></p>
<p>2) 查看三台服务器运行进程  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">================linux1================</span><br><span class="line">3330 Jps</span><br><span class="line">3238 Worker</span><br><span class="line">3163 Master</span><br><span class="line">================linux2================</span><br><span class="line">2966 Jps</span><br><span class="line">2908 Worker</span><br><span class="line">================linux3================</span><br><span class="line">2978 Worker</span><br><span class="line">3036 Jps</span><br></pre></td></tr></table></figure>

<p>3) 查看 Master 资源监控 Web UI 界面: <a href="http://linux1:8080" target="_blank" rel="noopener">http://linux1:8080</a>  </p>
<p><img src="/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230703104849386.png" alt="image-20230703104849386"></p>
<h3 id="3-2-4-提交应用"><a href="#3-2-4-提交应用" class="headerlink" title="3.2.4 提交应用"></a>3.2.4 提交应用</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bin/spark-submit \</span><br><span class="line">--class org.apache.spark.examples.SparkPi \</span><br><span class="line">--master spark://linux1:7077 \</span><br><span class="line">./examples/jars/spark-examples_2.12-3.0.0.jar \</span><br><span class="line">10</span><br></pre></td></tr></table></figure>

<p>1) –class 表示要执行程序的主类<br>2) –master spark://linux1:7077 独立部署模式，连接到 Spark 集群<br>3) spark-examples_2.12-3.0.0.jar 运行类所在的 jar 包<br>4) 数字 10 表示程序的入口参数，用于设定当前应用的任务数量  </p>
<p><img src="/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230703104947119.png" alt="image-20230703104947119"></p>
<p>执行任务时，会产生多个 Java 进程  </p>
<p><img src="/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230703104935967.png" alt="image-20230703104935967"></p>
<p>执行任务时，默认采用服务器集群节点的总核数，每个节点内存 1024M。  </p>
<p><img src="/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230703105008718.png" alt="image-20230703105008718"></p>
<h3 id="3-2-5-提交参数说明"><a href="#3-2-5-提交参数说明" class="headerlink" title="3.2.5 提交参数说明"></a>3.2.5 提交参数说明</h3><p>在提交应用中，一般会同时一些提交参数  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bin/spark-submit \</span><br><span class="line">--class &lt;main-class&gt;</span><br><span class="line">--master &lt;master-url&gt; \</span><br><span class="line">... # other options</span><br><span class="line">&lt;application-jar&gt; \</span><br><span class="line">[application-arguments]</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="left">参数</th>
<th align="left">解释</th>
<th align="left">可选值举例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">–class</td>
<td align="left">Spark 程序中包含主函数的类</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">–master</td>
<td align="left">Spark 程序运行的模式(环境)</td>
<td align="left">模式：local[*]、spark://linux1:7077、Yarn</td>
</tr>
<tr>
<td align="left">–executor-memory 1G</td>
<td align="left">指定每个 executor 可用内存为 1G</td>
<td align="left">符合集群内存配置即可，具体情况具体分析。</td>
</tr>
<tr>
<td align="left">–total-executor-cores 2</td>
<td align="left">指定所有executor使用的cpu核数  为 2 个</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">–executor-cores</td>
<td align="left">指定每个executor使用的cpu核数</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">–num-executors</td>
<td align="left">配置 Executor 的数量</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">application-jar</td>
<td align="left">打包好的应用 jar，包含依赖。这 个 URL 在集群中全局可见。 比 如 hdfs:// 共享存储系统，如果是file:// path，那么所有的节点的 path 都包含同样的 jar</td>
<td align="left"></td>
</tr>
<tr>
<td align="left">application-arguments</td>
<td align="left">传给 main()方法的参数</td>
<td align="left"></td>
</tr>
</tbody></table>
<h3 id="3-2-6-配置历史服务"><a href="#3-2-6-配置历史服务" class="headerlink" title="3.2.6 配置历史服务"></a>3.2.6 配置历史服务</h3><p>由于 spark-shell 停止掉后， 集群监控 linux1:4040 页面就看不到历史任务的运行情况，所以开发时都配置历史服务器记录任务运行情况。  </p>
<p>1) 修改 spark-defaults.conf.template 文件名为 spark-defaults.conf</p>
   <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv spark-defaults.conf.template spark-defaults.conf</span><br></pre></td></tr></table></figure>

<p>2) 修改 spark-default.conf 文件，配置日志存储路径  </p>
   <figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spark.eventLog.enabled</span> <span class="string">true</span></span><br><span class="line"><span class="meta">spark.eventLog.dir</span> <span class="string">hdfs://linux1:8020/directory</span></span><br></pre></td></tr></table></figure>

<p>   注意：需要启动 hadoop 集群， HDFS 上的 directory 目录需要提前存在。  </p>
   <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sbin/start-dfs.sh</span><br><span class="line">hadoop fs -mkdir /directory</span><br></pre></td></tr></table></figure>

<p>3) 修改 spark-env.sh 文件, 添加日志配置  </p>
   <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">export SPARK_HISTORY_OPTS="</span><br><span class="line">-Dspark.history.ui.port=18080</span><br><span class="line">-Dspark.history.fs.logDirectory=hdfs://linux1:8020/directory</span><br><span class="line">-Dspark.history.retainedApplications=30"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 参数 1 含义： WEB UI 访问的端口号为 18080</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 参数 2 含义：指定历史服务器日志存储路径</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 参数 3 含义：指定保存 Application 历史记录的个数，如果超过这个值，旧的应用程序信息将被删除，这个是内存中的应用数，而不是页面上显示的应用数。</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li><p>分发配置文件</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xsync conf</span><br></pre></td></tr></table></figure>
</li>
<li><p>重新启动集群和历史服务  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sbin/start-all.sh</span><br><span class="line">sbin/start-history-server.sh</span><br></pre></td></tr></table></figure>
</li>
<li><p>重新执行任务  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bin/spark-submit \</span><br><span class="line">--class org.apache.spark.examples.SparkPi \</span><br><span class="line">--master spark://linux1:7077 \</span><br><span class="line">./examples/jars/spark-examples_2.12-3.0.0.jar \</span><br><span class="line">10</span><br></pre></td></tr></table></figure>

<p><img src="/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230705153212251.png" alt="image-20230705153212251"></p>
</li>
<li><p>查看历史服务： <a href="http://linux1:18080" target="_blank" rel="noopener">http://linux1:18080</a></p>
<p><img src="/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230705153250449.png" alt="image-20230705153250449"></p>
</li>
</ol>
<h3 id="3-2-7-配置高可用（-HA）"><a href="#3-2-7-配置高可用（-HA）" class="headerlink" title="3.2.7 配置高可用（ HA）"></a>3.2.7 配置高可用（ HA）</h3><p>所谓的高可用是因为当前集群中的 Master 节点只有一个，所以会存在单点故障问题。 所以为了解决单点故障问题，需要在集群中配置多个 Master 节点，一旦处于活动状态的 Master发生故障时，由备用 Master 提供服务，保证作业可以继续执行。 这里的高可用一般采用Zookeeper 设置。</p>
<p>集群规划:  </p>
<p><img src="/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230705153321493.png" alt="image-20230705153321493"></p>
<p>1) 停止集群  </p>
   <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sbin/stop-all.sh</span><br></pre></td></tr></table></figure>

<p>2) 启动 Zookeeper  </p>
   <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xstart zk</span><br></pre></td></tr></table></figure>

<p>3) 修改 spark-env.sh 文件添加如下配置  </p>
   <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 注释如下内容：</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> SPARK_MASTER_HOST=linux1</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> SPARK_MASTER_PORT=7077</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加如下内容:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Master 监控页面默认访问端口为 8080，但是可能会和 Zookeeper 冲突，所以改成 8989，也可以自定义，访问 UI 监控页面时请注意</span></span><br><span class="line">SPARK_MASTER_WEBUI_PORT=8989</span><br><span class="line"></span><br><span class="line">export SPARK_DAEMON_JAVA_OPTS="</span><br><span class="line">-Dspark.deploy.recoveryMode=ZOOKEEPER</span><br><span class="line">-Dspark.deploy.zookeeper.url=linux1,linux2,linux3</span><br><span class="line">-Dspark.deploy.zookeeper.dir=/spark"</span><br></pre></td></tr></table></figure>

<p>4) 分发配置文件  </p>
   <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xsync conf/</span><br></pre></td></tr></table></figure>

<p>5) 启动集群  </p>
   <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sbin/start-all.sh</span><br></pre></td></tr></table></figure>

<p>   <img src="/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230705153720036.png" alt="image-20230705153720036"></p>
<p>6) 启动 linux2 的单独 Master 节点，此时 linux2 节点 Master 状态处于备用状态  </p>
   <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@linux2 spark-standalone]# sbin/start-master.sh</span><br></pre></td></tr></table></figure>

<p>   <img src="/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230705153803504.png" alt="image-20230705153803504"></p>
<p>7) 提交应用到高可用集群  </p>
   <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">bin/spark-submit \</span><br><span class="line">--class org.apache.spark.examples.SparkPi \</span><br><span class="line">--master spark://linux1:7077,linux2:7077 \</span><br><span class="line">./examples/jars/spark-examples_2.12-3.0.0.jar \</span><br><span class="line">10</span><br></pre></td></tr></table></figure>

<p>8) 停止 linux1 的 Master 资源监控进程  </p>
<p>   <img src="/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230705153950847.png" alt="image-20230705153950847"></p>
<p>9) 查看 linux2 的 Master 资源监控 Web UI，稍等一段时间后， linux2 节点的 Master 状态提升为活动状态  </p>
<p>   <img src="/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230705154022313.png" alt="image-20230705154022313"></p>
<h2 id="3-3-Yarn-模式"><a href="#3-3-Yarn-模式" class="headerlink" title="3.3 Yarn 模式"></a>3.3 Yarn 模式</h2><p>独立部署（Standalone）模式由 Spark 自身提供计算资源，无需其他框架提供资源。 这种方式降低了和其他第三方资源框架的耦合性，独立性非常强。但是你也要记住， Spark 主要是计算框架，而不是资源调度框架，所以本身提供的资源调度并不是它的强项，所以还是和其他专业的资源调度框架集成会更靠谱一些。 所以接下来我们来学习在强大的 Yarn 环境下 Spark 是如何工作的（其实是因为在国内工作中，Yarn 使用的非常多）。  </p>
<h3 id="3-3-1-解压缩文件"><a href="#3-3-1-解压缩文件" class="headerlink" title="3.3.1 解压缩文件"></a>3.3.1 解压缩文件</h3><p>将 spark-3.0.0-bin-hadoop3.2.tgz 文件上传到 linux 并解压缩，放置在指定位置。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf spark-3.0.0-bin-hadoop3.2.tgz -C /opt/module</span><br><span class="line">cd /opt/module</span><br><span class="line">mv spark-3.0.0-bin-hadoop3.2 spark-yarn</span><br></pre></td></tr></table></figure>

<h3 id="3-3-2-修改配置文件"><a href="#3-3-2-修改配置文件" class="headerlink" title="3.3.2 修改配置文件"></a>3.3.2 修改配置文件</h3><p>1) 修改 hadoop 配置文件/opt/module/hadoop/etc/hadoop/yarn-site.xml, 并分发 </p>
   <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--是否启动一个线程检查每个任务正使用的物理内存量，如果任务超出分配值，则直接将其杀掉，默认是 true --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.pmem-check-enabled<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>false<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--是否启动一个线程检查每个任务正使用的虚拟内存量，如果任务超出分配值，则直接将其杀掉，默认是 true --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>yarn.nodemanager.vmem-check-enabled<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>false<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>2) 修改 conf/spark-env.sh，添加 JAVA_HOME 和 YARN_CONF_DIR 配置  </p>
   <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mv spark-env.sh.template spark-env.sh</span><br><span class="line">... ...</span><br><span class="line">export JAVA_HOME=/opt/module/jdk1.8.0_144</span><br><span class="line">YARN_CONF_DIR=/opt/module/hadoop/etc/hadoop</span><br></pre></td></tr></table></figure>

<h3 id="3-3-3-启动-HDFS-以及-YARN-集群"><a href="#3-3-3-启动-HDFS-以及-YARN-集群" class="headerlink" title="3.3.3 启动 HDFS 以及 YARN 集群"></a>3.3.3 启动 HDFS 以及 YARN 集群</h3><p>请自己配置并启动</p>
<h3 id="3-3-4-提交应用"><a href="#3-3-4-提交应用" class="headerlink" title="3.3.4 提交应用"></a>3.3.4 提交应用</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bin/spark-submit \</span><br><span class="line">--class org.apache.spark.examples.SparkPi \</span><br><span class="line">--master yarn \</span><br><span class="line">--deploy-mode cluster \</span><br><span class="line">./examples/jars/spark-examples_2.12-3.0.0.jar \</span><br><span class="line">10</span><br></pre></td></tr></table></figure>

<p><img src="/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230705154429977.png" alt="image-20230705154429977"></p>
<p>查看 <a href="http://linux2:8088" target="_blank" rel="noopener">http://linux2:8088</a> 页面，点击 History，查看历史页面</p>
<p><img src="/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230705154452542.png" alt="image-20230705154452542"></p>
<p><img src="/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230705154542440.png" alt="image-20230705154542440"></p>
<h3 id="3-3-5-配置历史服务器"><a href="#3-3-5-配置历史服务器" class="headerlink" title="3.3.5 配置历史服务器"></a>3.3.5 配置历史服务器</h3><p>1) 修改 spark-defaults.conf.template 文件名为 spark-defaults.conf  </p>
   <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mv spark-defaults.conf.template spark-defaults.conf</span><br></pre></td></tr></table></figure>

<p>2) 修改 spark-default.conf 文件，配置日志存储路径  </p>
   <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spark.eventLog.enabled true</span><br><span class="line">spark.eventLog.dir hdfs://linux1:8020/directory</span><br></pre></td></tr></table></figure>

<p>   注意：需要启动 hadoop 集群， HDFS 上的目录需要提前存在。  </p>
   <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@linux1 hadoop]# sbin/start-dfs.sh</span><br><span class="line">[root@linux1 hadoop]# hadoop fs -mkdir /directory</span><br></pre></td></tr></table></figure>

<p>3) 修改 spark-env.sh 文件, 添加日志配置  </p>
   <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">export SPARK_HISTORY_OPTS="</span><br><span class="line">-Dspark.history.ui.port=18080</span><br><span class="line">-Dspark.history.fs.logDirectory=hdfs://linux1:8020/directory</span><br><span class="line">-Dspark.history.retainedApplications=30"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 参数 1 含义： WEB UI 访问的端口号为 18080</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 参数 2 含义：指定历史服务器日志存储路径</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 参数 3 含义：指定保存 Application 历史记录的个数，如果超过这个值，旧的应用程序信息将被删除，这个是内存中的应用数，而不是页面上显示的应用数。</span></span><br></pre></td></tr></table></figure>

<p>4) 修改 spark-defaults.conf  </p>
   <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">spark.yarn.historyServer.address=linux1:18080</span><br><span class="line">spark.history.ui.port=18080</span><br></pre></td></tr></table></figure>

<p>5) 启动历史服务  </p>
   <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sbin/start-history-server.sh</span><br></pre></td></tr></table></figure>

<p>6) 重新提交应用  </p>
   <figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">bin/spark-submit \</span><br><span class="line">--class org.apache.spark.examples.SparkPi \</span><br><span class="line">--master yarn \</span><br><span class="line">--deploy-mode client \</span><br><span class="line">./examples/jars/spark-examples_2.12-3.0.0.jar \</span><br><span class="line">10</span><br></pre></td></tr></table></figure>

<p>   <img src="/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230705154917101.png" alt="image-20230705154917101"></p>
<p>7) Web 页面查看日志： <a href="http://linux2:8088" target="_blank" rel="noopener">http://linux2:8088</a>  </p>
<p>   <img src="/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230705154947955.png" alt="image-20230705154947955"></p>
<h2 id="3-4-K8S-amp-Mesos-模式"><a href="#3-4-K8S-amp-Mesos-模式" class="headerlink" title="3.4 K8S &amp; Mesos 模式"></a>3.4 K8S &amp; Mesos 模式</h2><p>Mesos 是 Apache 下的开源分布式资源管理框架，它被称为是分布式系统的内核,在Twitter 得到广泛使用,管理着 Twitter 超过 30,0000 台服务器上的应用部署，但是在国内，依然使用着传统的 Hadoop 大数据框架，所以国内使用 Mesos 框架的并不多， 但是原理其实都差不多， 这里我们就不做过多讲解了。</p>
<p><img src="/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230705155340773.png" alt="image-20230705155340773"></p>
<p>容器化部署是目前业界很流行的一项技术，基于 Docker 镜像运行能够让用户更加方便地对应用进行管理和运维。容器管理工具中最为流行的就是 Kubernetes（k8s），而 Spark也在最近的版本中支持了 k8s 部署模式。这里我们也不做过多的讲解。给个链接大家自己感受一下： <a href="https://spark.apache.org/docs/latest/running-on-kubernetes.html" target="_blank" rel="noopener">https://spark.apache.org/docs/latest/running-on-kubernetes.html</a></p>
<p><img src="/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230705155415701.png" alt="image-20230705155415701"></p>
<h2 id="3-5-Windows-模式"><a href="#3-5-Windows-模式" class="headerlink" title="3.5 Windows 模式"></a>3.5 Windows 模式</h2><p>在同学们自己学习时，每次都需要启动虚拟机，启动集群，这是一个比较繁琐的过程，并且会占大量的系统资源，导致系统执行变慢，不仅仅影响学习效果，也影响学习进度，Spark 非常暖心地提供了可以在 windows 系统下启动本地集群的方式，这样，在不使用虚拟机的情况下，也能学习 Spark 的基本使用。</p>
<h3 id="3-5-1-解压缩文件"><a href="#3-5-1-解压缩文件" class="headerlink" title="3.5.1 解压缩文件"></a>3.5.1 解压缩文件</h3><p>将文件 spark-3.0.0-bin-hadoop3.2.tgz 解压缩到无中文无空格的路径中  </p>
<h3 id="3-5-2-启动本地环境"><a href="#3-5-2-启动本地环境" class="headerlink" title="3.5.2 启动本地环境"></a>3.5.2 启动本地环境</h3><p>1) 执行解压缩文件路径下 bin 目录中的 spark-shell.cmd 文件，启动 Spark 本地环境</p>
<p>   <img src="/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230705155656311.png" alt="image-20230705155656311"></p>
<p>2) 在 bin 目录中创建 input 目录，并添加 word.txt 文件, 在命令行中输入脚本代码</p>
<p>   <img src="/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230705155727521-1688543848374-1.png" alt="image-20230705155727521"></p>
<h3 id="3-5-3-命令行提交应用"><a href="#3-5-3-命令行提交应用" class="headerlink" title="3.5.3 命令行提交应用"></a>3.5.3 命令行提交应用</h3><p>在 DOS 命令行窗口中执行提交指令</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">spark-submit --class org.apache.spark.examples.SparkPi --master local[2] ../examples/jars/spark-examples_2.12-3.0.0.jar 10</span><br></pre></td></tr></table></figure>

<p><img src="/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230705155908075.png" alt="image-20230705155908075"></p>
<h2 id="3-6-部署模式对比"><a href="#3-6-部署模式对比" class="headerlink" title="3.6 部署模式对比"></a>3.6 部署模式对比</h2><table>
<thead>
<tr>
<th>模式</th>
<th>Spark 安装机器数</th>
<th>需启动的进程</th>
<th>所属者</th>
<th>应用场景</th>
</tr>
</thead>
<tbody><tr>
<td>Local</td>
<td>1</td>
<td>无</td>
<td>Spark</td>
<td>测试</td>
</tr>
<tr>
<td>Standalone</td>
<td>3</td>
<td>Master 及 Worker</td>
<td>Spark</td>
<td>单独部署</td>
</tr>
<tr>
<td>Yarn</td>
<td>1</td>
<td>Yarn 及 HDFS</td>
<td>Hadoop</td>
<td>混合部署</td>
</tr>
</tbody></table>
<h2 id="3-7-端口号"><a href="#3-7-端口号" class="headerlink" title="3.7 端口号"></a>3.7 端口号</h2><ul>
<li>Spark 查看当前 Spark-shell 运行任务情况端口号： 4040（计算）</li>
<li>Spark Master 内部通信服务端口号： 7077</li>
<li>Standalone 模式下， Spark Master Web 端口号： 8080（资源）</li>
<li>Spark 历史服务器端口号： 18080</li>
<li>Hadoop YARN 任务运行情况查看端口号： 8088</li>
</ul>
<h1 id="第4章-Spark-运行架构"><a href="#第4章-Spark-运行架构" class="headerlink" title="第4章 Spark 运行架构"></a>第4章 Spark 运行架构</h1><h2 id="4-1-运行架构"><a href="#4-1-运行架构" class="headerlink" title="4.1 运行架构"></a>4.1 运行架构</h2><p>Spark 框架的核心是一个计算引擎，整体来说，它采用了标准 master-slave 的结构。<br>如下图所示，它展示了一个 Spark 执行时的基本结构。 图形中的 Driver 表示 master，负责管理整个集群中的作业任务调度。图形中的 Executor 则是 slave，负责实际执行任务。  </p>
<p><img src="/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230705160051860.png" alt="image-20230705160051860"></p>
<h2 id="4-2-核心组件"><a href="#4-2-核心组件" class="headerlink" title="4.2 核心组件"></a>4.2 核心组件</h2><p>由上图可以看出，对于 Spark 框架有两个核心组件：</p>
<h3 id="4-2-1-Driver"><a href="#4-2-1-Driver" class="headerlink" title="4.2.1 Driver"></a>4.2.1 Driver</h3><p>Spark 驱动器节点，用于执行 Spark 任务中的 main 方法，负责实际代码的执行工作。Driver 在 Spark 作业执行时主要负责：  </p>
<ul>
<li>将用户程序转化为作业（job）</li>
<li>Executor 之间调度任务(task)</li>
<li>跟踪 Executor 的执行情况</li>
<li>通过 UI 展示查询运行情况  </li>
</ul>
<p>实际上，我们无法准确地描述 Driver 的定义，因为在整个的编程过程中没有看到任何有关Driver 的字眼。所以简单理解，所谓的 Driver 就是驱使整个应用运行起来的程序，也称之为 Driver 类。</p>
<h3 id="4-2-2-Executor"><a href="#4-2-2-Executor" class="headerlink" title="4.2.2 Executor"></a>4.2.2 Executor</h3><p>Spark Executor 是集群中工作节点（Worker）中的一个 JVM 进程，负责在 Spark 作业中运行具体任务（Task），任务彼此之间相互独立。Spark 应用启动时，Executor 节点被同时启动，并且始终伴随着整个 Spark 应用的生命周期而存在。如果有 Executor 节点发生了故障或崩溃， Spark 应用也可以继续执行，会将出错节点上的任务调度到其他 Executor 节点上继续运行。</p>
<p>Executor 有两个核心功能：  </p>
<ul>
<li>负责运行组成 Spark 应用的任务，并将结果返回给驱动器进程</li>
<li>它们通过自身的块管理器（Block Manager）为用户程序中要求缓存的 RDD 提供内存式存储。 RDD 是直接缓存在 Executor 进程内的，因此任务可以在运行时充分利用缓存数据加速运算。  </li>
</ul>
<h3 id="4-2-3-Master-amp-Worker"><a href="#4-2-3-Master-amp-Worker" class="headerlink" title="4.2.3 Master &amp; Worker"></a>4.2.3 Master &amp; Worker</h3><p>Spark 集群的独立部署环境中，不需要依赖其他的资源调度框架，自身就实现了资源调度的功能，所以环境中还有其他两个核心组件： Master 和 Worker，这里的 Master 是一个进程，主要负责资源的调度和分配，并进行集群的监控等职责，类似于 Yarn 环境中的 RM, 而 Worker 呢，也是进程，一个 Worker 运行在集群中的一台服务器上，由 Master 分配资源对数据进行并行的处理和计算，类似于 Yarn 环境中 NM。</p>
<h3 id="4-2-4-ApplicationMaster"><a href="#4-2-4-ApplicationMaster" class="headerlink" title="4.2.4 ApplicationMaster"></a>4.2.4 ApplicationMaster</h3><p>Hadoop 用户向 YARN 集群提交应用程序时,提交程序中应该包含 ApplicationMaster，用于向资源调度器申请执行任务的资源容器 Container，运行用户自己的程序任务 job，监控整个任务的执行，跟踪整个任务的状态，处理任务失败等异常情况。</p>
<p>说的简单点就是， ResourceManager（资源）和 Driver（计算）之间的解耦合靠的就是ApplicationMaster。</p>
<h2 id="4-3-核心概念"><a href="#4-3-核心概念" class="headerlink" title="4.3 核心概念"></a>4.3 核心概念</h2><h3 id="4-3-1-Executor-与-Core"><a href="#4-3-1-Executor-与-Core" class="headerlink" title="4.3.1 Executor 与 Core"></a>4.3.1 Executor 与 Core</h3><p>Spark Executor 是集群中运行在工作节点（Worker）中的一个 JVM 进程，是整个集群中的专门用于计算的节点。在提交应用中，可以提供参数指定计算节点的个数，以及对应的资源。这里的资源一般指的是工作节点 Executor 的内存大小和使用的虚拟 CPU 核（Core）数量。  </p>
<p>应用程序相关启动参数如下：  </p>
<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>–num-executors</td>
<td>配置 Executor 的数量</td>
</tr>
<tr>
<td>–executor-memory</td>
<td>配置每个 Executor 的内存大小</td>
</tr>
<tr>
<td>–executor-cores</td>
<td>配置每个 Executor 的虚拟 CPU core 数量</td>
</tr>
</tbody></table>
<h3 id="4-3-2-并行度（-Parallelism）"><a href="#4-3-2-并行度（-Parallelism）" class="headerlink" title="4.3.2 并行度（ Parallelism）"></a>4.3.2 并行度（ Parallelism）</h3><p>在分布式计算框架中一般都是多个任务同时执行，由于任务分布在不同的计算节点进行计算，所以能够真正地实现多任务并行执行，记住，这里是并行，而不是并发。这里我们将整个集群并行执行任务的数量称之为并行度。那么一个作业到底并行度是多少呢？这个取决于框架的默认配置。应用程序也可以在运行过程中动态修改。</p>
<h3 id="4-3-3-有向无环图（-DAG）"><a href="#4-3-3-有向无环图（-DAG）" class="headerlink" title="4.3.3 有向无环图（ DAG）"></a>4.3.3 有向无环图（ DAG）</h3><p><img src="/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230710163412215.png" alt="image-20230710163412215"></p>
<p>大数据计算引擎框架我们根据使用方式的不同一般会分为四类，其中第一类就是Hadoop 所承载的 MapReduce,它将计算分为两个阶段，分别为 Map 阶段 和Reduce 阶段。对于上层应用来说，就不得不想方设法去拆分算法，甚至于不得不在上层应用实现多个 Job的串联，以完成一个完整的算法，例如迭代计算。 由于这样的弊端，催生了支持 DAG 框架的产生。 因此，支持 DAG 的框架被划分为第二代计算引擎。如 Tez 以及更上层的Oozie。这里我们不去细究各种 DAG 实现之间的区别，不过对于当时的 Tez 和 Oozie 来说，大多还是批处理的任务。接下来就是以 Spark 为代表的第三代的计算引擎。第三代计算引擎的特点主要是 Job 内部的 DAG 支持（不跨越 Job），以及实时计算。</p>
<p>这里所谓的有向无环图，并不是真正意义的图形，而是由 Spark 程序直接映射成的数据流的高级抽象模型。简单理解就是将整个程序计算的执行过程用图形表示出来,这样更直观，更便于理解，可以用于表示程序的拓扑结构。  </p>
<p>DAG（Directed Acyclic Graph）有向无环图是由点和线组成的拓扑图形，该图形具有方向，不会闭环。  </p>
<h2 id="4-4-提交流程"><a href="#4-4-提交流程" class="headerlink" title="4.4 提交流程"></a>4.4 提交流程</h2><p>所谓的提交流程，其实就是我们开发人员根据需求写的应用程序通过 Spark 客户端提交给 Spark 运行环境执行计算的流程。在不同的部署环境中，这个提交过程基本相同，但是又有细微的区别，我们这里不进行详细的比较，但是因为国内工作中，将 Spark 引用部署到Yarn 环境中会更多一些，所以本课程中的提交流程是基于 Yarn 环境的。  </p>
<p><img src="/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230710163840537.png" alt="image-20230710163840537"></p>
<p>Spark 应用程序提交到 Yarn 环境中执行的时候，一般会有两种部署执行的方式： Client和 Cluster。 两种模式主要区别在于： Driver 程序的运行节点位置。  </p>
<h3 id="4-4-1-Yarn-Client-模式"><a href="#4-4-1-Yarn-Client-模式" class="headerlink" title="4.4.1 Yarn Client 模式"></a>4.4.1 Yarn Client 模式</h3><p>Client 模式将用于监控和调度的 Driver 模块在客户端执行，而不是在 Yarn 中，所以一般用于测试。  </p>
<p>Driver 在任务提交的本地机器上运行</p>
<ul>
<li>Driver 启动后会和 ResourceManager 通讯申请启动 ApplicationMaster</li>
<li>ResourceManager 分配 container，在合适的 NodeManager 上启动 ApplicationMaster， 负责向 ResourceManager 申请 Executor 内存</li>
<li>ResourceManager 接到 ApplicationMaster 的资源申请后会分配 container，然后ApplicationMaster 在资源分配指定的 NodeManager 上启动 Executor 进程 </li>
<li>Executor 进程启动后会向 Driver 反向注册， Executor 全部注册完成后 Driver 开始执行main 函数</li>
<li>之后执行到 Action 算子时，触发一个 Job，并根据宽依赖开始划分 stage，每个 stage 生成对应的 TaskSet，之后将 task 分发到各个 Executor 上执行。</li>
</ul>
<h3 id="4-4-2-Yarn-Cluster-模式"><a href="#4-4-2-Yarn-Cluster-模式" class="headerlink" title="4.4.2 Yarn Cluster 模式"></a>4.4.2 Yarn Cluster 模式</h3><p>Cluster 模式将用于监控和调度的 Driver 模块启动在 Yarn 集群资源中执行。一般应用于实际生产环境。  </p>
<ul>
<li>在 YARN Cluster 模式下，任务提交后会和 ResourceManager 通讯申请启动 ApplicationMaster</li>
<li>随后 ResourceManager 分配 container，在合适的 NodeManager 上启动 ApplicationMaster，此时的 ApplicationMaster 就是 Driver</li>
<li>Driver 启动后向 ResourceManager 申请 Executor 内存，ResourceManager 接到 ApplicationMaster 的资源申请后会分配 container，然后在合适的 NodeManager 上启动Executor 进程</li>
<li>Executor 进程启动后会向 Driver 反向注册， Executor 全部注册完成后 Driver 开始执行main 函数</li>
<li>之后执行到 Action 算子时，触发一个 Job，并根据宽依赖开始划分 stage，每个 stage 生成对应的 TaskSet，之后将 task 分发到各个 Executor 上执行。</li>
</ul>
<h1 id="第5章-Spark-核心编程"><a href="#第5章-Spark-核心编程" class="headerlink" title="第5章 Spark 核心编程"></a>第5章 Spark 核心编程</h1><p>Spark 计算框架为了能够进行高并发和高吞吐的数据处理，封装了三大数据结构，用于处理不同的应用场景。三大数据结构分别是：  </p>
<ul>
<li>RDD : 弹性分布式数据集</li>
<li>累加器：分布式共享只写变量</li>
<li>广播变量：分布式共享只读变量</li>
</ul>
<p>接下来我们一起看看这三大数据结构是如何在数据处理中使用的。</p>
<h2 id="5-1-RDD"><a href="#5-1-RDD" class="headerlink" title="5.1 RDD"></a>5.1 RDD</h2><h3 id="5-1-1-什么是-RDD"><a href="#5-1-1-什么是-RDD" class="headerlink" title="5.1.1 什么是 RDD"></a>5.1.1 什么是 RDD</h3><p><strong>RDD</strong>（Resilient Distributed Dataset）叫做<strong>弹性分布式数据集</strong>，是 Spark 中最基本的数据处理模型。代码中是一个抽象类，它代表一个弹性的、不可变、可分区、里面的元素可并行计算的集合。</p>
<ul>
<li>弹性<ul>
<li>存储的弹性：内存与磁盘的自动切换；</li>
<li>容错的弹性：数据丢失可以自动恢复；</li>
<li>计算的弹性：计算出错重试机制；</li>
<li>分片的弹性：可根据需要重新分片。</li>
</ul>
</li>
<li>分布式：数据存储在大数据集群不同节点上</li>
<li>数据集：RDD 封装了计算逻辑，并不保存数据</li>
<li>数据抽象：RDD 是一个抽象类，需要子类具体实现</li>
<li>不可变：RDD 封装了计算逻辑，是不可以改变的，想要改变，只能产生新的 RDD，在新的 RDD 里面封装计算逻辑</li>
<li>可分区、并行计算  </li>
</ul>
<p>概念分析与总结</p>
<p>RDD 的简单基本原理</p>
<p><img src="/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230710101418977.png" alt="image-20230710101418977"></p>
<p>RDD与IO的关系图</p>
<p><img src="/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230710102026568.png" alt="image-20230710102026568"></p>
<p><img src="/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230710102045899.png" alt="image-20230710102045899"></p>
<p><img src="/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230710101358005.png" alt="image-20230710101358005"></p>
<p><img src="/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230808165004045.png" alt="image-20230808165004045"></p>
<p>RDD的数据处理方式类似于IO流，也有装饰者设计模式<br>RDD的数据只有在调用collect方法时，才会真正执行业务逻辑操作，之前的封装全部都是功能的扩展<br>RDD是不保存数据的，但是IO流可以临时保存一部分数据</p>
<h3 id="5-1-2-核心属性"><a href="#5-1-2-核心属性" class="headerlink" title="5.1.2 核心属性"></a>5.1.2 核心属性</h3><p><img src="/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230710181744170.png" alt="image-20230710181744170"></p>
<ul>
<li><p>分区列表</p>
<p>RDD 数据结构中存在分区列表，用于执行任务时并行计算，是实现分布式计算的重要属性。</p>
<p><img src="/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230710181651865.png" alt="image-20230710181651865"></p>
</li>
<li><p>分区计算函数</p>
<p><img src="/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230710181819982.png" alt="image-20230710181819982"></p>
</li>
<li><p>RDD 之间的依赖关系</p>
<p>RDD 是计算模型的封装，当需求中需要将多个计算模型进行组合时，就需要将多个 RDD 建立依赖关系</p>
<p><img src="/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230710181845879.png" alt="image-20230710181845879"></p>
</li>
<li><p>分区器（可选）</p>
<p>当数据为 KV 类型数据时，可以通过设定分区器自定义数据的分区</p>
<p><img src="/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230710181914836.png" alt="image-20230710181914836"></p>
</li>
<li><p>首选位置（可选）</p>
<p>计算数据时，可以根据计算节点的状态选择不同的节点位置进行计算</p>
<p><img src="/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230710181942998.png" alt="image-20230710181942998"></p>
<p><img src="/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230807163350450.png" alt="image-20230807163350450"></p>
</li>
</ul>
<h3 id="5-1-3-执行原理"><a href="#5-1-3-执行原理" class="headerlink" title="5.1.3 执行原理"></a>5.1.3 执行原理</h3><p>从计算的角度来讲，数据处理过程中需要计算资源（内存 &amp; CPU）和计算模型（逻辑）。执行时，需要将计算资源和计算模型进行协调和整合。  </p>
<p>Spark 框架在执行时，先申请资源，然后将应用程序的数据处理逻辑分解成一个一个的计算任务。然后将任务发到已经分配资源的计算节点上, 按照指定的计算模型进行数据计算。最后得到计算结果。  </p>
<p>RDD 是 Spark 框架中用于数据处理的核心模型，接下来我们看看，在 Yarn 环境中， RDD的工作原理:  </p>
<p>1) 启动 Yarn 集群环境  </p>
<p>   <img src="/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230804173336550.png" alt="image-20230804173336550"></p>
<p>2) Spark 通过申请资源创建调度节点和计算节点</p>
<p>   <img src="/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230804173435262.png" alt="image-20230804173435262"></p>
<p>3) Spark 框架根据需求将计算逻辑根据分区划分成不同的任务</p>
<p>   <img src="/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230804173514641.png" alt="image-20230804173514641"></p>
<p>4) 调度节点将任务根据计算节点状态或者根据首选位置的判断发送到对应的计算节点进行计算</p>
<p>   <img src="/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230804173818441.png" alt="image-20230804173818441"></p>
<p>从以上流程可以看出 RDD 在整个流程中主要用于将逻辑进行封装，并生成 Task 发送给Executor 节点执行计算，接下来我们就一起看看 Spark 框架中 RDD 是具体是如何进行数据处理的。</p>
<h3 id="5-1-4-基础编程"><a href="#5-1-4-基础编程" class="headerlink" title="5.1.4 基础编程"></a>5.1.4 基础编程</h3><h4 id="5-1-4-1-RDD-创建"><a href="#5-1-4-1-RDD-创建" class="headerlink" title="5.1.4.1 RDD 创建"></a>5.1.4.1 RDD 创建</h4><p>在 Spark 中创建 RDD 的创建方式可以分为四种：  </p>
<p>1) 从集合（内存）中创建 RDD  </p>
<p>   从集合中创建 RDD， Spark 主要提供了两个方法： parallelize 和 makeRDD  </p>
   <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">"local[*]"</span>).setAppName(<span class="string">"spark"</span>)</span><br><span class="line"><span class="keyword">val</span> sparkContext = <span class="keyword">new</span> <span class="type">SparkContext</span>(sparkConf)</span><br><span class="line"><span class="keyword">val</span> rdd1 = sparkContext.parallelize(<span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line"><span class="keyword">val</span> rdd2 = sparkContext.makeRDD(<span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line">rdd1.collect().foreach(println)</span><br><span class="line">rdd2.collect().foreach(println)</span><br><span class="line">sparkContext.stop()</span><br></pre></td></tr></table></figure>

<p>   从底层代码实现来讲， makeRDD 方法其实就是 parallelize 方法  </p>
   <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">makeRDD</span></span>[<span class="type">T</span>: <span class="type">ClassTag</span>](</span><br><span class="line">    seq: <span class="type">Seq</span>[<span class="type">T</span>],</span><br><span class="line">    numSlices: <span class="type">Int</span> = defaultParallelism): <span class="type">RDD</span>[<span class="type">T</span>] = withScope &#123;</span><br><span class="line">    	parallelize(seq, numSlices)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>   练习与测试</p>
   <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spark.core.rdd.builder</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.rdd.<span class="type">RDD</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Spark01_RDD_Memory</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">// 准备环境 ,[*] 表示当前系统最大可用核数，使用和核数一样的线程数量进行模拟，local 表示使用单线程进行模拟</span></span><br><span class="line">    <span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">"local[*]"</span>).setAppName(<span class="string">"RDD"</span>)</span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(sparkConf)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 内存中创建RDD</span></span><br><span class="line">    <span class="comment">// 创建RDD</span></span><br><span class="line">    <span class="comment">// 从内存中创建RDD,将内存中集合的数据作为处理的数据源</span></span><br><span class="line">    <span class="keyword">val</span> seq = <span class="type">Seq</span>[<span class="type">Int</span>](<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// parallelize: 表示并行,不好理解，语境不合适</span></span><br><span class="line">    <span class="comment">// val rdd: RDD[Int] = sc.parallelize(seq)</span></span><br><span class="line">    <span class="keyword">val</span> rdd: <span class="type">RDD</span>[<span class="type">Int</span>] = sc.makeRDD(seq) <span class="comment">// 简化版本，makeRDD方法在底层实现其实就是调用了rdd对象的parallelize方法，更容易理解，这个用的多一些。</span></span><br><span class="line"></span><br><span class="line">    rdd.collect().foreach(println)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭环境</span></span><br><span class="line">    sc.stop()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2) 从外部存储（文件）创建 RDD  </p>
<p>   由外部存储系统的数据集创建 RDD 包括：本地的文件系统，所有 Hadoop 支持的数据集，比如 HDFS、 HBase 等。  </p>
   <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">"local[*]"</span>).setAppName(<span class="string">"spark"</span>)</span><br><span class="line"><span class="keyword">val</span> sparkContext = <span class="keyword">new</span> <span class="type">SparkContext</span>(sparkConf)</span><br><span class="line"><span class="keyword">val</span> fileRDD: <span class="type">RDD</span>[<span class="type">String</span>] = sparkContext.textFile(<span class="string">"input"</span>)</span><br><span class="line">fileRDD.collect().foreach(println)</span><br><span class="line">sparkContext.stop()</span><br></pre></td></tr></table></figure>

<p>   练习与测试</p>
   <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spark.core.rdd.builder</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.rdd.<span class="type">RDD</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Spark02_RDD_File</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">// 准备环境，[*] 表示当前系统最大可用核数，使用和核数一样的线程数量进行模拟， local 表示使用单线程进行模拟</span></span><br><span class="line">    <span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">"local[*]"</span>).setAppName(<span class="string">"RDD"</span>)</span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(sparkConf)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 文件中创建RDD</span></span><br><span class="line">    <span class="comment">// 创建RDD</span></span><br><span class="line">    <span class="comment">// 从文件中创建RDD,将文件中的数据作为处理的数据源</span></span><br><span class="line">    <span class="comment">// path 路径以当前环境的根路径为基准，可以写绝对路径，也可以写相对路径(当前项目的根)</span></span><br><span class="line">    <span class="comment">// val rdd: RDD[String] = sc.textFile("D:\\learn\\spark_test\\datas\\1.txt")</span></span><br><span class="line">    <span class="comment">// path 路径可以使文件的具体路径，也可以是目录名称,统计目录下所有的文件</span></span><br><span class="line">    <span class="comment">// val rdd: RDD[String] = sc.textFile("datas/1.txt")</span></span><br><span class="line">    <span class="comment">// val rdd = sc.textFile("datas")</span></span><br><span class="line">    <span class="comment">// path路径还可以使用通配符</span></span><br><span class="line">    <span class="comment">// val rdd = sc.textFile("datas/1*.txt")</span></span><br><span class="line">    <span class="comment">// path还可以使分布式存储系统路径：HDFS</span></span><br><span class="line">    <span class="keyword">val</span> rdd = sc.textFile(<span class="string">"hdfs://bigdata1:8020/test.txt"</span>)</span><br><span class="line">    rdd.collect().foreach(println)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭环境</span></span><br><span class="line">    sc.stop()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

   <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spark.core.rdd.builder</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Spark02_RDD_File1</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">// 准备环境，[*] 表示当前系统最大可用核数，使用和核数一样的线程数量进行模拟，local 表示使用单线程进行模拟</span></span><br><span class="line">    <span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">"local[*]"</span>).setAppName(<span class="string">"RDD"</span>)</span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(sparkConf)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 文件中创建RDD（文件夹）</span></span><br><span class="line">    <span class="comment">// 创建RDD</span></span><br><span class="line">    <span class="comment">// 从文件中创建RDD,将文件中的数据作为处理的数据源</span></span><br><span class="line">    <span class="comment">// textFile: 以行为单位读取数据，读取的数据都是字符串</span></span><br><span class="line">    <span class="comment">// wholeTextFiles：以文件为单位读取数据</span></span><br><span class="line">    <span class="comment">// 读取的结果表明为元组，第一个元素表示文件路径，第二个元素表示文件内容</span></span><br><span class="line">    <span class="keyword">val</span> rdd = sc.wholeTextFiles(<span class="string">"datas"</span>)</span><br><span class="line">    rdd.collect().foreach(println)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭环境</span></span><br><span class="line">    sc.stop()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3) 从其他 RDD 创建  </p>
<p>   主要是通过一个 RDD 运算完后，再产生新的 RDD。 详情请参考后续章节  </p>
<p>4) 直接创建 RDD（new）  </p>
<p>   使用 new 的方式直接构造 RDD，一般由 Spark 框架自身使用。  </p>
<h4 id="5-1-4-2-RDD-并行度与分区"><a href="#5-1-4-2-RDD-并行度与分区" class="headerlink" title="5.1.4.2 RDD 并行度与分区"></a>5.1.4.2 RDD 并行度与分区</h4><p>默认情况下， Spark 可以将一个作业切分多个任务后，发送给 Executor 节点并行计算，而能够并行计算的任务数量我们称之为并行度。这个数量可以在构建 RDD 时指定。 记住，这里的并行执行的任务数量，并不是指的切分任务的数量，不要混淆了。  </p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">"local[*]"</span>).setAppName(<span class="string">"spark"</span>)</span><br><span class="line"><span class="keyword">val</span> sparkContext = <span class="keyword">new</span> <span class="type">SparkContext</span>(sparkConf)</span><br><span class="line"><span class="keyword">val</span> dataRDD: <span class="type">RDD</span>[<span class="type">Int</span>] = sparkContext.makeRDD(<span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>),<span class="number">4</span>)</span><br><span class="line"><span class="keyword">val</span> fileRDD: <span class="type">RDD</span>[<span class="type">String</span>] =sparkContext.textFile(<span class="string">"input"</span>,<span class="number">2</span>)</span><br><span class="line">fileRDD.collect().foreach(println)</span><br><span class="line">sparkContext.stop()</span><br></pre></td></tr></table></figure>

<p>读取内存数据时，数据可以按照并行度的设定进行数据的分区操作，数据分区规则的Spark 核心源码如下：  </p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">positions</span></span>(length: <span class="type">Long</span>, numSlices: <span class="type">Int</span>): <span class="type">Iterator</span>[(<span class="type">Int</span>, <span class="type">Int</span>)] = &#123;</span><br><span class="line">    (<span class="number">0</span> until numSlices).iterator.map &#123; i =&gt;</span><br><span class="line">        <span class="keyword">val</span> start = ((i * length) / numSlices).toInt</span><br><span class="line">        <span class="keyword">val</span> end = (((i + <span class="number">1</span>) * length) / numSlices).toInt</span><br><span class="line">        (start, end)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>练习与测试</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spark.core.rdd.builder</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Spark01_RDD_Memory_Par</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">// 准备环境 ,local[*] 表示当前系统最大可用核数，使用和核数一样的线程数量进行模拟，local 表示使用单线程进行模拟</span></span><br><span class="line">    <span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">"local[*]"</span>).setAppName(<span class="string">"RDD"</span>)</span><br><span class="line">    sparkConf.set(<span class="string">"spark.default.parallelism"</span>, <span class="string">"5"</span>)</span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(sparkConf)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 分区数量的设定</span></span><br><span class="line">    <span class="comment">// 创建RDD</span></span><br><span class="line">    <span class="comment">// RDD的并行度 &amp; 分区</span></span><br><span class="line">    <span class="comment">// makeRDD可以传递第二个参数，表示分区的数量</span></span><br><span class="line">    <span class="comment">// 第二个参数可以不传递，那么makeRDD将使用默认值：defaultParallelism（默认并行度）</span></span><br><span class="line">    <span class="comment">// scheduler.conf.getInt("spark.default.parallelism", totalCores)</span></span><br><span class="line">    <span class="comment">// 分区数量的计算方式：spark在默认情况下，优先使用自己定义的，否则从配置对象中获取配置参数spark.default.parallelism，如果还取不到，则使用totalCores，这个属性取值为当前运行环境最大可用核数，代替做为分区数</span></span><br><span class="line">    <span class="comment">// val rdd = sc.makeRDD(List(1, 2, 3, 4), 2)</span></span><br><span class="line">    <span class="keyword">val</span> rdd = sc.makeRDD(<span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line">    <span class="comment">// 将树立的数据以分区为单位保存成分区文件</span></span><br><span class="line">    rdd.saveAsTextFile(<span class="string">"output"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭环境</span></span><br><span class="line">    sc.stop()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spark.core.rdd.builder</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Spark01_RDD_Memory_Par1</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">// 准备环境 ,[*] 表示当前系统最大可用核数，使用和核数一样的线程数量进行模拟，local 表示使用单线程进行模拟</span></span><br><span class="line">    <span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">"local[*]"</span>).setAppName(<span class="string">"RDD"</span>)</span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(sparkConf)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 分区数据的分配</span></span><br><span class="line">    <span class="comment">// 创建RDD</span></span><br><span class="line">    <span class="comment">// [1,2],[3,4]</span></span><br><span class="line">    <span class="comment">// val rdd = sc.makeRDD(List(1, 2, 3, 4), 2)</span></span><br><span class="line">    <span class="comment">// [1],[2],[3,4]</span></span><br><span class="line">    <span class="comment">// val rdd = sc.makeRDD(List(1, 2, 3, 4), 3)</span></span><br><span class="line">    <span class="comment">// [1],[2,3],[4,5]</span></span><br><span class="line">    <span class="comment">// 数据分配细节请看源码</span></span><br><span class="line">    <span class="keyword">val</span> rdd = sc.makeRDD(<span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>), <span class="number">3</span>)</span><br><span class="line">    <span class="comment">// 将树立的数据以分区为单位保存成分区文件</span></span><br><span class="line">    rdd.saveAsTextFile(<span class="string">"output"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 关闭环境</span></span><br><span class="line">    sc.stop()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>读取文件数据时，数据是按照 Hadoop 文件读取的规则进行切片分区，而切片规则和数据读取的规则有些差异，具体 Spark 核心源码如下  </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> InputSplit[] getSplits(JobConf job, <span class="keyword">int</span> numSplits) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    <span class="keyword">long</span> totalSize = <span class="number">0</span>; <span class="comment">// compute total size</span></span><br><span class="line">    <span class="keyword">for</span> (FileStatus file: files) &#123; <span class="comment">// check we have valid files</span></span><br><span class="line">        <span class="keyword">if</span> (file.isDirectory()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Not a file: "</span>+ file.getPath());</span><br><span class="line">        &#125;</span><br><span class="line">        totalSize += file.getLen();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> goalSize = totalSize / (numSplits == <span class="number">0</span> ? <span class="number">1</span> : numSplits);</span><br><span class="line">    <span class="keyword">long</span> minSize = Math.max(job.getLong(org.apache.hadoop.mapreduce.lib.input.</span><br><span class="line">    FileInputFormat.SPLIT_MINSIZE, <span class="number">1</span>), minSplitSize);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">for</span> (FileStatus file: files) &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">if</span> (isSplitable(fs, path)) &#123;</span><br><span class="line">        <span class="keyword">long</span> blockSize = file.getBlockSize();</span><br><span class="line">        <span class="keyword">long</span> splitSize = computeSplitSize(goalSize, minSize, blockSize);</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">long</span> <span class="title">computeSplitSize</span><span class="params">(<span class="keyword">long</span> goalSize, <span class="keyword">long</span> minSize, <span class="keyword">long</span> blockSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Math.max(minSize, Math.min(goalSize, blockSize));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>练习与测试</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spark.core.rdd.builder</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Spark02_RDD_File_Par</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">// 准备环境，[*] 表示当前系统最大可用核数，使用和核数一样的线程数量进行模拟，local 表示使用单线程进行模拟</span></span><br><span class="line">    <span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">"local[*]"</span>).setAppName(<span class="string">"RDD"</span>)</span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(sparkConf)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 分区数量的设定（无参数）</span></span><br><span class="line">    <span class="comment">// 创建RDD</span></span><br><span class="line">    <span class="comment">// textFile可以将文件作为数据处理的数据源，默认也可以设定分区</span></span><br><span class="line">    <span class="comment">// minPartitions：最小分区数量</span></span><br><span class="line">    <span class="comment">// math.min(defaultParallelism, 2) // 未设定参数，此时会获取配置的默认spark.default.parallelism参数值与2比较得到最小值，如果参数值为空则获取最大核数作为默认分区数与2比较获得最小值</span></span><br><span class="line">    <span class="comment">// val rdd = sc.textFile("datas/1.txt")</span></span><br><span class="line">    <span class="comment">// TODO 分区数量的设定（有参数）</span></span><br><span class="line">    <span class="comment">// 如果不想使用默认的分区数量，可以通过第二个参数：最小分区数 来指定分区数</span></span><br><span class="line">    <span class="comment">// 数据文件为：</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      1</span></span><br><span class="line"><span class="comment">      2</span></span><br><span class="line"><span class="comment">      3</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">// Spark读取文件，底层和读取hadoop文件的方式是一样的</span></span><br><span class="line">    <span class="comment">// 分区数量的计算方式：</span></span><br><span class="line">    <span class="comment">// totalSize =  7 文件总字节数</span></span><br><span class="line">    <span class="comment">// goalSize = 7 / 2 = 3(byte) 文件总字节数除以传递的参数分区数，表示每个分区应该存多少字节</span></span><br><span class="line">    <span class="comment">// 所以分数数量 = 7 / 3 = 2余1, 又因为剩余的字节数大于每个分区的字节数的10%，所以判定增加分区，一共为3个分区。</span></span><br><span class="line">    <span class="keyword">val</span> rdd = sc.textFile(<span class="string">"datas/1.txt"</span>, <span class="number">2</span>)</span><br><span class="line">    rdd.saveAsTextFile(<span class="string">"output"</span>)</span><br><span class="line">    <span class="comment">// 关闭环境</span></span><br><span class="line">    sc.stop()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spark.core.rdd.builder</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Spark02_RDD_File_Par1</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">// 准备环境，[*] 表示当前系统最大可用核数，使用和核数一样的线程数量进行模拟，local 表示使用单线程进行模拟</span></span><br><span class="line">    <span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">"local[*]"</span>).setAppName(<span class="string">"RDD"</span>)</span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(sparkConf)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 分区数据的分配</span></span><br><span class="line">    <span class="comment">// 创建RDD</span></span><br><span class="line">    <span class="comment">// 1、数据以行为单位进行读取，spark读取文件，采用的是hadoop的方式读取，所以一行一行读取，和字节数没有关系</span></span><br><span class="line">    <span class="comment">// 2、数据读取时以偏移量为单位,偏移量不会被重新读取</span></span><br><span class="line">    <span class="comment">/* 偏移量</span></span><br><span class="line"><span class="comment">      1@@ =&gt; 0 1 2</span></span><br><span class="line"><span class="comment">      2@@ =&gt; 3 4 5</span></span><br><span class="line"><span class="comment">      3   =&gt; 6</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     <span class="comment">// 3、数据分区的偏移量范围计算</span></span><br><span class="line">     <span class="comment">// 0 =&gt; [0,3] =&gt; 1 2 // 中括号里面的代表每个分区截取的文件偏移量起始和终点位置，闭区间。</span></span><br><span class="line">     <span class="comment">// 1 =&gt; [3,6] =&gt; 3</span></span><br><span class="line">     <span class="comment">// 2 =&gt; [6,9]</span></span><br><span class="line">    <span class="keyword">val</span> rdd = sc.textFile(<span class="string">"datas/1.txt"</span>, <span class="number">2</span>)</span><br><span class="line">    rdd.saveAsTextFile(<span class="string">"output"</span>)</span><br><span class="line">    <span class="comment">// 关闭环境</span></span><br><span class="line">    sc.stop()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spark.core.rdd.builder</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Spark02_RDD_File_Par2</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">// 准备环境，[*] 表示当前系统最大可用核数，使用和核数一样的线程数量进行模拟，local 表示使用单线程进行模拟</span></span><br><span class="line">    <span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">"local[*]"</span>).setAppName(<span class="string">"RDD"</span>)</span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(sparkConf)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 分区数量的设定（有参数）</span></span><br><span class="line">    <span class="comment">// 总共14字节</span></span><br><span class="line">    <span class="comment">// 14byte / 2 = 7byte 每个分区7字节</span></span><br><span class="line">    <span class="comment">// 所以：14 / 7 = 2(分区)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 分区数据的分配</span></span><br><span class="line">    <span class="comment">/* 偏移量</span></span><br><span class="line"><span class="comment">      1234567@@ =&gt; 0 1 2 3 4 5 6 7 8</span></span><br><span class="line"><span class="comment">      89@@      =&gt; 9 10 11 12</span></span><br><span class="line"><span class="comment">      0         =&gt; 13</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">// 0 =&gt; [0,7]  =&gt; 1 2 3 4 5 6 7</span></span><br><span class="line">    <span class="comment">// 1 =&gt; [7,14] =&gt; 8 9 0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果数据源为多个文件，那么计算分区时以文件为单位进行分区</span></span><br><span class="line">    <span class="keyword">val</span> rdd = sc.textFile(<span class="string">"datas/word.txt"</span>, <span class="number">2</span>)</span><br><span class="line">    rdd.saveAsTextFile(<span class="string">"output"</span>)</span><br><span class="line">    <span class="comment">// 关闭环境</span></span><br><span class="line">    sc.stop()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-1-4-3-RDD-转换算子"><a href="#5-1-4-3-RDD-转换算子" class="headerlink" title="5.1.4.3 RDD 转换算子"></a>5.1.4.3 RDD 转换算子</h4><p>RDD方法</p>
<ul>
<li>转换 ： 功能的补充和封装，将旧的RDD包装成新的RDD，如：flatMap, map</li>
<li>行动 ： 触发任务的调度和作业的执行，如：collect</li>
</ul>
<p>认知心理学认为解决问题其实将问题的状态进行改变：问题（初始） =&gt; 操作（算子） =&gt; 问题（审核中） =&gt; 操作（算子） =&gt; 问题（完成）</p>
<p>操作 =&gt; Operator</p>
<p>所以我们也可以说：RDD算子包括转换算子和行动算子</p>
<p>RDD 根据数据处理方式的不同将算子整体上分为 Value 类型、双 Value 类型和 Key-Value类型  </p>
<h5 id="Value类型"><a href="#Value类型" class="headerlink" title="Value类型"></a>Value类型</h5><h6 id="map"><a href="#map" class="headerlink" title="map"></a>map</h6><ul>
<li>函数签名</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">map</span></span>[<span class="type">U</span>: <span class="type">ClassTag</span>](f: <span class="type">T</span> =&gt; <span class="type">U</span>): <span class="type">RDD</span>[<span class="type">U</span>]</span><br></pre></td></tr></table></figure>

<ul>
<li><p>函数说明  </p>
<p>将处理的数据逐条进行映射转换，这里的转换可以是类型的转换，也可以是值的转换。  </p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> dataRDD: <span class="type">RDD</span>[<span class="type">Int</span>] = sparkContext.makeRDD(<span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line"><span class="keyword">val</span> dataRDD1: <span class="type">RDD</span>[<span class="type">Int</span>] = dataRDD.map(</span><br><span class="line">num =&gt; &#123;</span><br><span class="line">		num * <span class="number">2</span></span><br><span class="line">	&#125;</span><br><span class="line">)</span><br><span class="line"><span class="keyword">val</span> dataRDD2: <span class="type">RDD</span>[<span class="type">String</span>] = dataRDD1.map(</span><br><span class="line">    num =&gt; &#123;</span><br><span class="line">    	<span class="string">""</span> + num</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
</li>
<li><p>小功能：从服务器日志数据 apache.log 中获取用户请求 URL 资源路径  </p>
</li>
<li><p>练习与测试</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spark.core.rdd.operator.transform</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.rdd.<span class="type">RDD</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Spark01_RDD_Operator_Transform</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">"local[*]"</span>).setAppName(<span class="string">"Operator"</span>)</span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(sparkConf)</span><br><span class="line">    <span class="comment">// TODO 转换算子</span></span><br><span class="line">    <span class="comment">// TODO 算子-双Value类型</span></span><br><span class="line">    <span class="comment">// TODO 算子-map</span></span><br><span class="line">    <span class="comment">// TODO 将处理的数据逐条进行映射转换，这里的转换可以是类型的转换，也可以是值的转换</span></span><br><span class="line">    <span class="comment">// TODO 将集合内的数值翻倍</span></span><br><span class="line">    <span class="keyword">val</span> rdd: <span class="type">RDD</span>[<span class="type">Int</span>] = sc.makeRDD(<span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 转换函数</span></span><br><span class="line">    <span class="comment">// def mapFunction(num: Int): Int = &#123;</span></span><br><span class="line">    <span class="comment">//  num * 2</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// val mapRDD: RDD[Int] = rdd.map(mapFunction)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> mapRDD: <span class="type">RDD</span>[<span class="type">Int</span>] = rdd.map(_ * <span class="number">2</span>)</span><br><span class="line">    mapRDD.collect().foreach(println)</span><br><span class="line"></span><br><span class="line">    sc.stop()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spark.core.rdd.operator.transform</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Spark01_RDD_Operator_Transform_Par</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">"local[*]"</span>).setAppName(<span class="string">"Operator"</span>)</span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(sparkConf)</span><br><span class="line">    <span class="comment">// TODO 算子-并行计算</span></span><br><span class="line">    <span class="comment">// TODO 探究分区内数据的执行顺序</span></span><br><span class="line">    <span class="comment">// 1、rdd的计算一个分区内的数据是一个一个的顺序执行的逻辑，只有前面一个数据全部逻辑执行完毕后，才会执行下一个数据，分区内数据的执行是有序的</span></span><br><span class="line">    <span class="comment">// val rdd = sc.makeRDD(List(1, 2, 3, 4),1)</span></span><br><span class="line">    <span class="comment">// 2、不同分区数据计算是无序的，但是每个分区内部是有序的</span></span><br><span class="line">    <span class="comment">// [1,2] [3,4]</span></span><br><span class="line">    <span class="keyword">val</span> rdd = sc.makeRDD(<span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>),<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">val</span> mapRDD = rdd.map(num =&gt; &#123;</span><br><span class="line">      println(<span class="string">"&gt;&gt;&gt;&gt;&gt; "</span> + num)</span><br><span class="line">      num</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">val</span> mapRDD1 = mapRDD.map(num =&gt; &#123;</span><br><span class="line">      println(<span class="string">"##### "</span> + num)</span><br><span class="line">      num</span><br><span class="line">    &#125;)</span><br><span class="line">    mapRDD1.collect()</span><br><span class="line">    sc.stop()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spark.core.rdd.operator.transform</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Spark01_RDD_Operator_Transform_Part</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">"local[*]"</span>).setAppName(<span class="string">"Operator"</span>)</span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(sparkConf)</span><br><span class="line">    <span class="comment">// TODO 算子-map</span></span><br><span class="line">    <span class="comment">// TODO 验证分区内容在多个RDD中保持不变</span></span><br><span class="line">    <span class="keyword">val</span> rdd = sc.makeRDD(<span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>), <span class="number">2</span>)</span><br><span class="line">    <span class="comment">// [1,2], [3,4]</span></span><br><span class="line">    rdd.saveAsTextFile(<span class="string">"output"</span>)</span><br><span class="line">    <span class="keyword">val</span> mapRDD = rdd.map(_ * <span class="number">2</span>)</span><br><span class="line">    <span class="comment">// [2,4], [6,8]</span></span><br><span class="line">    mapRDD.saveAsTextFile(<span class="string">"output1"</span>)</span><br><span class="line"></span><br><span class="line">    sc.stop()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spark.core.rdd.operator.transform</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.rdd.<span class="type">RDD</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Spark01_RDD_Operator_Transform_Test</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">"local[*]"</span>).setAppName(<span class="string">"Operator"</span>)</span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(sparkConf)</span><br><span class="line">    <span class="comment">// TODO 算子-map</span></span><br><span class="line">    <span class="comment">// TODO 从服务器日志数据 apache.log 中获取用户请求 URL 资源路径</span></span><br><span class="line">    <span class="keyword">val</span> rdd = sc.textFile(<span class="string">"datas/apache.log"</span>)</span><br><span class="line">    <span class="keyword">val</span> mapRDD: <span class="type">RDD</span>[<span class="type">String</span>] = rdd.map(_.split(<span class="string">" "</span>)(<span class="number">6</span>))</span><br><span class="line"></span><br><span class="line">    mapRDD.collect().foreach(println)</span><br><span class="line">    sc.stop()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h6 id="mapPartitions"><a href="#mapPartitions" class="headerlink" title="mapPartitions"></a>mapPartitions</h6><ul>
<li>函数签名</li>
</ul>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mapPartitions</span></span>[<span class="type">U</span>: <span class="type">ClassTag</span>](f: <span class="type">Iterator</span>[<span class="type">T</span>] =&gt; <span class="type">Iterator</span>[<span class="type">U</span>],preservesPartitioning: <span class="type">Boolean</span> = <span class="literal">false</span>): <span class="type">RDD</span>[<span class="type">U</span>]</span><br></pre></td></tr></table></figure>

<ul>
<li><p>函数说明</p>
<p>将待处理的数据以分区为单位发送到计算节点进行处理，这里的处理是指可以进行任意的处理，哪怕是过滤数据。  </p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> dataRDD1: <span class="type">RDD</span>[<span class="type">Int</span>] = dataRDD.mapPartitions(</span><br><span class="line">    datas =&gt; &#123;</span><br><span class="line">    	datas.filter(_==<span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
</li>
<li><p>小功能：获取每个数据分区的最大值</p>
</li>
<li><p>思考一个问题： map 和 mapPartitions 的区别？</p>
<ul>
<li>数据处理角度<br>Map 算子是分区内一个数据一个数据的执行，类似于串行操作。而 mapPartitions 算子是以分区为单位进行批处理操作。</li>
<li>功能的角度<br>Map 算子主要目的将数据源中的数据进行转换和改变。但是不会减少或增多数据。MapPartitions 算子需要传递一个迭代器，返回一个迭代器，没有要求的元素的个数保持不变，所以可以增加或减少数据。</li>
<li>性能的角度<br>Map 算子因为类似于串行操作，所以性能比较低，而是 mapPartitions 算子类似于批处理，所以性能较高。但是 mapPartitions 算子会长时间占用内存，那么这样会导致内存可能不够用，出现内存溢出的错误。所以在内存有限的情况下，不推荐使用。使用 map 操作。</li>
</ul>
</li>
<li><p>练习与测试</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spark.core.rdd.operator.transform</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.rdd.<span class="type">RDD</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Spark02_RDD_Operator_Transform</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">"local[*]"</span>).setAppName(<span class="string">"Operator"</span>)</span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(sparkConf)</span><br><span class="line">    <span class="comment">// TODO 算子-mapPartitions</span></span><br><span class="line">    <span class="comment">// TODO 将待处理的数据以分区为单位发送到计算节点进行处理，这里的处理是指可以进行任意的处理，哪怕是过滤数据</span></span><br><span class="line">    <span class="comment">// TODO 将每个分区内的数值翻倍</span></span><br><span class="line">    <span class="comment">// [1,2] [3,4]</span></span><br><span class="line">    <span class="keyword">val</span> rdd = sc.makeRDD(<span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>), <span class="number">2</span>)</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        mapPartitions：执行效率高，可以批量的以分区为单位进行数据转换操作，但是会将整个分区的数据加载到内存进行引用，处理完的数据是不会被释放掉的，因为存在对象的引用。</span></span><br><span class="line"><span class="comment">        在内存较小，数据量比较大的场合下，容易出现内存溢出，反而用map效果较好。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">val</span> mappRDD: <span class="type">RDD</span>[<span class="type">Int</span>] = rdd.mapPartitions(iter =&gt; &#123;</span><br><span class="line">      println(<span class="string">"&gt;&gt;&gt;&gt;&gt;"</span>)</span><br><span class="line">      iter.map(_ * <span class="number">2</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// val mappRDD: RDD[Int] = rdd.mapPartitions(_.map(_ * 2))</span></span><br><span class="line">    mappRDD.collect().foreach(println)</span><br><span class="line">    sc.stop()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spark.core.rdd.operator.transform</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Spark02_RDD_Operator_Transform_Test</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">"local[*]"</span>).setAppName(<span class="string">"Operator"</span>)</span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(sparkConf)</span><br><span class="line">    <span class="comment">// TODO 算子-mapPartitions</span></span><br><span class="line">    <span class="comment">// TODO 获取每个数据分区的最大值</span></span><br><span class="line">    <span class="comment">// [1,2] [3,4]</span></span><br><span class="line">    <span class="keyword">val</span> rdd = sc.makeRDD(<span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>), <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">val</span> mappRDD = rdd.mapPartitions(iter =&gt; <span class="type">List</span>(iter.max).iterator)</span><br><span class="line">    mappRDD.collect().foreach(println)</span><br><span class="line">    sc.stop()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h6 id="mapPartitionsWithIndex"><a href="#mapPartitionsWithIndex" class="headerlink" title="mapPartitionsWithIndex"></a>mapPartitionsWithIndex</h6><ul>
<li><p>函数签名  </p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mapPartitionsWithIndex</span></span>[<span class="type">U</span>: <span class="type">ClassTag</span>](f: (<span class="type">Int</span>, <span class="type">Iterator</span>[<span class="type">T</span>]) =&gt; <span class="type">Iterator</span>[<span class="type">U</span>],preservesPartitioning: <span class="type">Boolean</span> = <span class="literal">false</span>): <span class="type">RDD</span>[<span class="type">U</span>]</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数说明  </p>
<p>将待处理的数据以分区为单位发送到计算节点进行处理，这里的处理是指可以进行任意的处理，哪怕是过滤数据，在处理时同时可以获取当前分区索引。  </p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> dataRDD1 = dataRDD.mapPartitionsWithIndex(</span><br><span class="line">    (index, datas) =&gt; &#123;</span><br><span class="line">    	datas.map(index, _)</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
</li>
<li><p>小功能：获取第二个数据分区的数据</p>
</li>
<li><p>练习与测试</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spark.core.rdd.operator.transform</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Spark03_RDD_Operator_Transform</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">"local[*]"</span>).setAppName(<span class="string">"Operator"</span>)</span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(sparkConf)</span><br><span class="line">    <span class="comment">// TODO 算子-mapPartitionsWithIndex</span></span><br><span class="line">    <span class="comment">// TODO 将待处理的数据以分区为单位发送到计算节点进行处理，这里的处理是指可以进行任意的处理，哪怕是过滤数据，在处理时同时可以获取当前分区索引</span></span><br><span class="line">    <span class="comment">// TODO 获取第二个数据分区的数据</span></span><br><span class="line">    <span class="comment">// [1,2] [3,4]</span></span><br><span class="line">    <span class="keyword">val</span> rdd = sc.makeRDD(<span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>), <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">val</span> mpiRDD = rdd.mapPartitionsWithIndex((index, iter) =&gt; &#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="number">1</span> == index) &#123; <span class="comment">// 保留第二个分区</span></span><br><span class="line">        iter</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">Nil</span>.iterator</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    mpiRDD.collect().foreach(println)</span><br><span class="line">    sc.stop()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spark.core.rdd.operator.transform</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Spark03_RDD_Operator_Transform_Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">"local[*]"</span>).setAppName(<span class="string">"Operator"</span>)</span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(sparkConf)</span><br><span class="line">    <span class="comment">// TODO 算子-mapPartitionsWithIndex</span></span><br><span class="line">    <span class="comment">// TODO 求每个数据以及所在的分区</span></span><br><span class="line">    <span class="keyword">val</span> rdd = sc.makeRDD(<span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)) <span class="comment">//共用所有核</span></span><br><span class="line">    <span class="keyword">val</span> mpiRDD = rdd.mapPartitionsWithIndex((index, iter) =&gt; iter.map(num =&gt; (index, num)))</span><br><span class="line">    mpiRDD.collect().foreach(println)</span><br><span class="line">    sc.stop()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h6 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap"></a>flatMap</h6><ul>
<li><p>函数签名  </p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">flatMap</span></span>[<span class="type">U</span>: <span class="type">ClassTag</span>](f: <span class="type">T</span> =&gt; <span class="type">TraversableOnce</span>[<span class="type">U</span>]): <span class="type">RDD</span>[<span class="type">U</span>]</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数说明  </p>
<p>将处理的数据进行扁平化后再进行映射处理，所以算子也称之为扁平映射  </p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> dataRDD = sparkContext.makeRDD(<span class="type">List</span>(</span><br><span class="line">	<span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>),<span class="type">List</span>(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">),<span class="number">1</span>)</span><br><span class="line"><span class="keyword">val</span> dataRDD1 = dataRDD.flatMap(</span><br><span class="line">	list =&gt; list</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
</li>
<li><p>小功能：将 List(List(1,2),3,List(4,5))进行扁平化操作</p>
</li>
<li><p>练习与测试</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spark.core.rdd.operator.transform</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.rdd.<span class="type">RDD</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Spark04_RDD_Operator_Transform</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">"local[*]"</span>).setAppName(<span class="string">"Operator"</span>)</span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(sparkConf)</span><br><span class="line">    <span class="comment">// TODO 算子-flatMap 扁平化</span></span><br><span class="line">    <span class="comment">// TODO 将处理的数据进行扁平化后再进行映射处理，所以算子也称之为扁平映射</span></span><br><span class="line">    <span class="comment">// TODO 集合数据扁平化</span></span><br><span class="line">    <span class="keyword">val</span> rdd: <span class="type">RDD</span>[<span class="type">List</span>[<span class="type">Int</span>]] = sc.makeRDD(<span class="type">List</span>(<span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>), <span class="type">List</span>(<span class="number">3</span>, <span class="number">4</span>)))</span><br><span class="line">    <span class="keyword">val</span> flatRDD = rdd.flatMap(list =&gt; &#123;</span><br><span class="line">      list <span class="comment">// 这里要返回集合</span></span><br><span class="line">    &#125;)</span><br><span class="line">    flatRDD.collect().foreach(println)</span><br><span class="line">    sc.stop()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spark.core.rdd.operator.transform</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.rdd.<span class="type">RDD</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Spark04_RDD_Operator_Transform_Test</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">"local[*]"</span>).setAppName(<span class="string">"Operator"</span>)</span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(sparkConf)</span><br><span class="line">    <span class="comment">// TODO 算子-flatMap 扁平化</span></span><br><span class="line">    <span class="comment">// TODO 切割字符串转换成数组然后进行扁平化</span></span><br><span class="line">    <span class="keyword">val</span> rdd: <span class="type">RDD</span>[<span class="type">String</span>] = sc.makeRDD(<span class="type">List</span>(<span class="string">"Hello Scala"</span>, <span class="string">"Hello Spark"</span>))</span><br><span class="line">    <span class="keyword">val</span> fmRDD: <span class="type">RDD</span>[<span class="type">String</span>] = rdd.flatMap(_.split(<span class="string">" "</span>))</span><br><span class="line">    fmRDD.collect().foreach(println)</span><br><span class="line">    sc.stop()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spark.core.rdd.operator.transform</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Spark04_RDD_Operator_Transform_Test1</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">"local[*]"</span>).setAppName(<span class="string">"Operator"</span>)</span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(sparkConf)</span><br><span class="line">    <span class="comment">// TODO 算子-flatMap 扁平化</span></span><br><span class="line">    <span class="comment">// TODO 将 List(List(1,2),3,List(4,5))进行扁平化操作</span></span><br><span class="line">    <span class="keyword">val</span> rdd = sc.makeRDD(<span class="type">List</span>(<span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>), <span class="number">3</span>, <span class="type">List</span>(<span class="number">4</span>, <span class="number">5</span>)))</span><br><span class="line">    <span class="comment">// 使用模式匹配</span></span><br><span class="line">    <span class="comment">// val fmRDD = rdd.flatMap(</span></span><br><span class="line">    <span class="comment">//   item =&gt; &#123;</span></span><br><span class="line">    <span class="comment">//      item match &#123;</span></span><br><span class="line">    <span class="comment">//       case list: List[Int] =&gt; list</span></span><br><span class="line">    <span class="comment">//       case i: Int =&gt; List(i)</span></span><br><span class="line">    <span class="comment">//      &#125;</span></span><br><span class="line">    <span class="comment">//   &#125;)</span></span><br><span class="line">    <span class="comment">// 使用偏函数</span></span><br><span class="line">    <span class="keyword">val</span> fmRDD = rdd.flatMap &#123;</span><br><span class="line">      <span class="keyword">case</span> list: <span class="type">List</span>[<span class="type">Int</span>] =&gt; list</span><br><span class="line">      <span class="keyword">case</span> i: <span class="type">Int</span> =&gt; <span class="type">List</span>(i)</span><br><span class="line">    &#125;</span><br><span class="line">    fmRDD.collect().foreach(println)</span><br><span class="line">    sc.stop()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h6 id="glom"><a href="#glom" class="headerlink" title="glom"></a>glom</h6><ul>
<li><p>函数签名  </p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">glom</span></span>(): <span class="type">RDD</span>[<span class="type">Array</span>[<span class="type">T</span>]]</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数说明  </p>
<p>将同一个分区的数据直接转换为相同类型的内存数组进行处理，分区不变  </p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> dataRDD = sparkContext.makeRDD(<span class="type">List</span>(</span><br><span class="line">	<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span></span><br><span class="line">),<span class="number">1</span>)</span><br><span class="line"><span class="keyword">val</span> dataRDD1:<span class="type">RDD</span>[<span class="type">Array</span>[<span class="type">Int</span>]] = dataRDD.glom()</span><br></pre></td></tr></table></figure>
</li>
<li><p>小功能：计算所有分区最大值求和（分区内取最大值，分区间最大值求和）</p>
</li>
<li><p>练习与测试</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spark.core.rdd.operator.transform</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.rdd.<span class="type">RDD</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Spark05_RDD_Operator_Transform</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">"local[*]"</span>).setAppName(<span class="string">"Operator"</span>)</span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(sparkConf)</span><br><span class="line">    <span class="comment">// TODO 算子-glom</span></span><br><span class="line">    <span class="comment">// TODO 将同一个分区的数据直接转换为相同类型的内存数组进行处理，分区不变</span></span><br><span class="line">    <span class="comment">// TODO 分区内数据变集合</span></span><br><span class="line">    <span class="keyword">val</span> rdd: <span class="type">RDD</span>[<span class="type">Int</span>] = sc.makeRDD(<span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>), <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">val</span> glomRDD: <span class="type">RDD</span>[<span class="type">Array</span>[<span class="type">Int</span>]] = rdd.glom()</span><br><span class="line">    println(glomRDD.collect().mkString(<span class="string">","</span>))</span><br><span class="line">    glomRDD.collect().foreach(data =&gt; println(data.mkString(<span class="string">","</span>)))</span><br><span class="line">    sc.stop()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spark.core.rdd.operator.transform</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.rdd.<span class="type">RDD</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Spark05_RDD_Operator_Transform_Test</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">"local[*]"</span>).setAppName(<span class="string">"Operator"</span>)</span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(sparkConf)</span><br><span class="line">    <span class="comment">// TODO 算子-glom</span></span><br><span class="line">    <span class="comment">// TODO 计算所有分区最大值求和（分区内取最大值，分区间最大值求和）</span></span><br><span class="line">    <span class="keyword">val</span> rdd: <span class="type">RDD</span>[<span class="type">Int</span>] = sc.makeRDD(<span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>), <span class="number">2</span>)</span><br><span class="line">    <span class="comment">// 【1，2】，【3，4】</span></span><br><span class="line">    <span class="comment">// 【2】，【4】</span></span><br><span class="line">    <span class="comment">// 【6】</span></span><br><span class="line">    <span class="keyword">val</span> glomRDD: <span class="type">RDD</span>[<span class="type">Array</span>[<span class="type">Int</span>]] = rdd.glom()</span><br><span class="line">    <span class="keyword">val</span> maxRDD: <span class="type">RDD</span>[<span class="type">Int</span>] = glomRDD.map(_.max)</span><br><span class="line">    println(maxRDD.collect().sum)</span><br><span class="line">      </span><br><span class="line">    sc.stop()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h6 id="groupBy"><a href="#groupBy" class="headerlink" title="groupBy"></a>groupBy</h6><ul>
<li><p>函数签名  </p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">groupBy</span></span>[<span class="type">K</span>](f: <span class="type">T</span> =&gt; <span class="type">K</span>)(<span class="keyword">implicit</span> kt: <span class="type">ClassTag</span>[<span class="type">K</span>]): <span class="type">RDD</span>[(<span class="type">K</span>, <span class="type">Iterable</span>[<span class="type">T</span>])]</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数说明  </p>
<p>将数据根据指定的规则进行分组, 分区默认不变，但是数据会被打乱重新组合，我们将这样的操作称之为 shuffle。极限情况下，数据可能被分在同一个分区中  </p>
<p>一个组的数据在一个分区中，但是并不是说一个分区中只有一个组  </p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> dataRDD = sparkContext.makeRDD(<span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>),<span class="number">1</span>)</span><br><span class="line"><span class="keyword">val</span> dataRDD1 = dataRDD.groupBy(</span><br><span class="line">	_%<span class="number">2</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>groupBy会将数据打乱（打散），重新组合，这个操作我们称之为shuffle，下面是与map的对比图</p>
<ul>
<li>map</li>
</ul>
<p><img src="/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230907144557799.png" alt="image-20230907144557799"></p>
<ul>
<li>groupBy</li>
</ul>
<p><img src="/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230907112107435.png" alt="image-20230907112107435"></p>
</li>
<li><p>小功能： 将 List(“Hello”, “hive”, “hbase”, “Hadoop”)根据单词首写字母进行分组。</p>
</li>
<li><p>小功能： 从服务器日志数据 apache.log 中获取每个时间段访问量。</p>
</li>
<li><p>小功能： WordCount</p>
</li>
<li><p>练习与测试</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spark.core.rdd.operator.transform</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.rdd.<span class="type">RDD</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Spark06_RDD_Operator_Transform</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">"local[*]"</span>).setAppName(<span class="string">"Operator"</span>)</span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(sparkConf)</span><br><span class="line">    <span class="comment">// TODO 算子-groupBy</span></span><br><span class="line">    <span class="comment">// TODO 将数据根据指定的规则进行分组，分区默认不变，但是数据会被打乱重新组合，我们将这样的操作称之为 shuffle。极限情况下，数据可能被分在同一个分区中，一个组的数据在一个分区中，但是并不是说一个分区中只有一个组。</span></span><br><span class="line">    <span class="comment">// TODO 根据奇数偶数进行分组</span></span><br><span class="line">    <span class="keyword">val</span> rdd: <span class="type">RDD</span>[<span class="type">Int</span>] = sc.makeRDD(<span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>), <span class="number">2</span>)</span><br><span class="line">    <span class="comment">// groupBy会将数据源中的每一个数据进行分组判断，根据返回的分组key进行分组，相同的key值的数据会放置在一个组中</span></span><br><span class="line">    <span class="keyword">val</span> gbRDD: <span class="type">RDD</span>[(<span class="type">Int</span>, <span class="type">Iterable</span>[<span class="type">Int</span>])] = rdd.groupBy(_ % <span class="number">2</span>)</span><br><span class="line">    gbRDD.collect().foreach(println)</span><br><span class="line"></span><br><span class="line">    sc.stop()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spark.core.rdd.operator.transform</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.rdd.<span class="type">RDD</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Spark06_RDD_Operator_Transform_Test</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">"local[*]"</span>).setAppName(<span class="string">"Operator"</span>)</span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(sparkConf)</span><br><span class="line">    <span class="comment">// TODO 算子-groupBy</span></span><br><span class="line">    <span class="comment">// TODO 将 List("Hello", "Spark", "Scala", "Hadoop")根据单词首写字母进行分组</span></span><br><span class="line">    <span class="keyword">val</span> rdd: <span class="type">RDD</span>[<span class="type">String</span>] = sc.makeRDD(<span class="type">List</span>(<span class="string">"Hello"</span>, <span class="string">"Spark"</span>, <span class="string">"Scala"</span>, <span class="string">"Hadoop"</span>), <span class="number">2</span>)</span><br><span class="line">    <span class="comment">// groupBy会将数据源中的每一个数据进行分组判断，根据返回的分组key进行分组，相同的key值的数据会放置在一个组中</span></span><br><span class="line">    <span class="comment">// 分组和分区没有必然的关系！！！</span></span><br><span class="line">    <span class="keyword">val</span> gbRDD: <span class="type">RDD</span>[(<span class="type">Char</span>, <span class="type">Iterable</span>[<span class="type">String</span>])] = rdd.groupBy(_.charAt(<span class="number">0</span>))</span><br><span class="line">    gbRDD.collect().foreach(println)</span><br><span class="line"></span><br><span class="line">    sc.stop()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spark.core.rdd.operator.transform</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.rdd.<span class="type">RDD</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Spark06_RDD_Operator_Transform_Test1</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">"local[*]"</span>).setAppName(<span class="string">"Operator"</span>)</span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(sparkConf)</span><br><span class="line">    <span class="comment">// TODO 算子-groupBy</span></span><br><span class="line">    <span class="comment">// TODO 从服务器日志数据 apache.log 中获取每个时间段访问量</span></span><br><span class="line">    <span class="keyword">val</span> rdd = sc.textFile(<span class="string">"datas/apache.log"</span>)</span><br><span class="line">    <span class="keyword">val</span> gbRDDIte: <span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">Iterable</span>[<span class="type">String</span>])] = rdd.groupBy(_.split(<span class="string">" "</span>)(<span class="number">3</span>).split(<span class="string">":"</span>)(<span class="number">1</span>))</span><br><span class="line">    <span class="comment">// val gbRDD: RDD[(String, Int)] = gbRDDIte.map(tup =&gt; (tup._1, tup._2.size))</span></span><br><span class="line">    <span class="keyword">val</span> gbRDD: <span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = gbRDDIte.map &#123;</span><br><span class="line">      <span class="keyword">case</span> (k, v) =&gt; (k, v.size)</span><br><span class="line">    &#125;</span><br><span class="line">    gbRDD.collect().foreach(println)</span><br><span class="line">    sc.stop()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h6 id="filter"><a href="#filter" class="headerlink" title="filter"></a>filter</h6><ul>
<li><p>函数签名  </p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">filter</span></span>(f: <span class="type">T</span> =&gt; <span class="type">Boolean</span>): <span class="type">RDD</span>[<span class="type">T</span>]</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数说明  </p>
<p>将数据根据指定的规则进行筛选过滤，符合规则的数据保留，不符合规则的数据丢弃。当数据进行筛选过滤后，分区不变，但是分区内的数据可能不均衡，生产环境下，可能会出现数据倾斜。  </p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> dataRDD = sparkContext.makeRDD(<span class="type">List</span>(</span><br><span class="line">	<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span></span><br><span class="line">),<span class="number">1</span>)</span><br><span class="line"><span class="keyword">val</span> dataRDD1 = dataRDD.filter(_%<span class="number">2</span> == <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>小功能：从服务器日志数据 apache.log 中获取 2015 年 5 月 17 日的请求路径</p>
</li>
<li><p>练习与测试</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spark.core.rdd.operator.transform</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Spark07_RDD_Operator_Transform</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">"local[*]"</span>).setAppName(<span class="string">"Operator"</span>)</span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(sparkConf)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 算子-filter</span></span><br><span class="line">    <span class="comment">// TODO 将数据根据指定的规则进行筛选过滤，符合规则的数据保留，不符合规则的数据丢弃。当数据进行筛选过滤后，分区不变，但是分区内的数据可能不均衡，生产环境下，可能会出现数据倾斜。</span></span><br><span class="line">    <span class="comment">// TODO 过滤数据，只留下奇数</span></span><br><span class="line">    <span class="keyword">val</span> rdd = sc.makeRDD(<span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line">    <span class="keyword">val</span> mRDD = rdd.filter(_ % <span class="number">2</span> != <span class="number">0</span>)</span><br><span class="line">    mRDD.collect().foreach(println)</span><br><span class="line">    sc.stop()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spark.core.rdd.operator.transform</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Spark07_RDD_Operator_Transform_Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">"local[*]"</span>).setAppName(<span class="string">"Operator"</span>)</span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(sparkConf)</span><br><span class="line">    <span class="comment">// TODO 算子-filter</span></span><br><span class="line">    <span class="comment">// TODO 从服务器日志数据 apache.log 中获取 2015 年 5 月 17 日的请求路径</span></span><br><span class="line">    <span class="keyword">val</span> rdd = sc.textFile(<span class="string">"datas/apache.log"</span>)</span><br><span class="line">    <span class="keyword">val</span> fRDD = rdd.filter(_.split(<span class="string">" "</span>)(<span class="number">3</span>).startsWith(<span class="string">"17/05/2015"</span>))</span><br><span class="line">    fRDD.collect().foreach(println)</span><br><span class="line">    sc.stop()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h6 id="sample"><a href="#sample" class="headerlink" title="sample"></a>sample</h6><ul>
<li><p>函数签名  </p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sample</span></span>(withReplacement: <span class="type">Boolean</span>, fraction: <span class="type">Double</span>, seed: <span class="type">Long</span> = <span class="type">Utils</span>.random.nextLong): <span class="type">RDD</span>[<span class="type">T</span>]</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数说明  </p>
<p>根据指定的规则从数据集中抽取数据  </p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> dataRDD = sparkContext.makeRDD(<span class="type">List</span>(</span><br><span class="line">	<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span></span><br><span class="line">),<span class="number">1</span>)</span><br><span class="line"><span class="comment">// 抽取数据不放回（伯努利算法）</span></span><br><span class="line"><span class="comment">// 伯努利算法：又叫 0、 1 分布。例如扔硬币，要么正面，要么反面。</span></span><br><span class="line"><span class="comment">// 具体实现：根据种子和随机算法算出一个数和第二个参数设置几率比较，小于第二个参数要，大于不要</span></span><br><span class="line"><span class="comment">// 第一个参数：抽取的数据是否放回， false：不放回</span></span><br><span class="line"><span class="comment">// 第二个参数：抽取的几率，范围在[0,1]之间,0：全不取； 1：全取；</span></span><br><span class="line"><span class="comment">// 第三个参数：随机数种子</span></span><br><span class="line"><span class="keyword">val</span> dataRDD1 = dataRDD.sample(<span class="literal">false</span>, <span class="number">0.5</span>)</span><br><span class="line"><span class="comment">// 抽取数据放回（泊松算法）</span></span><br><span class="line"><span class="comment">// 第一个参数：抽取的数据是否放回， true：放回； false：不放回</span></span><br><span class="line"><span class="comment">// 第二个参数：重复数据的几率，范围大于等于 0.表示每一个元素被期望抽取到的次数</span></span><br><span class="line"><span class="comment">// 第三个参数：随机数种子</span></span><br><span class="line"><span class="keyword">val</span> dataRDD2 = dataRDD.sample(<span class="literal">true</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>思考一个问题：有啥用，抽奖吗？  </p>
</li>
<li><p>练习与测试</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spark.core.rdd.operator.transform</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Spark08_RDD_Operator_Transform</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">"local[*]"</span>).setAppName(<span class="string">"Operator"</span>)</span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(sparkConf)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 算子-sample</span></span><br><span class="line">    <span class="comment">// TODO 根据指定的规则从数据集中抽取数据</span></span><br><span class="line">    <span class="comment">// TODO 数据抽取</span></span><br><span class="line">    <span class="keyword">val</span> rdd = sc.makeRDD(<span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>))</span><br><span class="line">    <span class="comment">// sample算子需要传递三个参数</span></span><br><span class="line">    <span class="comment">// 1. 第一个参数表示：抽取数据后是否将数据放回。true(放回)，false(丢弃)</span></span><br><span class="line">    <span class="comment">// 2. 第二个参数表示：</span></span><br><span class="line">    <span class="comment">//    1）如果是抽取不放回的场合：数据源中每条数据被抽取的概率，基准值的概念</span></span><br><span class="line">    <span class="comment">//    2）如果抽取放回的场合：表示数据源中的每条数据被抽取的可能次数</span></span><br><span class="line">    <span class="comment">// 3. 第三个参数表示：抽取数据时随机算法的种子。如果不传递第三个参数，那么使用的当前系统时间作为种子，如果传递，则种子固定，每次抽取的内容也是固定。</span></span><br><span class="line">    <span class="comment">// rdd.sample(false,0.4,1).collect().foreach(println) // 内容 固定</span></span><br><span class="line">    <span class="comment">// rdd.sample(false,0.4).collect().foreach(println)</span></span><br><span class="line">    rdd.sample(<span class="literal">true</span>, <span class="number">2</span>).collect().foreach(println)</span><br><span class="line">    sc.stop()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h6 id="distinct"><a href="#distinct" class="headerlink" title="distinct"></a>distinct</h6><ul>
<li><p>函数签名  </p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">distinct</span></span>()(<span class="keyword">implicit</span> ord: <span class="type">Ordering</span>[<span class="type">T</span>] = <span class="literal">null</span>): <span class="type">RDD</span>[<span class="type">T</span>]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">distinct</span></span>(numPartitions: <span class="type">Int</span>)(<span class="keyword">implicit</span> ord: <span class="type">Ordering</span>[<span class="type">T</span>] = <span class="literal">null</span>): <span class="type">RDD</span>[<span class="type">T</span>]</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数说明  </p>
<p>将数据集中重复的数据去重  </p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> dataRDD = sparkContext.makeRDD(<span class="type">List</span>(</span><br><span class="line">	<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span></span><br><span class="line">),<span class="number">1</span>)</span><br><span class="line"><span class="keyword">val</span> dataRDD1 = dataRDD.distinct()</span><br><span class="line"><span class="keyword">val</span> dataRDD2 = dataRDD.distinct(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>思考一个问题： 如果不用该算子，你有什么办法实现数据去重？</p>
</li>
<li><p>练习与测试</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spark.core.rdd.operator.transform</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.rdd.<span class="type">RDD</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Spark09_RDD_Operator_Transform</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">"local[*]"</span>).setAppName(<span class="string">"Operator"</span>)</span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(sparkConf)</span><br><span class="line">    <span class="comment">// TODO 算子-distinct</span></span><br><span class="line">    <span class="comment">// TODO 将数据集中重复的数据去重</span></span><br><span class="line">    <span class="comment">// TODO 数据去重</span></span><br><span class="line">    <span class="keyword">val</span> rdd = sc.makeRDD(<span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line">    <span class="keyword">val</span> rdd1 = rdd.distinct() <span class="comment">// map(x =&gt; (x, null)).reduceByKey((x, _) =&gt; x, numPartitions).map(_._1)</span></span><br><span class="line">    rdd1.collect().foreach(println)</span><br><span class="line">    sc.stop()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h6 id="coalesce"><a href="#coalesce" class="headerlink" title="coalesce"></a>coalesce</h6><ul>
<li><p>函数签名  </p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">coalesce</span></span>(numPartitions: <span class="type">Int</span>, shuffle: <span class="type">Boolean</span> = <span class="literal">false</span>,partitionCoalescer: <span class="type">Option</span>[<span class="type">PartitionCoalescer</span>] = <span class="type">Option</span>.empty)</span><br><span class="line">(<span class="keyword">implicit</span> ord: <span class="type">Ordering</span>[<span class="type">T</span>] = <span class="literal">null</span>): <span class="type">RDD</span>[<span class="type">T</span>]</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数说明  </p>
<p>根据数据量缩减分区，用于大数据集过滤后，提高小数据集的执行效率当 spark 程序中，存在过多的小任务的时候，可以通过 coalesce 方法，收缩合并分区，减少分区的个数，减小任务调度成本</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> dataRDD = sparkContext.makeRDD(<span class="type">List</span>(</span><br><span class="line">	<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span></span><br><span class="line">),<span class="number">6</span>)</span><br><span class="line"><span class="keyword">val</span> dataRDD1 = dataRDD.coalesce(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>思考一个问题： 我想要扩大分区，怎么办？</p>
</li>
<li><p>练习与测试</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spark.core.rdd.operator.transform</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Spark10_RDD_Operator_Transform</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">"local[*]"</span>).setAppName(<span class="string">"Operator"</span>)</span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(sparkConf)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 算子-coalesce</span></span><br><span class="line">    <span class="comment">// TODO 根据数据量缩减分区，用于大数据集过滤后，提高小数据集的执行效率，当spark程序中，存在过多的小任务的时候，可以通过 coalesce 方法，收缩合并分区，减少分区的个数，减小任务调度成本。</span></span><br><span class="line">    <span class="comment">// TODO 合并分区</span></span><br><span class="line">    <span class="comment">// 1)</span></span><br><span class="line">    <span class="comment">//    val rdd = sc.makeRDD(List(1, 2, 3, 4),4)</span></span><br><span class="line">    <span class="comment">//    val newRDD = rdd.coalesce(2)</span></span><br><span class="line">    <span class="comment">//    newRDD.saveAsTextFile("output")</span></span><br><span class="line">    <span class="comment">// 2)</span></span><br><span class="line">    <span class="keyword">val</span> rdd = sc.makeRDD(<span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>), <span class="number">3</span>)</span><br><span class="line">    <span class="comment">// clalesce 缩减分区方法默认情况下不会拆散原有分区内的数据组合，不会将分区的数据打乱重新组合</span></span><br><span class="line">    <span class="comment">// 但是这种情况下的缩减分区可能会导致数据不均衡，出现数据倾斜，比如原来有三个分区，现在缩减成两个，缩减的时候原来的一个少的单独成为一个分区，另外两个多的合并成为一个大的分区。</span></span><br><span class="line">    <span class="comment">// 如果想让数据均衡，可进行shuffle处理，第二个参数设置为true</span></span><br><span class="line">    <span class="comment">// val newRDD = rdd.coalesce(2)</span></span><br><span class="line">    <span class="keyword">val</span> newRDD = rdd.coalesce(<span class="number">2</span>, <span class="literal">true</span>)</span><br><span class="line">    newRDD.saveAsTextFile(<span class="string">"output"</span>)</span><br><span class="line">    sc.stop()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h6 id="repartition"><a href="#repartition" class="headerlink" title="repartition"></a>repartition</h6><ul>
<li><p>函数签名  </p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">repartition</span></span>(numPartitions: <span class="type">Int</span>)(<span class="keyword">implicit</span> ord: <span class="type">Ordering</span>[<span class="type">T</span>] = <span class="literal">null</span>): <span class="type">RDD</span>[<span class="type">T</span>]</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数说明  </p>
<p>该操作内部其实执行的是 coalesce 操作，参数 shuffle 的默认值为 true。无论是将分区数多的RDD 转换为分区数少的 RDD，还是将分区数少的 RDD 转换为分区数多的 RDD， repartition操作都可以完成，因为无论如何都会经 shuffle 过程。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> dataRDD = sparkContext.makeRDD(<span class="type">List</span>(</span><br><span class="line">	<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span></span><br><span class="line">),<span class="number">2</span>)</span><br><span class="line"><span class="keyword">val</span> dataRDD1 = dataRDD.repartition(<span class="number">4</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>思考一个问题： coalesce 和 repartition 区别？  </p>
</li>
<li><p>练习与测试</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spark.core.rdd.operator.transform</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Spark11_RDD_Operator_Transform</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">"local[*]"</span>).setAppName(<span class="string">"Operator"</span>)</span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(sparkConf)</span><br><span class="line">    <span class="comment">// TODO 算子-repartition</span></span><br><span class="line">    <span class="comment">// TODO 该操作内部其实执行的是 coalesce 操作，参数 shuffle 的默认值为 true。无论是将分区数多的RDD 转换为分区数少的 RDD，还是将分区数少的 RDD 转换为分区数多的RDD， repartition操作都可以完成，因为无论如何都会经 shuffle 过程。</span></span><br><span class="line">    <span class="comment">// TODO 增加分区</span></span><br><span class="line">    <span class="keyword">val</span> rdd = sc.makeRDD(<span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>), <span class="number">2</span>)</span><br><span class="line">    <span class="comment">// 同理，coalesce是可以增加分区的，如果想要进行shuffle处理保持数据均衡，让数据分配到各个分区中，则第二个参数也要设置为true，才能实现扩大分区的效果，不然数据不会分配到新增加的分区中，没有意义也不起作用。</span></span><br><span class="line">    <span class="comment">// val newRDD = rdd.coalesce(3)</span></span><br><span class="line">    <span class="comment">// val newRDD = rdd.coalesce(3, true)</span></span><br><span class="line">    <span class="comment">// spark提供了一个简化的操作</span></span><br><span class="line">    <span class="comment">// 缩减分区：coalesce，如果想要数据均衡，可以采用sheffle</span></span><br><span class="line">    <span class="comment">// 扩大分区：repartition，底层使用的也是coalesce，且第二个参数为true，采用shuffle</span></span><br><span class="line">    <span class="keyword">val</span> newRDD = rdd.repartition(<span class="number">3</span>)</span><br><span class="line">    newRDD.saveAsTextFile(<span class="string">"output"</span>)</span><br><span class="line">    sc.stop()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h6 id="sortBy"><a href="#sortBy" class="headerlink" title="sortBy"></a>sortBy</h6><ul>
<li><p>函数签名  </p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sortBy</span></span>[<span class="type">K</span>](f: (<span class="type">T</span>) =&gt; <span class="type">K</span>,ascending: <span class="type">Boolean</span> = <span class="literal">true</span>,numPartitions: <span class="type">Int</span> = <span class="keyword">this</span>.partitions.length)</span><br><span class="line">(<span class="keyword">implicit</span> ord: <span class="type">Ordering</span>[<span class="type">K</span>], ctag: <span class="type">ClassTag</span>[<span class="type">K</span>]): <span class="type">RDD</span>[<span class="type">T</span>]</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数说明  </p>
<p>该操作用于排序数据。在排序之前，可以将数据通过 f 函数进行处理，之后按照 f 函数处理的结果进行排序，默认为升序排列。排序后新产生的 RDD 的分区数与原 RDD 的分区数一致。 中间存在 shuffle 的过程。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> dataRDD = sparkContext.makeRDD(<span class="type">List</span>(</span><br><span class="line">	<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">2</span></span><br><span class="line">),<span class="number">2</span>)</span><br><span class="line"><span class="keyword">val</span> dataRDD1 = dataRDD.sortBy(num=&gt;num, <span class="literal">false</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>练习与测试</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spark.core.rdd.operator.transform</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Spark12_RDD_Operator_Transform</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">"local[*]"</span>).setAppName(<span class="string">"Operator"</span>)</span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(sparkConf)</span><br><span class="line">    <span class="comment">// TODO 算子-sortBy</span></span><br><span class="line">    <span class="comment">// TODO 该操作用于排序数据。在排序之前，可以将数据通过 f 函数进行处理，之后按照 f 函数处理的结果进行排序，默认为升序排列。排序后新产生的 RDD 的分区数与原 RDD 的分区数一致。 中间存在 shuffle 的过程</span></span><br><span class="line">    <span class="comment">// TODO 排序</span></span><br><span class="line">    <span class="keyword">val</span> rdd = sc.makeRDD(<span class="type">List</span>(<span class="number">6</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>), <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">val</span> newRDD = rdd.sortBy(num =&gt; num)</span><br><span class="line">    newRDD.saveAsTextFile(<span class="string">"output"</span>)</span><br><span class="line">    sc.stop()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spark.core.rdd.operator.transform</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Spark12_RDD_Operator_Transform_Test</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">"local[*]"</span>).setAppName(<span class="string">"Operator"</span>)</span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(sparkConf)</span><br><span class="line">    <span class="comment">// TODO 算子-sortBy</span></span><br><span class="line">    <span class="comment">// TODO 自定义排序</span></span><br><span class="line">    <span class="keyword">val</span> rdd = sc.makeRDD(<span class="type">List</span>((<span class="string">"1"</span>, <span class="number">1</span>), (<span class="string">"11"</span>, <span class="number">2</span>), (<span class="string">"2"</span>, <span class="number">3</span>)), <span class="number">2</span>)</span><br><span class="line">    <span class="comment">// val newRDD = rdd.sortBy(t =&gt; t._1.toInt)</span></span><br><span class="line">    <span class="comment">// sortBy方法可以根据指定的规则对数据源中的数据进行排序，默认为升序，第二个参数可以改变排序的方式</span></span><br><span class="line">    <span class="comment">// sortBy默认情况下，不会改变分区，但是中间存在shuffle操作</span></span><br><span class="line">    <span class="keyword">val</span> newRDD = rdd.sortBy(t =&gt; t._1.toInt, <span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line">    newRDD.saveAsTextFile(<span class="string">"output"</span>)</span><br><span class="line">    newRDD.collect().foreach(println)</span><br><span class="line">    sc.stop()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="双-Value-类型"><a href="#双-Value-类型" class="headerlink" title="双 Value 类型"></a>双 Value 类型</h5><h6 id="intersection"><a href="#intersection" class="headerlink" title="intersection"></a>intersection</h6><ul>
<li><p>函数签名  </p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">intersection</span></span>(other: <span class="type">RDD</span>[<span class="type">T</span>]): <span class="type">RDD</span>[<span class="type">T</span>]</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数说明  </p>
<p>对源 RDD 和参数 RDD 求交集后返回一个新的 RDD  </p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> dataRDD1 = sparkContext.makeRDD(<span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line"><span class="keyword">val</span> dataRDD2 = sparkContext.makeRDD(<span class="type">List</span>(<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>))</span><br><span class="line"><span class="keyword">val</span> dataRDD = dataRDD1.intersection(dataRDD2)</span><br></pre></td></tr></table></figure>
</li>
<li><p>思考一个问题： 如果两个 RDD 数据类型不一致怎么办？</p>
</li>
</ul>
<h6 id="union"><a href="#union" class="headerlink" title="union"></a>union</h6><ul>
<li><p>函数签名  </p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">union</span></span>(other: <span class="type">RDD</span>[<span class="type">T</span>]): <span class="type">RDD</span>[<span class="type">T</span>]</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数说明  </p>
<p>对源 RDD 和参数 RDD 求并集后返回一个新的 RDD  </p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> dataRDD1 = sparkContext.makeRDD(<span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line"><span class="keyword">val</span> dataRDD2 = sparkContext.makeRDD(<span class="type">List</span>(<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>))</span><br><span class="line"><span class="keyword">val</span> dataRDD = dataRDD1.union(dataRDD2)</span><br></pre></td></tr></table></figure>
</li>
<li><p>思考一个问题： 如果两个 RDD 数据类型不一致怎么办？  </p>
</li>
</ul>
<h6 id="subtract"><a href="#subtract" class="headerlink" title="subtract"></a>subtract</h6><ul>
<li><p>函数签名  </p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">subtract</span></span>(other: <span class="type">RDD</span>[<span class="type">T</span>]): <span class="type">RDD</span>[<span class="type">T</span>]</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数说明  </p>
<p>以一个 RDD 元素为主， 去除两个 RDD 中重复元素，将其他元素保留下来。求差集  </p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> dataRDD1 = sparkContext.makeRDD(<span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line"><span class="keyword">val</span> dataRDD2 = sparkContext.makeRDD(<span class="type">List</span>(<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>))</span><br><span class="line"><span class="keyword">val</span> dataRDD = dataRDD1.subtract(dataRDD2)</span><br></pre></td></tr></table></figure>

<p>思考一个问题： 如果两个 RDD 数据类型不一致怎么办？  </p>
</li>
</ul>
<h6 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h6><ul>
<li><p>函数签名  </p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">zip</span></span>[<span class="type">U</span>: <span class="type">ClassTag</span>](other: <span class="type">RDD</span>[<span class="type">U</span>]): <span class="type">RDD</span>[(<span class="type">T</span>, <span class="type">U</span>)]</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数说明  </p>
<p>将两个 RDD 中的元素，以键值对的形式进行合并。其中，键值对中的 Key 为第 1 个 RDD中的元素， Value 为第 2 个 RDD 中的相同位置的元素。  </p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> dataRDD1 = sparkContext.makeRDD(<span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line"><span class="keyword">val</span> dataRDD2 = sparkContext.makeRDD(<span class="type">List</span>(<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>))</span><br><span class="line"><span class="keyword">val</span> dataRDD = dataRDD1.zip(dataRDD2)</span><br></pre></td></tr></table></figure>
</li>
<li><p>思考一个问题： 如果两个 RDD 数据类型不一致怎么办？</p>
</li>
<li><p>思考一个问题： 如果两个 RDD 数据分区不一致怎么办？</p>
</li>
<li><p>思考一个问题： 如果两个 RDD 分区数据数量不一致怎么办？  </p>
</li>
<li><p>练习与测试</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spark.core.rdd.operator.transform</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Spark13_RDD_Operator_Transform</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">"local[*]"</span>).setAppName(<span class="string">"Operator"</span>)</span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(sparkConf)</span><br><span class="line">    <span class="comment">// TODO 算子-双Value类型</span></span><br><span class="line">    <span class="comment">// TODO 对交集、并集、差集以及拉链算子进行测试。交集、并集、差集要求两个数据源数据类型保持一致，拉链操作两个数据源的类型可以不一致</span></span><br><span class="line">    <span class="keyword">val</span> rdd1 = sc.makeRDD(<span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line">    <span class="keyword">val</span> rdd2 = sc.makeRDD(<span class="type">List</span>(<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>))</span><br><span class="line">    <span class="keyword">val</span> rdd7 = sc.makeRDD(<span class="type">List</span>(<span class="string">"33"</span>,<span class="string">"44"</span>,<span class="string">"55"</span>,<span class="string">"66"</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 算子-intersection 交集 3,4</span></span><br><span class="line">    <span class="comment">// TODO 对源 RDD 和参数 RDD 求交集后返回一个新的 RDD</span></span><br><span class="line">    <span class="comment">// TODO 求交集</span></span><br><span class="line">    <span class="keyword">val</span> rdd3 = rdd1.intersection(rdd2)</span><br><span class="line">    println(rdd3.collect().mkString(<span class="string">","</span>))</span><br><span class="line">    println(<span class="string">"========================"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 算子-union 并集 1,2,3,4,3,4,5,6</span></span><br><span class="line">    <span class="comment">// TODO 对源 RDD 和参数 RDD 求并集后返回一个新的 RDD</span></span><br><span class="line">    <span class="comment">// TODO 求并集</span></span><br><span class="line">    <span class="keyword">val</span> rdd4 = rdd1.union(rdd2)</span><br><span class="line">    println(rdd4.collect().mkString(<span class="string">","</span>))</span><br><span class="line">    println(<span class="string">"========================"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 算子-subtract 差集 1,2</span></span><br><span class="line">    <span class="comment">// TODO 以一个 RDD 元素为主， 去除两个 RDD 中重复元素，将其他元素保留下来，求差集</span></span><br><span class="line">    <span class="keyword">val</span> rdd5 = rdd1.subtract(rdd2)</span><br><span class="line">    println(rdd5.collect().mkString(<span class="string">","</span>))</span><br><span class="line">    <span class="comment">// TODO 求差集</span></span><br><span class="line">    println(<span class="string">"========================"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 算子-zip 拉链 (1,3),(2,4),(3,5),(4,6)</span></span><br><span class="line">    <span class="comment">// TODO 将两个 RDD 中的元素，以键值对的形式进行合并。其中，键值对中的 Key 为第 1 个 RDD中的元素， Value 为第 2 个 RDD 中的相同位置的元素。</span></span><br><span class="line">    <span class="comment">// TODO 求拉链</span></span><br><span class="line">    <span class="keyword">val</span> rdd6 = rdd1.zip(rdd2)</span><br><span class="line">    <span class="comment">// 拉链两个数据类型可以不一致</span></span><br><span class="line">    <span class="keyword">val</span> rdd8 = rdd1.zip(rdd7)</span><br><span class="line">    println(rdd6.collect().mkString(<span class="string">","</span>))</span><br><span class="line">    println(rdd8.collect().mkString(<span class="string">","</span>))</span><br><span class="line">    sc.stop()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spark.core.rdd.operator.transform</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Spark13_RDD_Operator_Transform_Test</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">"local[*]"</span>).setAppName(<span class="string">"Operator"</span>)</span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(sparkConf)</span><br><span class="line">    <span class="comment">// TODO 算子-zip 拉链</span></span><br><span class="line">    <span class="comment">// TODO 分区数量和元素数量的不同对拉链算子的影响</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Error Can't zip RDDs with unequal numbers of partitions: List(2, 4)</span></span><br><span class="line">    <span class="comment">// 两个数据源要求分区数量保持一致</span></span><br><span class="line">    <span class="comment">// val rdd1 = sc.makeRDD(List(1,2,3,4),2)</span></span><br><span class="line">    <span class="comment">// val rdd2 = sc.makeRDD(List(3,4,5,6),4)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Error Can only zip RDDs with same number of elements in each partition</span></span><br><span class="line">    <span class="comment">// 两个数据源要求分区中数据数量保持一致</span></span><br><span class="line">    <span class="keyword">val</span> rdd1 = sc.makeRDD(<span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>), <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">val</span> rdd2 = sc.makeRDD(<span class="type">List</span>(<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>), <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> rdd3 = rdd1.zip(rdd2)</span><br><span class="line">    println(rdd3.collect().mkString(<span class="string">","</span>))</span><br><span class="line"></span><br><span class="line">    sc.stop()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="Key-Value-类型"><a href="#Key-Value-类型" class="headerlink" title="Key - Value 类型"></a>Key - Value 类型</h5><h6 id="partitionBy"><a href="#partitionBy" class="headerlink" title="partitionBy"></a>partitionBy</h6><ul>
<li><p>函数签名  </p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">partitionBy</span></span>(partitioner: <span class="type">Partitioner</span>): <span class="type">RDD</span>[(<span class="type">K</span>, <span class="type">V</span>)]</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数说明  </p>
<p>将数据按照指定 Partitioner 重新进行分区。 Spark 默认的分区器是 HashPartitioner  </p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> rdd: <span class="type">RDD</span>[(<span class="type">Int</span>, <span class="type">String</span>)] =sc.makeRDD(<span class="type">Array</span>((<span class="number">1</span>,<span class="string">"aaa"</span>),(<span class="number">2</span>,<span class="string">"bbb"</span>),(<span class="number">3</span>,<span class="string">"ccc"</span>)),<span class="number">3</span>)</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.<span class="type">HashPartitioner</span></span><br><span class="line"><span class="keyword">val</span> rdd2: <span class="type">RDD</span>[(<span class="type">Int</span>, <span class="type">String</span>)] =rdd.partitionBy(<span class="keyword">new</span> <span class="type">HashPartitioner</span>(<span class="number">2</span>))</span><br></pre></td></tr></table></figure>
</li>
<li><p>思考一个问题：如果重分区的分区器和当前 RDD 的分区器一样怎么办？</p>
</li>
<li><p>思考一个问题：Spark 还有其他分区器吗？</p>
</li>
<li><p>思考一个问题：如果想按照自己的方法进行数据分区怎么办？</p>
</li>
<li><p>思考一个问题：哪那么多问题？  </p>
</li>
<li><p>练习与测试</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spark.core.rdd.operator.transform</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.rdd.<span class="type">RDD</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">HashPartitioner</span>, <span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Spark14_RDD_Operator_Transform</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">"local[*]"</span>).setAppName(<span class="string">"Operator"</span>)</span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(sparkConf)</span><br><span class="line">    <span class="comment">// TODO 算子-Key-Value类型</span></span><br><span class="line">    <span class="comment">// TODO 算子-partitionBy</span></span><br><span class="line">    <span class="comment">// TODO 将数据按照指定 Partitioner 重新进行分区。Spark 默认的分区器是 HashPartitioner</span></span><br><span class="line">    <span class="comment">// TODO 自定义分区</span></span><br><span class="line">    <span class="keyword">val</span> rdd = sc.makeRDD(<span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>), <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">val</span> mapRDD: <span class="type">RDD</span>[(<span class="type">Int</span>, <span class="type">Int</span>)] = rdd.map((_, <span class="number">1</span>))</span><br><span class="line">    <span class="comment">// mapRDD.saveAsTextFile("output")</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 隐氏转换（二次编译），去执行了PairRDDFunctions隐氏方法</span></span><br><span class="line">    <span class="comment">// partitionBy方法根据指定的分区规则对数据进重分区(默认1,2在一个分区，3,4在一个分区)</span></span><br><span class="line">    <span class="keyword">val</span> newRDD = mapRDD.partitionBy(<span class="keyword">new</span> <span class="type">HashPartitioner</span>(<span class="number">2</span>))</span><br><span class="line">    newRDD.saveAsTextFile(<span class="string">"output"</span>)</span><br><span class="line"></span><br><span class="line">    sc.stop()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h6 id="reduceByKey"><a href="#reduceByKey" class="headerlink" title="reduceByKey"></a>reduceByKey</h6><ul>
<li><p>函数签名  </p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reduceByKey</span></span>(func: (<span class="type">V</span>, <span class="type">V</span>) =&gt; <span class="type">V</span>): <span class="type">RDD</span>[(<span class="type">K</span>, <span class="type">V</span>)]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reduceByKey</span></span>(func: (<span class="type">V</span>, <span class="type">V</span>) =&gt; <span class="type">V</span>, numPartitions: <span class="type">Int</span>): <span class="type">RDD</span>[(<span class="type">K</span>, <span class="type">V</span>)]</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数说明  </p>
<p>可以将数据按照相同的 Key 对 Value 进行聚合  </p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> dataRDD1 = sparkContext.makeRDD(<span class="type">List</span>((<span class="string">"a"</span>,<span class="number">1</span>),(<span class="string">"b"</span>,<span class="number">2</span>),(<span class="string">"c"</span>,<span class="number">3</span>)))</span><br><span class="line"><span class="keyword">val</span> dataRDD2 = dataRDD1.reduceByKey(_+_)</span><br><span class="line"><span class="keyword">val</span> dataRDD3 = dataRDD1.reduceByKey(_+_, <span class="number">2</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>小功能： WordCount  </p>
</li>
<li><p>练习与测试</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spark.core.rdd.operator.transform</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">HashPartitioner</span>, <span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Spark15_RDD_Operator_Transform</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">"local[*]"</span>).setAppName(<span class="string">"Operator"</span>)</span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(sparkConf)</span><br><span class="line">    <span class="comment">// TODO 算子-reduceByKey</span></span><br><span class="line">    <span class="comment">// TODO 可以将数据按照相同的 Key 对 Value 进行聚合</span></span><br><span class="line">    <span class="comment">// TODO 相同的key的数据进行value数据的聚合操作</span></span><br><span class="line">    <span class="comment">// scala语言中一般的聚合操作都是两两聚合，spark基于scala开发的，所以它的聚合也是两两聚合</span></span><br><span class="line">    <span class="comment">// reduceByKey中如果某个key的数据只有一个，是不会参加运算的</span></span><br><span class="line">    <span class="comment">// reduceByKey分区内和分区间的聚合计算规则是相同的</span></span><br><span class="line">    <span class="comment">// reduceByKey支持分区内预聚合功能，可以有效减少shuffle时落盘的数据量，提升shuffle的性能。</span></span><br><span class="line">    <span class="keyword">val</span> rdd = sc.makeRDD(<span class="type">List</span>((<span class="string">"a"</span>, <span class="number">1</span>), (<span class="string">"a"</span>, <span class="number">2</span>), (<span class="string">"a"</span>, <span class="number">3</span>), (<span class="string">"b"</span>, <span class="number">4</span>)))</span><br><span class="line">    <span class="keyword">val</span> rbRDD = rdd.reduceByKey(_ + _)</span><br><span class="line">    rbRDD.collect().foreach(println)</span><br><span class="line">    sc.stop()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h6 id="groupByKey"><a href="#groupByKey" class="headerlink" title="groupByKey"></a>groupByKey</h6><ul>
<li><p>函数签名  </p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">groupByKey</span></span>(): <span class="type">RDD</span>[(<span class="type">K</span>, <span class="type">Iterable</span>[<span class="type">V</span>])]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">groupByKey</span></span>(numPartitions: <span class="type">Int</span>): <span class="type">RDD</span>[(<span class="type">K</span>, <span class="type">Iterable</span>[<span class="type">V</span>])]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">groupByKey</span></span>(partitioner: <span class="type">Partitioner</span>): <span class="type">RDD</span>[(<span class="type">K</span>, <span class="type">Iterable</span>[<span class="type">V</span>])]</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数说明  </p>
<p>将数据源的数据根据 key 对 value 进行分组  </p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> dataRDD1 =sparkContext.makeRDD(<span class="type">List</span>((<span class="string">"a"</span>,<span class="number">1</span>),(<span class="string">"b"</span>,<span class="number">2</span>),(<span class="string">"c"</span>,<span class="number">3</span>)))</span><br><span class="line"><span class="keyword">val</span> dataRDD2 = dataRDD1.groupByKey()</span><br><span class="line"><span class="keyword">val</span> dataRDD3 = dataRDD1.groupByKey(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">val</span> dataRDD4 = dataRDD1.groupByKey(<span class="keyword">new</span> <span class="type">HashPartitioner</span>(<span class="number">2</span>))</span><br></pre></td></tr></table></figure>
</li>
<li><p>思考一个问题： reduceByKey 和 groupByKey 的区别？  </p>
<ol>
<li><p>从 shuffle 的角度： reduceByKey 和 groupByKey 都存在 shuffle 的操作，但是 reduceByKey可以在 shuffle 前对分区内相同 key 的数据进行预聚合（combine）功能，这样会减少落盘的数据量，而 groupByKey 只是进行分组，不存在数据量减少的问题， reduceByKey 性能比较高。</p>
</li>
<li><p>从功能的角度： reduceByKey 其实包含分组和聚合的功能。 GroupByKey 只能分组，不能聚合，所以在分组聚合的场合下，推荐使用 reduceByKey，如果仅仅是分组而不需要聚合。那么还是只能使用 groupByKey  </p>
</li>
<li><p>分析图</p>
<p><img src="/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230908144937569.png" alt="image-20230908144937569"></p>
<ul>
<li>groupByKey会导致数据打乱重组，存在shuffle操作</li>
<li>spark中，shuffle操作必须落盘处理，不能在内存中数据等待，会导致内存溢出。shuffle操作的性能非常低</li>
</ul>
<p><img src="/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230908145543991.png" alt="image-20230908145543991"></p>
<ul>
<li>reduceByKey支持分区内预聚合功能，可以有效减少shuffle时落盘的数据量，提升shuffle的性能。</li>
<li>reduceByKey分区内和分区间的聚合计算规则是相同的。</li>
</ul>
</li>
</ol>
</li>
<li><p>小功能： WordCount</p>
</li>
<li><p>练习与测试</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spark.core.rdd.operator.transform</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.rdd.<span class="type">RDD</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Spark16_RDD_Operator_Transform</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">"local[*]"</span>).setAppName(<span class="string">"Operator"</span>)</span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(sparkConf)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 算子-groupByKey</span></span><br><span class="line">    <span class="comment">// TODO 将数据源的数据根据 key 对 value 进行分组</span></span><br><span class="line">    <span class="comment">// TODO 数据分组</span></span><br><span class="line">    <span class="keyword">val</span> rdd = sc.makeRDD(<span class="type">List</span>((<span class="string">"a"</span>, <span class="number">1</span>), (<span class="string">"a"</span>, <span class="number">2</span>), (<span class="string">"a"</span>, <span class="number">3</span>), (<span class="string">"b"</span>, <span class="number">4</span>)))</span><br><span class="line">    <span class="comment">// groupByKey：将数据源中的数据，相同key的数据分在一个组中，形成一个对偶元组</span></span><br><span class="line">    <span class="comment">// 元组中的第一个元素就是key,元素中的第二个元素就是相同key的value的集合</span></span><br><span class="line">    <span class="comment">// groupByKey会导致数据打乱重组，存在shuffle操作</span></span><br><span class="line">    <span class="comment">// spark中，shuffle操作必须落盘处理，不能在内存中数据等待，会导致内存溢出。因此shuffle操作的性能非常低，因为和磁盘进行IO交互</span></span><br><span class="line">    <span class="keyword">val</span> groupRDD: <span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">Iterable</span>[<span class="type">Int</span>])] = rdd.groupByKey()</span><br><span class="line">    groupRDD.collect().foreach(println)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// groupBy：与上面不同的是将元素整体进行分组，不将value单独拿出来分组</span></span><br><span class="line">    <span class="keyword">val</span> groupRDD1: <span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">Iterable</span>[(<span class="type">String</span>, <span class="type">Int</span>)])] = rdd.groupBy(_._1)</span><br><span class="line">    groupRDD1.collect().foreach(println)</span><br><span class="line"></span><br><span class="line">    sc.stop()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h6 id="aggregateByKey"><a href="#aggregateByKey" class="headerlink" title="aggregateByKey"></a>aggregateByKey</h6><ul>
<li><p>函数签名  </p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">aggregateByKey</span></span>[<span class="type">U</span>: <span class="type">ClassTag</span>](zeroValue: <span class="type">U</span>)(seqOp: (<span class="type">U</span>, <span class="type">V</span>) =&gt; <span class="type">U</span>, combOp: (<span class="type">U</span>, <span class="type">U</span>) =&gt; <span class="type">U</span>): <span class="type">RDD</span>[(<span class="type">K</span>, <span class="type">U</span>)]</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数说明</p>
<p>将数据根据不同的规则进行分区内计算和分区间计算  </p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> dataRDD1 = sparkContext.makeRDD(<span class="type">List</span>((<span class="string">"a"</span>,<span class="number">1</span>),(<span class="string">"b"</span>,<span class="number">2</span>),(<span class="string">"c"</span>,<span class="number">3</span>)))</span><br><span class="line"><span class="keyword">val</span> dataRDD2 = dataRDD1.aggregateByKey(<span class="number">0</span>)(_+_,_+_)</span><br></pre></td></tr></table></figure>

<p>取出每个分区内相同 key 的最大值然后分区间相加  </p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// TODO : 取出每个分区内相同 key 的最大值然后分区间相加</span></span><br><span class="line"><span class="comment">// aggregateByKey 算子是函数柯里化，存在两个参数列表</span></span><br><span class="line"><span class="comment">// 1. 第一个参数列表中的参数表示初始值</span></span><br><span class="line"><span class="comment">// 2. 第二个参数列表中含有两个参数</span></span><br><span class="line"><span class="comment">// 2.1 第一个参数表示分区内的计算规则</span></span><br><span class="line"><span class="comment">// 2.2 第二个参数表示分区间的计算规则</span></span><br><span class="line"><span class="keyword">val</span> rdd =</span><br><span class="line">    sc.makeRDD(<span class="type">List</span>(</span><br><span class="line">    	(<span class="string">"a"</span>,<span class="number">1</span>),(<span class="string">"a"</span>,<span class="number">2</span>),(<span class="string">"c"</span>,<span class="number">3</span>),</span><br><span class="line">    	(<span class="string">"b"</span>,<span class="number">4</span>),(<span class="string">"c"</span>,<span class="number">5</span>),(<span class="string">"c"</span>,<span class="number">6</span>)</span><br><span class="line">    ),<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> resultRDD =</span><br><span class="line">    rdd.aggregateByKey(<span class="number">10</span>)(</span><br><span class="line">        (x, y) =&gt; math.max(x,y),</span><br><span class="line">        (x, y) =&gt; x + y</span><br><span class="line">    )</span><br><span class="line">resultRDD.collect().foreach(println)</span><br></pre></td></tr></table></figure>
</li>
<li><p>图示分析</p>
<p><img src="/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230912162533020.png" alt="image-20230912162533020"></p>
</li>
<li><p>思考一个问题：分区内计算规则和分区间计算规则相同怎么办？（WordCount）</p>
</li>
<li><p>练习与测试</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spark.core.rdd.operator.transform</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Spark17_RDD_Operator_Transform</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">"local[*]"</span>).setAppName(<span class="string">"Operator"</span>)</span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(sparkConf)</span><br><span class="line">    <span class="comment">// TODO 算子-aggregateByKey</span></span><br><span class="line">    <span class="comment">// TODO 将数据根据不同的规则进行分区内计算和分区间计算</span></span><br><span class="line">    <span class="comment">// TODO 计算不同分区的最大值之和</span></span><br><span class="line">    <span class="keyword">val</span> rdd = sc.makeRDD(<span class="type">List</span>((<span class="string">"a"</span>, <span class="number">1</span>), (<span class="string">"a"</span>, <span class="number">2</span>), (<span class="string">"a"</span>, <span class="number">3</span>), (<span class="string">"a"</span>, <span class="number">4</span>)), <span class="number">2</span>)</span><br><span class="line">    <span class="comment">// (a, [1,2]),(a, [3,4])</span></span><br><span class="line">    <span class="comment">// (a, 2),(a, 4)</span></span><br><span class="line">    <span class="comment">// (a, 6)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// aggregateByKey存在函数的柯里化，有两个参数列表</span></span><br><span class="line">    <span class="comment">// 第一个参数列表：需要传递一个参数，表示为初始值，作用是：当碰见第一个key的时候和value进行分区内计算</span></span><br><span class="line">    <span class="comment">// 第二个参数列表需要传递两个参数：1. 分区内计算规则 2. 分区间计算规则</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> abRDD = rdd.aggregateByKey(<span class="number">0</span>)(</span><br><span class="line">      (x, y) =&gt; math.max(x, y), <span class="comment">// 分区间计算规则</span></span><br><span class="line">      (x, y) =&gt; x + y <span class="comment">// 分区内计算规则</span></span><br><span class="line">    )</span><br><span class="line">    abRDD.collect().foreach(println)</span><br><span class="line">    sc.stop()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spark.core.rdd.operator.transform</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Spark17_RDD_Operator_Transform_Test</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">"local[*]"</span>).setAppName(<span class="string">"Operator"</span>)</span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(sparkConf)</span><br><span class="line">    <span class="comment">// TODO 算子-aggregateByKey</span></span><br><span class="line">    <span class="comment">// TODO 计算不同分区的最大值之和</span></span><br><span class="line">    <span class="keyword">val</span> rdd = sc.makeRDD(<span class="type">List</span>(</span><br><span class="line">      (<span class="string">"a"</span>, <span class="number">1</span>), (<span class="string">"a"</span>, <span class="number">2</span>), (<span class="string">"b"</span>, <span class="number">3</span>),</span><br><span class="line">      (<span class="string">"b"</span>, <span class="number">4</span>), (<span class="string">"b"</span>, <span class="number">5</span>), (<span class="string">"a"</span>, <span class="number">6</span>)</span><br><span class="line">    ), <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// val abRDD = rdd.aggregateByKey(5)(</span></span><br><span class="line">    <span class="comment">//   (x, y) =&gt; math.max(x, y), // 分区间计算规则</span></span><br><span class="line">    <span class="comment">//   (x, y) =&gt; x + y // 分区内计算规则</span></span><br><span class="line">    <span class="comment">// )</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 简化</span></span><br><span class="line">    <span class="keyword">val</span> abRDD = rdd.aggregateByKey(<span class="number">5</span>)(math.max, _ + _)</span><br><span class="line">    abRDD.collect().foreach(println)</span><br><span class="line">    sc.stop()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spark.core.rdd.operator.transform</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.rdd.<span class="type">RDD</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Spark18_RDD_Operator_Transform</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">"local[*]"</span>).setAppName(<span class="string">"Operator"</span>)</span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(sparkConf)</span><br><span class="line">    <span class="comment">// TODO 算子-aggregateByKey</span></span><br><span class="line">    <span class="comment">// TODO 获取相同key的数据的平均值</span></span><br><span class="line">    <span class="keyword">val</span> rdd = sc.makeRDD(<span class="type">List</span>(</span><br><span class="line">      (<span class="string">"a"</span>, <span class="number">1</span>), (<span class="string">"a"</span>, <span class="number">2</span>), (<span class="string">"b"</span>, <span class="number">3</span>),</span><br><span class="line">      (<span class="string">"b"</span>, <span class="number">4</span>), (<span class="string">"b"</span>, <span class="number">5</span>), (<span class="string">"a"</span>, <span class="number">6</span>)</span><br><span class="line">    ), <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// aggregateByKey最终的返回数据结果应该和初始值的类型保持一致</span></span><br><span class="line">    <span class="comment">// def aggregateByKey[U: ClassTag](zeroValue: U, partitioner: Partitioner)(seqOp: (U, V) =&gt; U, combOp: (U, U) =&gt; U): RDD[(K, U)] = self.withScope &#123; ... &#125;</span></span><br><span class="line">    <span class="comment">// val abRDD: RDD[(String, String)] = rdd.aggregateByKey("")(_ + _, _ + _)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> newRDD: <span class="type">RDD</span>[(<span class="type">String</span>, (<span class="type">Int</span>, <span class="type">Int</span>))] = rdd.aggregateByKey((<span class="number">0</span>, <span class="number">0</span>))(</span><br><span class="line">      (t, v) =&gt; &#123;</span><br><span class="line">        (t._1 + v, t._2 + <span class="number">1</span>)</span><br><span class="line">      &#125;,</span><br><span class="line">      (t1, t2) =&gt; &#123;</span><br><span class="line">        (t1._1 + t2._1, t1._2 + t2._2)</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    newRDD.mapValues &#123;</span><br><span class="line">      <span class="keyword">case</span> (num, count) =&gt; num / count</span><br><span class="line">    &#125;.collect().foreach(println)</span><br><span class="line"></span><br><span class="line">    sc.stop()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h6 id="foldByKey"><a href="#foldByKey" class="headerlink" title="foldByKey"></a>foldByKey</h6><ul>
<li><p>函数签名  </p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foldByKey</span></span>(zeroValue: <span class="type">V</span>)(func: (<span class="type">V</span>, <span class="type">V</span>) =&gt; <span class="type">V</span>): <span class="type">RDD</span>[(<span class="type">K</span>, <span class="type">V</span>)]</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数说明  </p>
<p>当分区内计算规则和分区间计算规则相同时， aggregateByKey 就可以简化为 foldByKey  </p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> dataRDD1 = sparkContext.makeRDD(<span class="type">List</span>((<span class="string">"a"</span>,<span class="number">1</span>),(<span class="string">"b"</span>,<span class="number">2</span>),(<span class="string">"c"</span>,<span class="number">3</span>)))</span><br><span class="line"><span class="keyword">val</span> dataRDD2 = dataRDD1.foldByKey(<span class="number">0</span>)(_+_)</span><br></pre></td></tr></table></figure>
</li>
<li><p>练习与测试</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spark.core.rdd.operator.transform</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Spark17_RDD_Operator_Transform_Test1</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">"local[*]"</span>).setAppName(<span class="string">"Operator"</span>)</span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(sparkConf)</span><br><span class="line">    <span class="comment">// TODO 算子-foldByKey</span></span><br><span class="line">    <span class="comment">// TODO 当分区内计算规则和分区间计算规则相同时，aggregateByKey 就可以简化为 foldByKey</span></span><br><span class="line">    <span class="comment">// TODO 计算不同分区的最大值之和</span></span><br><span class="line">    <span class="keyword">val</span> rdd = sc.makeRDD(<span class="type">List</span>(</span><br><span class="line">      (<span class="string">"a"</span>, <span class="number">1</span>), (<span class="string">"a"</span>, <span class="number">2</span>), (<span class="string">"b"</span>, <span class="number">3</span>),</span><br><span class="line">      (<span class="string">"b"</span>, <span class="number">4</span>), (<span class="string">"b"</span>, <span class="number">5</span>), (<span class="string">"a"</span>, <span class="number">6</span>)</span><br><span class="line">    ), <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 简化</span></span><br><span class="line">    rdd.aggregateByKey(<span class="number">5</span>)(math.max, _ + _).collect().foreach(println)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果聚合计算时，分区内核分区间计算规则相同，spark提供了简化的方法</span></span><br><span class="line">    rdd.foldByKey(<span class="number">0</span>)(_+_).collect().foreach(println)</span><br><span class="line"></span><br><span class="line">    sc.stop()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h6 id="combineByKey"><a href="#combineByKey" class="headerlink" title="combineByKey"></a>combineByKey</h6><ul>
<li><p>函数签名  </p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">combineByKey</span></span>[<span class="type">C</span>](</span><br><span class="line">createCombiner: <span class="type">V</span> =&gt; <span class="type">C</span>,</span><br><span class="line">mergeValue: (<span class="type">C</span>, <span class="type">V</span>) =&gt; <span class="type">C</span>,</span><br><span class="line">mergeCombiners: (<span class="type">C</span>, <span class="type">C</span>) =&gt; <span class="type">C</span>): <span class="type">RDD</span>[(<span class="type">K</span>, <span class="type">C</span>)]</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数说明  </p>
<p>最通用的对 key-value 型 rdd 进行聚集操作的聚集函数（aggregation function）。类似于 aggregate()， combineByKey()允许用户返回值的类型与输入不一致。</p>
</li>
<li><p>图示分析</p>
<p><img src="/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230912162819586.png" alt="image-20230912162819586"></p>
</li>
<li><p>小练习：将数据 List((“a”, 88), (“b”, 95), (“a”, 91), (“b”, 93), (“a”, 95), (“b”, 98))求每个 key 的平均值  </p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list: <span class="type">List</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = <span class="type">List</span>((<span class="string">"a"</span>, <span class="number">88</span>), (<span class="string">"b"</span>, <span class="number">95</span>), (<span class="string">"a"</span>, <span class="number">91</span>), (<span class="string">"b"</span>, <span class="number">93</span>), (<span class="string">"a"</span>, <span class="number">95</span>), (<span class="string">"b"</span>, <span class="number">98</span>))</span><br><span class="line"><span class="keyword">val</span> input: <span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = sc.makeRDD(list, <span class="number">2</span>)</span><br><span class="line"><span class="keyword">val</span> combineRdd: <span class="type">RDD</span>[(<span class="type">String</span>, (<span class="type">Int</span>, <span class="type">Int</span>))] = input.combineByKey(</span><br><span class="line">    (_, <span class="number">1</span>),</span><br><span class="line">    (acc: (<span class="type">Int</span>, <span class="type">Int</span>), v) =&gt; (acc._1 + v, acc._2 + <span class="number">1</span>),</span><br><span class="line">    (acc1: (<span class="type">Int</span>, <span class="type">Int</span>), acc2: (<span class="type">Int</span>, <span class="type">Int</span>)) =&gt; (acc1._1 + acc2._1, acc1._2 + acc2._2)</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
</li>
<li><p>思考一个问题： reduceByKey、 foldByKey、 aggregateByKey、 combineByKey 的区别？</p>
<ol>
<li><p>reduceByKey: 相同 key 的第一个数据不进行任何计算，分区内和分区间计算规则相同</p>
</li>
<li><p>FoldByKey: 相同 key 的第一个数据和初始值进行分区内计算，分区内和分区间计算规则相同  </p>
</li>
<li><p>AggregateByKey：相同 key 的第一个数据和初始值进行分区内计算，分区内和分区间计算规则可以不相同</p>
</li>
<li><p>CombineByKey:当计算时，发现数据结构不满足要求时，可以让第一个数据转换结构。分区内和分区间计算规则不相同</p>
</li>
</ol>
</li>
<li><p>练习与测试</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spark.core.rdd.operator.transform</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.rdd.<span class="type">RDD</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Spark19_RDD_Operator_Transform</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">"local[*]"</span>).setAppName(<span class="string">"Operator"</span>)</span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(sparkConf)</span><br><span class="line">    <span class="comment">// TODO 算子-combineByKey</span></span><br><span class="line">    <span class="comment">// TODO 最通用的对 key-value 型 rdd 进行聚集操作的聚集函数（aggregation function）。类似于aggregate()，combineByKey()允许用户返回值的类型与输入不一致。</span></span><br><span class="line">    <span class="comment">// TODO 获取相同key的数据的平均值</span></span><br><span class="line">    <span class="keyword">val</span> rdd = sc.makeRDD(<span class="type">List</span>(</span><br><span class="line">      (<span class="string">"a"</span>, <span class="number">1</span>), (<span class="string">"a"</span>, <span class="number">2</span>), (<span class="string">"b"</span>, <span class="number">3</span>),</span><br><span class="line">      (<span class="string">"b"</span>, <span class="number">4</span>), (<span class="string">"b"</span>, <span class="number">5</span>), (<span class="string">"a"</span>, <span class="number">6</span>)</span><br><span class="line">    ), <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// combineByKey：方法需要三个参数</span></span><br><span class="line">    <span class="comment">// 第一个参数表示：将相同key的第一个value值进行结构的转换，实现操作</span></span><br><span class="line">    <span class="comment">// 第二个参数表示：分区内的计算规则</span></span><br><span class="line">    <span class="comment">// 第三个参数表示：分区间的计算规则</span></span><br><span class="line">    <span class="keyword">val</span> newRDD: <span class="type">RDD</span>[(<span class="type">String</span>, (<span class="type">Int</span>, <span class="type">Int</span>))] = rdd.combineByKey(</span><br><span class="line">      v =&gt; (v, <span class="number">1</span>),</span><br><span class="line">      (t: (<span class="type">Int</span>, <span class="type">Int</span>), v) =&gt; &#123;</span><br><span class="line">        (t._1 + v, t._2 + <span class="number">1</span>)</span><br><span class="line">      &#125;,</span><br><span class="line">      (t1: (<span class="type">Int</span>, <span class="type">Int</span>), t2: (<span class="type">Int</span>, <span class="type">Int</span>)) =&gt; &#123;</span><br><span class="line">        (t1._1 + t2._1, t1._2 + t2._2)</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> avgRDD = newRDD.mapValues &#123;</span><br><span class="line">      <span class="keyword">case</span> (num, count) =&gt; num / count</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    avgRDD.collect().foreach(println)</span><br><span class="line">    sc.stop()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spark.core.rdd.operator.transform</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Spark20_RDD_Operator_Transform</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">"local[*]"</span>).setAppName(<span class="string">"Operator"</span>)</span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(sparkConf)</span><br><span class="line">    <span class="comment">// TODO 算子-reduceByKey、aggregateByKey、foldByKey、combineByKey 底层源码和实现原理比较分析</span></span><br><span class="line">    <span class="keyword">val</span> rdd = sc.makeRDD(<span class="type">List</span>(</span><br><span class="line">      (<span class="string">"a"</span>, <span class="number">1</span>), (<span class="string">"a"</span>, <span class="number">2</span>), (<span class="string">"b"</span>, <span class="number">3</span>),</span><br><span class="line">      (<span class="string">"b"</span>, <span class="number">4</span>), (<span class="string">"b"</span>, <span class="number">5</span>), (<span class="string">"a"</span>, <span class="number">6</span>)</span><br><span class="line">    ), <span class="number">2</span>)</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        reduceByKey:</span></span><br><span class="line"><span class="comment">             combineByKeyWithClassTag[V](</span></span><br><span class="line"><span class="comment">                 (v: V) =&gt; v, // 第一个值不会参与计算</span></span><br><span class="line"><span class="comment">                 func, // 分区内计算规则</span></span><br><span class="line"><span class="comment">                 func, // 分区间计算规则</span></span><br><span class="line"><span class="comment">             )</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        aggregateByKey :</span></span><br><span class="line"><span class="comment">            combineByKeyWithClassTag[U](</span></span><br><span class="line"><span class="comment">                (v: V) =&gt; cleanedSeqOp(createZero(), v), // 初始值和第一个key的value值进行的分区内数据操作</span></span><br><span class="line"><span class="comment">                cleanedSeqOp, // 分区内计算规则</span></span><br><span class="line"><span class="comment">                combOp,       // 分区间计算规则</span></span><br><span class="line"><span class="comment">            )</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        foldByKey:</span></span><br><span class="line"><span class="comment">            combineByKeyWithClassTag[V](</span></span><br><span class="line"><span class="comment">                (v: V) =&gt; cleanedFunc(createZero(), v), // 初始值和第一个key的value值进行的分区内数据操作</span></span><br><span class="line"><span class="comment">                cleanedFunc,  // 分区内计算规则</span></span><br><span class="line"><span class="comment">                cleanedFunc,  // 分区间计算规则</span></span><br><span class="line"><span class="comment">            )</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">        combineByKey :</span></span><br><span class="line"><span class="comment">            combineByKeyWithClassTag(</span></span><br><span class="line"><span class="comment">                createCombiner,  // 相同key的第一条数据进行的处理函数</span></span><br><span class="line"><span class="comment">                mergeValue,      // 表示分区内数据的处理函数</span></span><br><span class="line"><span class="comment">                mergeCombiners,  // 表示分区间数据的处理函数</span></span><br><span class="line"><span class="comment">            )</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    rdd.reduceByKey(_ + _) <span class="comment">// wordcount</span></span><br><span class="line">    rdd.aggregateByKey(<span class="number">0</span>)(_ + _, _ + _) <span class="comment">// wordcount</span></span><br><span class="line">    rdd.foldByKey(<span class="number">0</span>)(_ + _) <span class="comment">// wordcount</span></span><br><span class="line">    rdd.combineByKey(v =&gt; v, (x: <span class="type">Int</span>, y) =&gt; x + y, (x: <span class="type">Int</span>, y: <span class="type">Int</span>) =&gt; x + y) <span class="comment">// wordcount</span></span><br><span class="line"></span><br><span class="line">    sc.stop()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h6 id="sortByKey"><a href="#sortByKey" class="headerlink" title="sortByKey"></a>sortByKey</h6><ul>
<li><p>函数签名  </p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sortByKey</span></span>(ascending: <span class="type">Boolean</span> = <span class="literal">true</span>, numPartitions: <span class="type">Int</span> = self.partitions.length): <span class="type">RDD</span>[(<span class="type">K</span>, <span class="type">V</span>)]</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数说明  </p>
<p>在一个(K,V)的 RDD 上调用， K 必须实现 Ordered 接口(特质)，返回一个按照 key 进行排序的</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> dataRDD1 = sparkContext.makeRDD(<span class="type">List</span>((<span class="string">"a"</span>,<span class="number">1</span>),(<span class="string">"b"</span>,<span class="number">2</span>),(<span class="string">"c"</span>,<span class="number">3</span>)))</span><br><span class="line"><span class="keyword">val</span> sortRDD1: <span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = dataRDD1.sortByKey(<span class="literal">true</span>)</span><br><span class="line"><span class="keyword">val</span> sortRDD1: <span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = dataRDD1.sortByKey(<span class="literal">false</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>小功能：设置 key 为自定义类 User</p>
</li>
<li><p>练习与测试</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spark.core.rdd.operator.transform</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.rdd.<span class="type">RDD</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Spark20_RDD_Operator_Transform_After</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">"local[*]"</span>).setAppName(<span class="string">"Operator"</span>)</span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(sparkConf)</span><br><span class="line">    <span class="comment">// TODO 算子-sortByKey</span></span><br><span class="line">    <span class="comment">// TODO 在一个(K,V)的 RDD 上调用， K 必须实现 Ordered 接口(特质)，返回一个按照 key 进行排序的</span></span><br><span class="line">    <span class="comment">// TODO 根据key排序</span></span><br><span class="line">    <span class="keyword">val</span> rdd = sc.makeRDD(<span class="type">List</span>(</span><br><span class="line">      (<span class="string">"a"</span>, <span class="number">3</span>), (<span class="string">"b"</span>, <span class="number">1</span>), (<span class="string">"c"</span>, <span class="number">2</span>)</span><br><span class="line">    ))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> sortRDD1: <span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = rdd.sortByKey(<span class="literal">true</span>)</span><br><span class="line">    <span class="keyword">val</span> sortRDD2: <span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = rdd.sortByKey(<span class="literal">false</span>)</span><br><span class="line"></span><br><span class="line">    sortRDD1.collect().foreach(println)</span><br><span class="line">    println(<span class="string">"=================="</span>)</span><br><span class="line"></span><br><span class="line">    sortRDD2.collect().foreach(println)</span><br><span class="line"></span><br><span class="line">    sc.stop()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h6 id="join"><a href="#join" class="headerlink" title="join"></a>join</h6><ul>
<li><p>函数签名  </p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">join</span></span>[<span class="type">W</span>](other: <span class="type">RDD</span>[(<span class="type">K</span>, <span class="type">W</span>)]): <span class="type">RDD</span>[(<span class="type">K</span>, (<span class="type">V</span>, <span class="type">W</span>))]</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数说明  </p>
<p>在类型为(K,V)和(K,W)的 RDD 上调用，返回一个相同 key 对应的所有元素连接在一起的(K,(V,W))的 RDD</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> rdd: <span class="type">RDD</span>[(<span class="type">Int</span>, <span class="type">String</span>)] = sc.makeRDD(<span class="type">Array</span>((<span class="number">1</span>, <span class="string">"a"</span>), (<span class="number">2</span>, <span class="string">"b"</span>), (<span class="number">3</span>, <span class="string">"c"</span>)))</span><br><span class="line"><span class="keyword">val</span> rdd1: <span class="type">RDD</span>[(<span class="type">Int</span>, <span class="type">Int</span>)] = sc.makeRDD(<span class="type">Array</span>((<span class="number">1</span>, <span class="number">4</span>), (<span class="number">2</span>, <span class="number">5</span>), (<span class="number">3</span>, <span class="number">6</span>)))</span><br><span class="line">rdd.join(rdd1).collect().foreach(println)</span><br></pre></td></tr></table></figure>
</li>
<li><p>思考一个问题：如果 key 存在不相等呢？</p>
</li>
<li><p>练习与测试</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spark.core.rdd.operator.transform</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.rdd.<span class="type">RDD</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Spark21_RDD_Operator_Transform</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">"local[*]"</span>).setAppName(<span class="string">"Operator"</span>)</span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(sparkConf)</span><br><span class="line">    <span class="comment">// TODO 算子-join</span></span><br><span class="line">    <span class="comment">// TODO 在类型为(K,V)和(K,W)的 RDD 上调用，返回一个相同 key 对应的所有元素连接在一起的(K,(V,W))的 RDD</span></span><br><span class="line">    <span class="comment">// TODO RDD之间的join连接（相当于内连接）</span></span><br><span class="line">    <span class="keyword">val</span> rdd1 = sc.makeRDD(<span class="type">List</span>(</span><br><span class="line">      (<span class="string">"a"</span>, <span class="number">1</span>), (<span class="string">"b"</span>, <span class="number">2</span>), (<span class="string">"c"</span>, <span class="number">3</span>)</span><br><span class="line">    ))</span><br><span class="line">    <span class="keyword">val</span> rdd2 = sc.makeRDD(<span class="type">List</span>(</span><br><span class="line">      (<span class="string">"a"</span>, <span class="number">4</span>), (<span class="string">"b"</span>, <span class="number">5</span>), (<span class="string">"c"</span>, <span class="number">6</span>)</span><br><span class="line">    ))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> rdd3 = sc.makeRDD(<span class="type">List</span>(</span><br><span class="line">      (<span class="string">"b"</span>, <span class="number">5</span>), (<span class="string">"c"</span>, <span class="number">6</span>), (<span class="string">"a"</span>, <span class="number">4</span>)</span><br><span class="line">    ))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> rdd4 = sc.makeRDD(<span class="type">List</span>(</span><br><span class="line">      (<span class="string">"d"</span>, <span class="number">5</span>), (<span class="string">"c"</span>, <span class="number">6</span>), (<span class="string">"a"</span>, <span class="number">4</span>)</span><br><span class="line">    ))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> rdd5 = sc.makeRDD(<span class="type">List</span>(</span><br><span class="line">      (<span class="string">"a"</span>, <span class="number">5</span>), (<span class="string">"c"</span>, <span class="number">6</span>), (<span class="string">"a"</span>, <span class="number">4</span>)</span><br><span class="line">    ))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> joinRDD: <span class="type">RDD</span>[(<span class="type">String</span>, (<span class="type">Int</span>, <span class="type">Int</span>))] = rdd1.join(rdd2)</span><br><span class="line">    joinRDD.collect().foreach(println)</span><br><span class="line">    println(<span class="string">"================"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 不同与拉链表，这里是根据相同的key两个数据源进行join组合在一起形成元组</span></span><br><span class="line">    <span class="keyword">val</span> joinRDD1: <span class="type">RDD</span>[(<span class="type">String</span>, (<span class="type">Int</span>, <span class="type">Int</span>))] = rdd1.join(rdd3)</span><br><span class="line">    joinRDD1.collect().foreach(println)</span><br><span class="line">    println(<span class="string">"================"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果两个数据源中key没有匹配上，那么数据不会出现在结果中</span></span><br><span class="line">    <span class="keyword">val</span> joinRDD2: <span class="type">RDD</span>[(<span class="type">String</span>, (<span class="type">Int</span>, <span class="type">Int</span>))] = rdd1.join(rdd4)</span><br><span class="line">    joinRDD2.collect().foreach(println)</span><br><span class="line">    println(<span class="string">"================"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果两个数据源中key有多个相同的，会依次匹配，可能会出现笛卡尔乘积，数据量会几何性增长，导致性能降低</span></span><br><span class="line">    <span class="keyword">val</span> joinRDD3: <span class="type">RDD</span>[(<span class="type">String</span>, (<span class="type">Int</span>, <span class="type">Int</span>))] = rdd1.join(rdd5)</span><br><span class="line">    joinRDD3.collect().foreach(println)</span><br><span class="line"></span><br><span class="line">    sc.stop()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h6 id="leftOuterJoin"><a href="#leftOuterJoin" class="headerlink" title="leftOuterJoin"></a>leftOuterJoin</h6><ul>
<li><p>函数签名  </p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">leftOuterJoin</span></span>[<span class="type">W</span>](other: <span class="type">RDD</span>[(<span class="type">K</span>, <span class="type">W</span>)]): <span class="type">RDD</span>[(<span class="type">K</span>, (<span class="type">V</span>, <span class="type">Option</span>[<span class="type">W</span>]))]</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数说明  </p>
<p>类似于 SQL 语句的左外连接  </p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> dataRDD1 = sparkContext.makeRDD(<span class="type">List</span>((<span class="string">"a"</span>,<span class="number">1</span>),(<span class="string">"b"</span>,<span class="number">2</span>),(<span class="string">"c"</span>,<span class="number">3</span>)))</span><br><span class="line"><span class="keyword">val</span> dataRDD2 = sparkContext.makeRDD(<span class="type">List</span>((<span class="string">"a"</span>,<span class="number">1</span>),(<span class="string">"b"</span>,<span class="number">2</span>),(<span class="string">"c"</span>,<span class="number">3</span>)))</span><br><span class="line"><span class="keyword">val</span> rdd: <span class="type">RDD</span>[(<span class="type">String</span>, (<span class="type">Int</span>, <span class="type">Option</span>[<span class="type">Int</span>]))] = dataRDD1.leftOuterJoin(dataRDD2)</span><br></pre></td></tr></table></figure>
</li>
<li><p>练习与测试</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spark.core.rdd.operator.transform</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.rdd.<span class="type">RDD</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Spark22_RDD_Operator_Transform</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">"local[*]"</span>).setAppName(<span class="string">"Operator"</span>)</span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(sparkConf)</span><br><span class="line">    <span class="comment">// TODO 算子-leftOuterJoin-rightOuterJoin</span></span><br><span class="line">    <span class="comment">// TODO 类似于 SQL 语句的左外连接</span></span><br><span class="line">    <span class="comment">// TODO RDD之间的join连接（左连接）</span></span><br><span class="line">    <span class="keyword">val</span> rdd1 = sc.makeRDD(<span class="type">List</span>(</span><br><span class="line">      (<span class="string">"a"</span>, <span class="number">1</span>), (<span class="string">"b"</span>, <span class="number">2</span>), (<span class="string">"c"</span>, <span class="number">3</span>)</span><br><span class="line">    ))</span><br><span class="line">    <span class="keyword">val</span> rdd2 = sc.makeRDD(<span class="type">List</span>(</span><br><span class="line">      (<span class="string">"a"</span>, <span class="number">4</span>),(<span class="string">"a"</span>, <span class="number">5</span>), (<span class="string">"b"</span>, <span class="number">6</span>)</span><br><span class="line">    ))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> leftJoinRDD: <span class="type">RDD</span>[(<span class="type">String</span>, (<span class="type">Int</span>, <span class="type">Option</span>[<span class="type">Int</span>]))] = rdd1.leftOuterJoin(rdd2)</span><br><span class="line">    leftJoinRDD.collect().foreach(println)</span><br><span class="line">    println(<span class="string">"========================="</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> rightJoinRDD: <span class="type">RDD</span>[(<span class="type">String</span>, (<span class="type">Option</span>[<span class="type">Int</span>], <span class="type">Int</span>))] = rdd2.rightOuterJoin(rdd1)</span><br><span class="line">    rightJoinRDD.collect().foreach(println)</span><br><span class="line">    sc.stop()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h6 id="cogroup"><a href="#cogroup" class="headerlink" title="cogroup"></a>cogroup</h6><ul>
<li><p>函数签名  </p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cogroup</span></span>[<span class="type">W</span>](other: <span class="type">RDD</span>[(<span class="type">K</span>, <span class="type">W</span>)]): <span class="type">RDD</span>[(<span class="type">K</span>, (<span class="type">Iterable</span>[<span class="type">V</span>], <span class="type">Iterable</span>[<span class="type">W</span>]))]</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数说明</p>
<p>在类型为(K,V)和(K,W)的 RDD 上调用，返回一个(K,(Iterable<V>,Iterable<W>))类型的 RDD  </W></V></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> dataRDD1 = sparkContext.makeRDD(<span class="type">List</span>((<span class="string">"a"</span>,<span class="number">1</span>),(<span class="string">"a"</span>,<span class="number">2</span>),(<span class="string">"c"</span>,<span class="number">3</span>)))</span><br><span class="line"><span class="keyword">val</span> dataRDD2 = sparkContext.makeRDD(<span class="type">List</span>((<span class="string">"a"</span>,<span class="number">1</span>),(<span class="string">"c"</span>,<span class="number">2</span>),(<span class="string">"c"</span>,<span class="number">3</span>)))</span><br><span class="line"><span class="keyword">val</span> value: <span class="type">RDD</span>[(<span class="type">String</span>, (<span class="type">Iterable</span>[<span class="type">Int</span>], <span class="type">Iterable</span>[<span class="type">Int</span>]))] =</span><br><span class="line">dataRDD1.cogroup(dataRDD2)</span><br></pre></td></tr></table></figure>
</li>
<li><p>练习与测试</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spark.core.rdd.operator.transform</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.rdd.<span class="type">RDD</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Spark23_RDD_Operator_Transform</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">"local[*]"</span>).setAppName(<span class="string">"Operator"</span>)</span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(sparkConf)</span><br><span class="line">    <span class="comment">// TODO 算子-cogroup</span></span><br><span class="line">    <span class="comment">// TODO 在类型为(K,V)和(K,W)的 RDD 上调用，返回一个(K,(Iterable&lt;V&gt;,Iterable&lt;W&gt;))类型的 RDD</span></span><br><span class="line">    <span class="comment">// TODO 连接分组算子数据展示</span></span><br><span class="line">    <span class="keyword">val</span> rdd1 = sc.makeRDD(<span class="type">List</span>(</span><br><span class="line">      (<span class="string">"a"</span>, <span class="number">1</span>), (<span class="string">"b"</span>, <span class="number">2</span>)</span><br><span class="line">    ))</span><br><span class="line">    <span class="keyword">val</span> rdd2 = sc.makeRDD(<span class="type">List</span>(</span><br><span class="line">      (<span class="string">"a"</span>, <span class="number">4</span>), (<span class="string">"b"</span>, <span class="number">5</span>), (<span class="string">"c"</span>, <span class="number">6</span>)</span><br><span class="line">    ))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> rdd3 = sc.makeRDD(<span class="type">List</span>(</span><br><span class="line">      (<span class="string">"a"</span>, <span class="number">4</span>), (<span class="string">"a"</span>, <span class="number">5</span>), (<span class="string">"c"</span>, <span class="number">6</span>)</span><br><span class="line">    ))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> cgRDD: <span class="type">RDD</span>[(<span class="type">String</span>, (<span class="type">Iterable</span>[<span class="type">Int</span>], <span class="type">Iterable</span>[<span class="type">Int</span>]))] = rdd1.cogroup(rdd2)</span><br><span class="line">    cgRDD.collect().foreach(println)</span><br><span class="line">    println(<span class="string">"======================"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> cgRDD1: <span class="type">RDD</span>[(<span class="type">String</span>, (<span class="type">Iterable</span>[<span class="type">Int</span>], <span class="type">Iterable</span>[<span class="type">Int</span>]))] = rdd1.cogroup(rdd3)</span><br><span class="line">    cgRDD1.collect().foreach(println)</span><br><span class="line">    println(<span class="string">"======================"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> cgRDD2: <span class="type">RDD</span>[(<span class="type">String</span>, (<span class="type">Iterable</span>[<span class="type">Int</span>], <span class="type">Iterable</span>[<span class="type">Int</span>], <span class="type">Iterable</span>[<span class="type">Int</span>]))] = rdd1.cogroup(rdd2, rdd3)</span><br><span class="line">    cgRDD2.collect().foreach(println)</span><br><span class="line">    sc.stop()</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="5-1-4-4-案例实操"><a href="#5-1-4-4-案例实操" class="headerlink" title="5.1.4.4 案例实操"></a>5.1.4.4 案例实操</h4><p>1) 数据准备</p>
<p>   agent.log：时间戳，省份，城市，用户，广告，中间字段使用空格分隔。</p>
<p>2) 需求描述</p>
<p>   统计出每一个省份每个广告被点击数量排行的 Top3</p>
<p>3) 需求分析</p>
<p>   <img src="/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230912163455261.png" alt="image-20230912163455261"></p>
<p>4) 功能实现</p>
<p>5) 练习与测试</p>
   <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spark.core.rdd.operator.transform</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.rdd.<span class="type">RDD</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Spark24_RDD_Req</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">"local[*]"</span>).setAppName(<span class="string">"Operator"</span>)</span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(sparkConf)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 案例实操-agent.log：时间戳，省份，城市，用户，广告，中间字段使用空格分隔。</span></span><br><span class="line">    <span class="comment">// TODO 统计出每一个省份每个广告被点击数量排行的 Top3</span></span><br><span class="line">    <span class="comment">// 1. 获取原始数据</span></span><br><span class="line">    <span class="comment">// 时间戳 省份 城市 用户 广告</span></span><br><span class="line">    <span class="keyword">val</span> dataRDD = sc.textFile(<span class="string">"datas/agent.log"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 将原始数据进行结构的转换，方便统计</span></span><br><span class="line">    <span class="comment">// 时间戳 省份 城市 用户 广告 =&gt; ((省份, 广告), 1)</span></span><br><span class="line">    <span class="keyword">val</span> mapRDD = dataRDD.map(data =&gt; ((data.split(<span class="string">" "</span>)(<span class="number">1</span>), data.split(<span class="string">" "</span>)(<span class="number">4</span>)), <span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 将转换结构后的数据进行分组聚合</span></span><br><span class="line">    <span class="comment">// ((省份, 广告),1) =&gt; ((省份, 广告), sum)</span></span><br><span class="line">    <span class="keyword">val</span> reduceRDD = mapRDD.reduceByKey(_ + _)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 将聚合的结果进行结构的转换</span></span><br><span class="line">    <span class="comment">// ((省份, 广告), sum) =&gt; (省份, (广告, sum))</span></span><br><span class="line">    <span class="keyword">val</span> newMapRDD = reduceRDD.map &#123;</span><br><span class="line">      <span class="keyword">case</span> ((prv, ad), sum) =&gt; (prv, (ad, sum))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 将转换结构后的数据根据省份进行分组</span></span><br><span class="line">    <span class="comment">// (省份, (广告, sum)) =&gt; (省份, [(广告A, sumA),(广告B, sumB)])</span></span><br><span class="line">    <span class="keyword">val</span> groupRDD: <span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">Iterable</span>[(<span class="type">String</span>, <span class="type">Int</span>)])] = newMapRDD.groupByKey()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6. 将分组后的数据组内排序(降序)，取前三名</span></span><br><span class="line">    <span class="keyword">val</span> resultRDD = groupRDD.mapValues(_.toList.sortBy(_._2)(<span class="type">Ordering</span>.<span class="type">Int</span>.reverse).take(<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 7. 采集数据打印控制台</span></span><br><span class="line">    resultRDD.collect().foreach(println)</span><br><span class="line"></span><br><span class="line">    sc.stop()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<h4 id="5-1-4-5-RDD-行动算子"><a href="#5-1-4-5-RDD-行动算子" class="headerlink" title="5.1.4.5 RDD 行动算子"></a>5.1.4.5 RDD 行动算子</h4><h5 id="reduce"><a href="#reduce" class="headerlink" title="reduce"></a>reduce</h5><ul>
<li><p>函数签名</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reduce</span></span>(f: (<span class="type">T</span>, <span class="type">T</span>) =&gt; <span class="type">T</span>): <span class="type">T</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>函数说明  </p>
<p>聚集 RDD 中的所有元素，先聚合分区内数据，再聚合分区间数据  </p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> rdd: <span class="type">RDD</span>[<span class="type">Int</span>] = sc.makeRDD(<span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line"><span class="comment">// 聚合数据</span></span><br><span class="line"><span class="keyword">val</span> reduceResult: <span class="type">Int</span> = rdd.reduce(_+_)</span><br></pre></td></tr></table></figure>
</li>
<li><p>练习与测试</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spark.core.rdd.operator.action</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Spark01_RDD_Operator_Action</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">"local[*]"</span>).setAppName(<span class="string">"Operator"</span>)</span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(sparkConf)</span><br><span class="line">    <span class="comment">// TODO 行动算子</span></span><br><span class="line">    <span class="comment">// TODO 行动算子-底层原理</span></span><br><span class="line">    <span class="keyword">val</span> rdd = sc.makeRDD(<span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 所谓的行动段子，其实就是触发作业（Job）执行的方法</span></span><br><span class="line">    <span class="comment">// 底层代码调用的是环境对象的runJob方法</span></span><br><span class="line">    <span class="comment">// 底层代码会创建ActiveJob，并提交执行</span></span><br><span class="line">    rdd.collect()</span><br><span class="line"></span><br><span class="line">    sc.stop()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spark.core.rdd.operator.action</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Spark02_RDD_Operator_Action</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">"local[*]"</span>).setAppName(<span class="string">"Operator"</span>)</span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(sparkConf)</span><br><span class="line">    <span class="comment">// TODO 行动算子-reduce</span></span><br><span class="line">    <span class="comment">// TODO 聚集 RDD 中的所有元素，先聚合分区内数据，再聚合分区间数据</span></span><br><span class="line">    <span class="comment">// TODO 数据聚合</span></span><br><span class="line">    <span class="keyword">val</span> rdd = sc.makeRDD(<span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> i = rdd.reduce(_ + _)</span><br><span class="line"></span><br><span class="line">    println(i)</span><br><span class="line">    sc.stop()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="collect"><a href="#collect" class="headerlink" title="collect"></a>collect</h5><ul>
<li><p>函数签名</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">collect</span></span>(): <span class="type">Array</span>[<span class="type">T</span>]</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数说明  </p>
<p>在驱动程序中，以数组 Array 的形式返回数据集的所有元素  </p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> rdd: <span class="type">RDD</span>[<span class="type">Int</span>] = sc.makeRDD(<span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line"><span class="comment">// 收集数据到 Driver</span></span><br><span class="line">rdd.collect().foreach(println)</span><br></pre></td></tr></table></figure>
</li>
<li><p>练习与测试</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spark.core.rdd.operator.action</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Spark03_RDD_Operator_Action</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">"local[*]"</span>).setAppName(<span class="string">"Operator"</span>)</span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(sparkConf)</span><br><span class="line">    <span class="comment">// TODO 行动算子-collect</span></span><br><span class="line">    <span class="comment">// TODO 在驱动程序中，以数组 Array 的形式返回数据集的所有元素</span></span><br><span class="line">    <span class="comment">// TODO 把不同节点的计算的结果按照一定的分区采集顺序采集到Driver端内存中，形成数组</span></span><br><span class="line">    <span class="keyword">val</span> rdd = sc.makeRDD(<span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// collect：方法会将不同分区的数据按照分区数据采集到Driver端内存中，形成数组</span></span><br><span class="line">    <span class="keyword">val</span> cRDD: <span class="type">Array</span>[<span class="type">Int</span>] = rdd.collect()</span><br><span class="line"></span><br><span class="line">    println(cRDD)</span><br><span class="line">    sc.stop()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="count"><a href="#count" class="headerlink" title="count"></a>count</h5><ul>
<li><p>函数签名</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count</span></span>(): <span class="type">Long</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>函数说明  </p>
<p>返回 RDD 中元素的个数  </p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> rdd: <span class="type">RDD</span>[<span class="type">Int</span>] = sc.makeRDD(<span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line"><span class="comment">// 返回 RDD 中元素的个数</span></span><br><span class="line"><span class="keyword">val</span> countResult: <span class="type">Long</span> = rdd.count()</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="first"><a href="#first" class="headerlink" title="first"></a>first</h5><ul>
<li><p>函数签名</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">first</span></span>(): <span class="type">T</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>函数说明  </p>
<p>返回 RDD 中的第一个元素  </p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> rdd: <span class="type">RDD</span>[<span class="type">Int</span>] = sc.makeRDD(<span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line"><span class="comment">// 返回 RDD 中元素的个数</span></span><br><span class="line"><span class="keyword">val</span> firstResult: <span class="type">Int</span> = rdd.first()</span><br><span class="line">println(firstResult)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="take"><a href="#take" class="headerlink" title="take"></a>take</h5><ul>
<li><p>函数签名</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">take</span></span>(num: <span class="type">Int</span>): <span class="type">Array</span>[<span class="type">T</span>]</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数说明  </p>
<p>返回一个由 RDD 的前 n 个元素组成的数组  </p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> rdd: <span class="type">RDD</span>[<span class="type">Int</span>] = sc.makeRDD(<span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line"><span class="comment">// 返回 RDD 中元素的个数</span></span><br><span class="line"><span class="keyword">val</span> takeResult: <span class="type">Array</span>[<span class="type">Int</span>] = rdd.take(<span class="number">2</span>)</span><br><span class="line">println(takeResult.mkString(<span class="string">","</span>))</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="takeOrdered"><a href="#takeOrdered" class="headerlink" title="takeOrdered"></a>takeOrdered</h5><ul>
<li><p>函数签名</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">takeOrdered</span></span>(num: <span class="type">Int</span>)(<span class="keyword">implicit</span> ord: <span class="type">Ordering</span>[<span class="type">T</span>]): <span class="type">Array</span>[<span class="type">T</span>]</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数说明  </p>
<p>返回该 RDD 排序后的前 n 个元素组成的数组  </p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> rdd: <span class="type">RDD</span>[<span class="type">Int</span>] = sc.makeRDD(<span class="type">List</span>(<span class="number">1</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">4</span>))</span><br><span class="line"><span class="comment">// 返回 RDD 中元素的个数</span></span><br><span class="line"><span class="keyword">val</span> result: <span class="type">Array</span>[<span class="type">Int</span>] = rdd.takeOrdered(<span class="number">2</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>练习与测试</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spark.core.rdd.operator.action</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Spark04_RDD_Operator_Action</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">"local[*]"</span>).setAppName(<span class="string">"Operator"</span>)</span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(sparkConf)</span><br><span class="line">    <span class="comment">// TODO 行动算子-count-first-take-takeOrdered</span></span><br><span class="line">    <span class="comment">// TODO 测试count、first、take、takeOrdered 算子</span></span><br><span class="line">    <span class="keyword">val</span> rdd = sc.makeRDD(<span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 行动算子-count</span></span><br><span class="line">    <span class="comment">// TODO 返回 RDD 中元素的个数</span></span><br><span class="line">    <span class="comment">// TODO 返回元素的个数</span></span><br><span class="line">    <span class="keyword">val</span> rRDD = rdd.count()</span><br><span class="line">    println(rRDD)</span><br><span class="line">    println(<span class="string">"================="</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 行动算子-first</span></span><br><span class="line">    <span class="comment">// TODO 返回 RDD 中的第一个元素</span></span><br><span class="line">    <span class="comment">// TODO 返回第一个元素</span></span><br><span class="line">    <span class="keyword">val</span> first = rdd.first()</span><br><span class="line">    println(first)</span><br><span class="line">    println(<span class="string">"================="</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 行动算子-take</span></span><br><span class="line">    <span class="comment">// TODO 返回一个由 RDD 的前 n 个元素组成的数组</span></span><br><span class="line">    <span class="comment">// TODO 返回前 n 个元素数组</span></span><br><span class="line">    <span class="keyword">val</span> takeRDD = rdd.take(<span class="number">3</span>)</span><br><span class="line">    takeRDD.foreach(println)</span><br><span class="line">    println(<span class="string">"================="</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 行动算子-takeOrdered</span></span><br><span class="line">    <span class="comment">// TODO 返回该 RDD 排序后的前 n 个元素组成的数组</span></span><br><span class="line">    <span class="comment">// TODO 返回排序后的前 n 个元素数组</span></span><br><span class="line">    <span class="keyword">val</span> rdd1 = sc.makeRDD(<span class="type">List</span>(<span class="number">4</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>))</span><br><span class="line">    <span class="keyword">val</span> toRDD = rdd1.takeOrdered(<span class="number">3</span>)(<span class="type">Ordering</span>.<span class="type">Int</span>.reverse)</span><br><span class="line">    toRDD.foreach(println)</span><br><span class="line"></span><br><span class="line">    sc.stop()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="aggregate"><a href="#aggregate" class="headerlink" title="aggregate"></a>aggregate</h5><ul>
<li><p>函数签名</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">aggregate</span></span>[<span class="type">U</span>: <span class="type">ClassTag</span>](zeroValue: <span class="type">U</span>)(seqOp: (<span class="type">U</span>, <span class="type">T</span>) =&gt; <span class="type">U</span>, combOp: (<span class="type">U</span>, <span class="type">U</span>) =&gt; <span class="type">U</span>): <span class="type">U</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>函数说明  </p>
<p>分区的数据通过初始值和分区内的数据进行聚合，然后再和初始值进行分区间的数据聚合  </p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> rdd: <span class="type">RDD</span>[<span class="type">Int</span>] = sc.makeRDD(<span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>), <span class="number">8</span>)</span><br><span class="line"><span class="comment">// 将该 RDD 所有元素相加得到结果</span></span><br><span class="line"><span class="comment">//val result: Int = rdd.aggregate(0)(_ + _, _ + _)</span></span><br><span class="line"><span class="keyword">val</span> result: <span class="type">Int</span> = rdd.aggregate(<span class="number">10</span>)(_ + _, _ + _)</span><br></pre></td></tr></table></figure>
</li>
<li><p>练习与测试</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spark.core.rdd.operator.action</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Spark05_RDD_Operator_Action</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">"local[*]"</span>).setAppName(<span class="string">"Operator"</span>)</span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(sparkConf)</span><br><span class="line">    <span class="comment">// TODO 行动算子-aggregate</span></span><br><span class="line">    <span class="comment">// TODO 分区的数据通过初始值和分区内的数据进行聚合，然后再和初始值进行分区间的数据聚合</span></span><br><span class="line">    <span class="comment">// TODO 计算不同分区数据之和</span></span><br><span class="line">    <span class="keyword">val</span> rdd = sc.makeRDD(<span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>), <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">val</span> result = rdd.aggregate(<span class="number">0</span>)(_ + _, _ + _)</span><br><span class="line">    println(result)</span><br><span class="line">    println(<span class="string">"====================="</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// aggregateByKey：初始值只会参与分区内计算</span></span><br><span class="line">    <span class="comment">// aggregate：初始值会参与分区内计算，而且还参与分区间的计算</span></span><br><span class="line">    <span class="keyword">val</span> result1 = rdd.aggregate(<span class="number">10</span>)(_ + _, _ + _)</span><br><span class="line">    println(result1)</span><br><span class="line">    sc.stop()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="fold"><a href="#fold" class="headerlink" title="fold"></a>fold</h5><ul>
<li><p>函数签名</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fold</span></span>(zeroValue: <span class="type">T</span>)(op: (<span class="type">T</span>, <span class="type">T</span>) =&gt; <span class="type">T</span>): <span class="type">T</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>函数说明  </p>
<p>折叠操作， aggregate 的简化版操作  </p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> rdd: <span class="type">RDD</span>[<span class="type">Int</span>] = sc.makeRDD(<span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line"><span class="keyword">val</span> foldResult: <span class="type">Int</span> = rdd.fold(<span class="number">0</span>)(_+_)</span><br></pre></td></tr></table></figure>
</li>
<li><p>练习与测试</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spark.core.rdd.operator.action</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Spark06_RDD_Operator_Action</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">"local[*]"</span>).setAppName(<span class="string">"Operator"</span>)</span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(sparkConf)</span><br><span class="line">    <span class="comment">// TODO 行动算子-fold</span></span><br><span class="line">    <span class="comment">// TODO 当分区内计算规则和分区间计算规则相同时，aggregate 就可以简化为 fold</span></span><br><span class="line">    <span class="comment">// TODO 计算不同分区数据之和</span></span><br><span class="line">    <span class="keyword">val</span> rdd = sc.makeRDD(<span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>), <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">val</span> result1 = rdd.fold(<span class="number">10</span>)(_ + _)</span><br><span class="line">    println(result1)</span><br><span class="line">    sc.stop()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="countByKey"><a href="#countByKey" class="headerlink" title="countByKey"></a>countByKey</h5><ul>
<li><p>函数签名</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">countByKey</span></span>(): <span class="type">Map</span>[<span class="type">K</span>, <span class="type">Long</span>]</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数说明  </p>
<p>统计每种 key 的个数  </p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> rdd: <span class="type">RDD</span>[(<span class="type">Int</span>, <span class="type">String</span>)] = sc.makeRDD(<span class="type">List</span>((<span class="number">1</span>, <span class="string">"a"</span>), (<span class="number">1</span>, <span class="string">"a"</span>), (<span class="number">1</span>, <span class="string">"a"</span>), (<span class="number">2</span>,<span class="string">"b"</span>), (<span class="number">3</span>, <span class="string">"c"</span>), (<span class="number">3</span>, <span class="string">"c"</span>)))</span><br><span class="line"><span class="comment">// 统计每种 key 的个数</span></span><br><span class="line"><span class="keyword">val</span> result: collection.<span class="type">Map</span>[<span class="type">Int</span>, <span class="type">Long</span>] = rdd.countByKey()</span><br></pre></td></tr></table></figure>
</li>
<li><p>练习与测试</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spark.core.rdd.operator.action</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Spark07_RDD_Operator_Action</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">"local[*]"</span>).setAppName(<span class="string">"Operator"</span>)</span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(sparkConf)</span><br><span class="line">    <span class="comment">// TODO 行动算子-countByValue-countByKey</span></span><br><span class="line">    <span class="comment">// TODO 统计每种 key(元组)/单值类型 的个数</span></span><br><span class="line">    <span class="comment">// TODO 返回 key(元组)/单值类型 的个数</span></span><br><span class="line">    <span class="keyword">val</span> rdd = sc.makeRDD(<span class="type">List</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">4</span>), <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">val</span> cRDD: collection.<span class="type">Map</span>[<span class="type">Int</span>, <span class="type">Long</span>] = rdd.countByValue()</span><br><span class="line">    println(cRDD) <span class="comment">// Map(4 -&gt; 1, 1 -&gt; 3)</span></span><br><span class="line">    println(<span class="string">"===================="</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> rdd1 = sc.makeRDD(<span class="type">List</span>((<span class="string">"a"</span>, <span class="number">1</span>), (<span class="string">"a"</span>, <span class="number">1</span>), (<span class="string">"a"</span>, <span class="number">3</span>)))</span><br><span class="line">    <span class="keyword">val</span> cRDD1: collection.<span class="type">Map</span>[<span class="type">String</span>, <span class="type">Long</span>] = rdd1.countByKey()</span><br><span class="line">    println(cRDD1)</span><br><span class="line"></span><br><span class="line">    sc.stop()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="save-相关算子"><a href="#save-相关算子" class="headerlink" title="save 相关算子"></a>save 相关算子</h5><ul>
<li><p>函数签名</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">saveAsTextFile</span></span>(path: <span class="type">String</span>): <span class="type">Unit</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">saveAsObjectFile</span></span>(path: <span class="type">String</span>): <span class="type">Unit</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">saveAsSequenceFile</span></span>(path: <span class="type">String</span>, codec: <span class="type">Option</span>[<span class="type">Class</span>[_ &lt;: <span class="type">CompressionCodec</span>]] = <span class="type">None</span>): <span class="type">Unit</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>函数说明  </p>
<p>将数据保存到不同格式的文件中  </p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 保存成 Text 文件</span></span><br><span class="line">rdd.saveAsTextFile(<span class="string">"output"</span>)</span><br><span class="line"><span class="comment">// 序列化成对象保存到文件</span></span><br><span class="line">rdd.saveAsObjectFile(<span class="string">"output1"</span>)</span><br><span class="line"><span class="comment">// 保存成 Sequencefile 文件</span></span><br><span class="line">rdd.map((_,<span class="number">1</span>)).saveAsSequenceFile(<span class="string">"output2"</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>练习与测试</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spark.core.rdd.operator.action</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Spark08_RDD_Operator_Action</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">"local[*]"</span>).setAppName(<span class="string">"Operator"</span>)</span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(sparkConf)</span><br><span class="line">    <span class="comment">// TODO 行动算子-save相关算子</span></span><br><span class="line">    <span class="comment">// TODO 将数据保存到不同格式的文件中</span></span><br><span class="line">    <span class="comment">// TODO 数据持久化</span></span><br><span class="line">    <span class="keyword">val</span> rdd = sc.makeRDD(<span class="type">List</span>((<span class="string">"a"</span>, <span class="number">1</span>), (<span class="string">"a"</span>, <span class="number">2</span>), (<span class="string">"a"</span>, <span class="number">3</span>), (<span class="string">"a"</span>, <span class="number">4</span>)), <span class="number">2</span>)</span><br><span class="line">    rdd.saveAsTextFile(<span class="string">"output"</span>)</span><br><span class="line">    rdd.saveAsObjectFile(<span class="string">"output1"</span>)</span><br><span class="line">    <span class="comment">// saveAsSequenceFile方法要求数据的格式必须为K-V类型</span></span><br><span class="line">    rdd.saveAsSequenceFile(<span class="string">"output2"</span>)</span><br><span class="line">    sc.stop()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h5 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h5><ul>
<li><p>函数签名</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foreach</span></span>(f: <span class="type">T</span> =&gt; <span class="type">Unit</span>): <span class="type">Unit</span> = withScope &#123;<span class="keyword">val</span> cleanF = sc.clean(f)sc.runJob(<span class="keyword">this</span>, (iter: <span class="type">Iterator</span>[<span class="type">T</span>]) =&gt; iter.foreach(cleanF))&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>函数说明  </p>
<p>分布式遍历 RDD 中的每一个元素，调用指定函数  </p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> rdd: <span class="type">RDD</span>[<span class="type">Int</span>] = sc.makeRDD(<span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line"><span class="comment">// 收集后打印</span></span><br><span class="line">rdd.map(num=&gt;num).collect().foreach(println)</span><br><span class="line">println(<span class="string">"****************"</span>)</span><br><span class="line"><span class="comment">// 分布式打印</span></span><br><span class="line">rdd.foreach(println)</span><br></pre></td></tr></table></figure>
</li>
<li><p>图示分析</p>
<p><img src="/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230915150713822.png" alt="image-20230915150713822"></p>
<p><img src="/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230915150757365.png" alt="image-20230915150757365"></p>
</li>
<li><p>练习与测试</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spark.core.rdd.operator.action</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Spark09_RDD_Operator_Action</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">"local[*]"</span>).setAppName(<span class="string">"Operator"</span>)</span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(sparkConf)</span><br><span class="line">    <span class="comment">// TODO 行动算子-foreach</span></span><br><span class="line">    <span class="comment">// TODO 分布式遍历 RDD 中的每一个元素，调用指定函数</span></span><br><span class="line">    <span class="comment">// TODO 遍历 RDD 中的每一个元素</span></span><br><span class="line">    <span class="keyword">val</span> rdd = sc.makeRDD(<span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line">    <span class="comment">// rdd.collect().foreach(println)：这里其实是Driver将不同节点的计算的结果以分区为单位先采集回到Driver端内存，然后再按照分区采集顺序进行集合的循环遍历打印的方法</span></span><br><span class="line">    rdd.collect().foreach(println)</span><br><span class="line">    println(<span class="string">"================="</span>)</span><br><span class="line">    <span class="comment">// rdd.foreach(println)：这里其实是分布式打印，没有顺序的概念，与因为会把每个数据发送给不同的Executor端，然后直接在Executor端内存中将数据进行打印输出</span></span><br><span class="line">    rdd.foreach(println)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 算子：Operator(操作)</span></span><br><span class="line">    <span class="comment">// RDD的方法和Scala集合对象的方法不一样</span></span><br><span class="line">    <span class="comment">// 集合对象的方法都是在同一个节点的内存中完成的</span></span><br><span class="line">    <span class="comment">// RDD的方法可以将计算逻辑发送到Executor端（分布式节点）执行</span></span><br><span class="line">    <span class="comment">// 为了区分不同的处理效果，所以将RDD的方法称之为算子。</span></span><br><span class="line">    <span class="comment">// RDD的方法外部的操作都是在Dreiver端执行的，而方法内部的逻辑代码是在Executor端执行的。</span></span><br><span class="line"></span><br><span class="line">    sc.stop()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230920141352308.png" alt="image-20230920141352308"></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spark.core.rdd.operator.action</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Spark10_RDD_Operator_Action</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">"local[*]"</span>).setAppName(<span class="string">"Operator"</span>)</span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(sparkConf)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO RDD的方法的内外部操作</span></span><br><span class="line">    <span class="keyword">val</span> rdd = sc.makeRDD(<span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> user = <span class="keyword">new</span> <span class="type">User</span>()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// RDD算子中传递的函数是会包含闭包操作，那么就会进行检测功能，称之为：闭包检测</span></span><br><span class="line">    rdd.foreach(num =&gt; &#123;</span><br><span class="line">      println(<span class="string">"age="</span> + (user.age + num))</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    sc.stop()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// SparkException: Task not serializable</span></span><br><span class="line">  <span class="comment">// java.io.NotSerializableException: com.atguigu.spark.core.rdd.operator.action.Spark10_RDD_Operator_Action$User</span></span><br><span class="line">  <span class="comment">// 因为println是在executor执行，而new User()在Driver执行，所以需要序列化对象传递数据</span></span><br><span class="line">  <span class="comment">// class User extends Serializable &#123;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 样例类在编译时，会自动混入序列化特质（实现可序列化接口）</span></span><br><span class="line">  <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> age: <span class="type">Int</span> = <span class="number">30</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>算子总结与练习</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spark.core.wc</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.rdd.<span class="type">RDD</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"><span class="keyword">import</span> scala.collection.mutable</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Spark04_WordCount</span> </span>&#123;</span><br><span class="line">  <span class="comment">// TODO wordCount的多种算子实现方式</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">"local"</span>).setAppName(<span class="string">"WordCount"</span>)</span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(sparkConf)</span><br><span class="line"></span><br><span class="line">    wordCount91011(sc)</span><br><span class="line"></span><br><span class="line">    sc.stop()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// groupBy</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">wordCount1</span></span>(sc: <span class="type">SparkContext</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> rdd = sc.makeRDD(<span class="type">List</span>(<span class="string">"Hello Scala"</span>, <span class="string">"Hello Spark"</span>))</span><br><span class="line">    <span class="keyword">val</span> words = rdd.flatMap(_.split(<span class="string">" "</span>))</span><br><span class="line">    <span class="keyword">val</span> group: <span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">Iterable</span>[<span class="type">String</span>])] = words.groupBy(word =&gt; word)</span><br><span class="line">    <span class="keyword">val</span> workCount = group.mapValues(iter =&gt; iter.size)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// groupByKey</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">wordCount2</span></span>(sc: <span class="type">SparkContext</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> rdd = sc.makeRDD(<span class="type">List</span>(<span class="string">"Hello Scala"</span>, <span class="string">"Hello Spark"</span>))</span><br><span class="line">    <span class="keyword">val</span> words = rdd.flatMap(_.split(<span class="string">" "</span>))</span><br><span class="line">    <span class="keyword">val</span> wordOne = words.map((_, <span class="number">1</span>))</span><br><span class="line">    <span class="keyword">val</span> group: <span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">Iterable</span>[<span class="type">Int</span>])] = wordOne.groupByKey()</span><br><span class="line">    <span class="keyword">val</span> workCount = group.mapValues(iter =&gt; iter.size)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// reduceByKey</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">wordCount3</span></span>(sc: <span class="type">SparkContext</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> rdd = sc.makeRDD(<span class="type">List</span>(<span class="string">"Hello Scala"</span>, <span class="string">"Hello Spark"</span>))</span><br><span class="line">    <span class="keyword">val</span> words = rdd.flatMap(_.split(<span class="string">" "</span>))</span><br><span class="line">    <span class="keyword">val</span> wordOne = words.map((_, <span class="number">1</span>))</span><br><span class="line">    <span class="keyword">val</span> wordCount: <span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = wordOne.reduceByKey(_ + _)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// aggregateByKey</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">wordCount4</span></span>(sc: <span class="type">SparkContext</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> rdd = sc.makeRDD(<span class="type">List</span>(<span class="string">"Hello Scala"</span>, <span class="string">"Hello Spark"</span>))</span><br><span class="line">    <span class="keyword">val</span> words = rdd.flatMap(_.split(<span class="string">" "</span>))</span><br><span class="line">    <span class="keyword">val</span> wordOne = words.map((_, <span class="number">1</span>))</span><br><span class="line">    <span class="keyword">val</span> wordCount: <span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = wordOne.aggregateByKey(<span class="number">0</span>)(_ + _, _ + _)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// foldByKey</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">wordCount5</span></span>(sc: <span class="type">SparkContext</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> rdd = sc.makeRDD(<span class="type">List</span>(<span class="string">"Hello Scala"</span>, <span class="string">"Hello Spark"</span>))</span><br><span class="line">    <span class="keyword">val</span> words = rdd.flatMap(_.split(<span class="string">" "</span>))</span><br><span class="line">    <span class="keyword">val</span> wordOne = words.map((_, <span class="number">1</span>))</span><br><span class="line">    <span class="keyword">val</span> wordCount: <span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = wordOne.foldByKey(<span class="number">0</span>)(_ + _)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// combineByKey</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">wordCount6</span></span>(sc: <span class="type">SparkContext</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> rdd = sc.makeRDD(<span class="type">List</span>(<span class="string">"Hello Scala"</span>, <span class="string">"Hello Spark"</span>))</span><br><span class="line">    <span class="keyword">val</span> words = rdd.flatMap(_.split(<span class="string">" "</span>))</span><br><span class="line">    <span class="keyword">val</span> wordOne = words.map((_, <span class="number">1</span>))</span><br><span class="line">    <span class="keyword">val</span> wordCount = wordOne.combineByKey(v =&gt; v, (x: <span class="type">Int</span>, y) =&gt; x + y, (x: <span class="type">Int</span>, y: <span class="type">Int</span>) =&gt; x + y)</span><br><span class="line">    wordCount.collect().foreach(println)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// countByKey</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">wordCount7</span></span>(sc: <span class="type">SparkContext</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> rdd = sc.makeRDD(<span class="type">List</span>(<span class="string">"Hello Scala"</span>, <span class="string">"Hello Spark"</span>))</span><br><span class="line">    <span class="keyword">val</span> words = rdd.flatMap(_.split(<span class="string">" "</span>))</span><br><span class="line">    <span class="keyword">val</span> wordOne = words.map((_, <span class="number">1</span>))</span><br><span class="line">    <span class="keyword">val</span> wordCount: collection.<span class="type">Map</span>[<span class="type">String</span>, <span class="type">Long</span>] = wordOne.countByKey()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// countByValue</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">wordCount8</span></span>(sc: <span class="type">SparkContext</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> rdd = sc.makeRDD(<span class="type">List</span>(<span class="string">"Hello Scala"</span>, <span class="string">"Hello Spark"</span>))</span><br><span class="line">    <span class="keyword">val</span> words = rdd.flatMap(_.split(<span class="string">" "</span>))</span><br><span class="line">    <span class="keyword">val</span> wordCount: collection.<span class="type">Map</span>[<span class="type">String</span>, <span class="type">Long</span>] = words.countByValue()</span><br><span class="line">    println(wordCount)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// reduce, aggregate, fold</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">wordCount91011</span></span>(sc: <span class="type">SparkContext</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> rdd = sc.makeRDD(<span class="type">List</span>(<span class="string">"Hello Scala"</span>, <span class="string">"Hello Spark"</span>))</span><br><span class="line">    <span class="keyword">val</span> words: <span class="type">RDD</span>[<span class="type">String</span>] = rdd.flatMap(_.split(<span class="string">" "</span>))</span><br><span class="line">    <span class="keyword">val</span> mapWord: <span class="type">RDD</span>[mutable.<span class="type">Map</span>[<span class="type">String</span>, <span class="type">Long</span>]] = words.map(</span><br><span class="line">      word =&gt; &#123;</span><br><span class="line">        mutable.<span class="type">Map</span>[<span class="type">String</span>, <span class="type">Long</span>]((word, <span class="number">1</span>))</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">val</span> wordCount: mutable.<span class="type">Map</span>[<span class="type">String</span>, <span class="type">Long</span>] = mapWord.reduce(</span><br><span class="line">      (map1, map2) =&gt; &#123;</span><br><span class="line">        map2.foreach &#123;</span><br><span class="line">          <span class="keyword">case</span> (word, count) =&gt; &#123;</span><br><span class="line">            <span class="keyword">val</span> newCount = map1.getOrElse(word, <span class="number">0</span>L) + count</span><br><span class="line">            map1.update(word, newCount)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        map1</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">    println(wordCount)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h4 id="5-1-4-6-RDD-序列化"><a href="#5-1-4-6-RDD-序列化" class="headerlink" title="5.1.4.6 RDD 序列化"></a>5.1.4.6 RDD 序列化</h4><p>1) 闭包检查</p>
<p>   从计算的角度, 算子以外的代码都是在 Driver 端执行, 算子里面的代码都是在 Executor端执行。 那么在 scala 的函数式编程中，就会导致算子内经常会用到算子外的数据，这样就形成了闭包的效果，如果使用的算子外的数据无法序列化，就意味着无法传值给 Executor端执行，就会发生错误，所以需要在执行任务计算前，检测闭包内的对象是否可以进行序列化，这个操作我们称之为闭包检测。 Scala2.12 版本后闭包编译方式发生了改变。</p>
<p>2) 序列化方法和属性</p>
<p>   从计算的角度, 算子以外的代码都是在 Driver 端执行, 算子里面的代码都是在 Executor端执行，看如下代码：  </p>
   <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">serializable02_function</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="comment">//1.创建 SparkConf 并设置 App 名称</span></span><br><span class="line">        <span class="keyword">val</span> conf: <span class="type">SparkConf</span> = <span class="keyword">new</span> <span class="type">SparkConf</span>().setAppName(<span class="string">"SparkCoreTest"</span>).setMaster(<span class="string">"local[*]"</span>)</span><br><span class="line">        <span class="comment">//2.创建 SparkContext，该对象是提交 Spark App 的入口</span></span><br><span class="line">        <span class="keyword">val</span> sc: <span class="type">SparkContext</span> = <span class="keyword">new</span> <span class="type">SparkContext</span>(conf)</span><br><span class="line">        <span class="comment">//3.创建一个 RDD</span></span><br><span class="line">        <span class="keyword">val</span> rdd: <span class="type">RDD</span>[<span class="type">String</span>] = sc.makeRDD(<span class="type">Array</span>(<span class="string">"hello world"</span>, <span class="string">"hello spark"</span>, <span class="string">"hive"</span>, <span class="string">"atguigu"</span>))</span><br><span class="line">        <span class="comment">//3.1 创建一个 Search 对象</span></span><br><span class="line">        <span class="keyword">val</span> search = <span class="keyword">new</span> <span class="type">Search</span>(<span class="string">"hello"</span>)</span><br><span class="line">        <span class="comment">//3.2 函数传递，打印： ERROR Task not serializable</span></span><br><span class="line">        search.getMatch1(rdd).collect().foreach(println)</span><br><span class="line">        <span class="comment">//3.3 属性传递，打印： ERROR Task not serializable</span></span><br><span class="line">        search.getMatch2(rdd).collect().foreach(println)</span><br><span class="line">        <span class="comment">//4.关闭连接</span></span><br><span class="line">        sc.stop()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Search</span>(<span class="params">query:<span class="type">String</span></span>) <span class="keyword">extends</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">isMatch</span></span>(s: <span class="type">String</span>): <span class="type">Boolean</span> = &#123;</span><br><span class="line">		s.contains(query)</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">// 函数序列化案例</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getMatch1</span> </span>(rdd: <span class="type">RDD</span>[<span class="type">String</span>]): <span class="type">RDD</span>[<span class="type">String</span>] = &#123;</span><br><span class="line">        <span class="comment">//rdd.filter(this.isMatch)</span></span><br><span class="line">        rdd.filter(isMatch)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 属性序列化案例</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getMatch2</span></span>(rdd: <span class="type">RDD</span>[<span class="type">String</span>]): <span class="type">RDD</span>[<span class="type">String</span>] = &#123;</span><br><span class="line">        <span class="comment">//rdd.filter(x =&gt; x.contains(this.query))</span></span><br><span class="line">        rdd.filter(x =&gt; x.contains(query))</span><br><span class="line">        <span class="comment">//val q = query</span></span><br><span class="line">        <span class="comment">//rdd.filter(x =&gt; x.contains(q))</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3) Kryo 序列化框架  </p>
<p>   参考地址: <a href="https://github.com/EsotericSoftware/kryo" target="_blank" rel="noopener">https://github.com/EsotericSoftware/kryo</a><br>   Java 的序列化能够序列化任何的类。但是比较重（字节多） ，序列化后，对象的提交也比较大。 Spark 出于性能的考虑， Spark2.0 开始支持另外一种 Kryo 序列化机制。 Kryo 速度是 Serializable 的 10 倍。当 RDD 在 Shuffle 数据的时候，简单数据类型、数组和字符串类型已经在 Spark 内部使用 Kryo 来序列化。<br>   注意：即使使用 Kryo 序列化，也要继承 Serializable 接口。  </p>
   <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">serializable_Kryo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">val</span> conf: <span class="type">SparkConf</span> = <span class="keyword">new</span> <span class="type">SparkConf</span>().setAppName(<span class="string">"SerDemo"</span>).setMaster(<span class="string">"local[*]"</span>)</span><br><span class="line">        <span class="comment">// 替换默认的序列化机制</span></span><br><span class="line">        .set(<span class="string">"spark.serializer"</span>,<span class="string">"org.apache.spark.serializer.KryoSerializer"</span>)</span><br><span class="line">        <span class="comment">// 注册需要使用 kryo 序列化的自定义类</span></span><br><span class="line">        .registerKryoClasses(<span class="type">Array</span>(classOf[<span class="type">Searcher</span>]))</span><br><span class="line">        <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(conf)</span><br><span class="line">        <span class="keyword">val</span> rdd: <span class="type">RDD</span>[<span class="type">String</span>] = sc.makeRDD(<span class="type">Array</span>(<span class="string">"hello world"</span>, <span class="string">"hello atguigu"</span>, <span class="string">"atguigu"</span>, <span class="string">"hahah"</span>), <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">val</span> searcher = <span class="keyword">new</span> <span class="type">Searcher</span>(<span class="string">"hello"</span>)</span><br><span class="line">        <span class="keyword">val</span> result: <span class="type">RDD</span>[<span class="type">String</span>] = searcher.getMatchedRDD1(rdd)</span><br><span class="line">        result.collect.foreach(println)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">Searcher</span>(<span class="params">val query: <span class="type">String</span></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">isMatch</span></span>(s: <span class="type">String</span>) = &#123;</span><br><span class="line">    	s.contains(query)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getMatchedRDD1</span></span>(rdd: <span class="type">RDD</span>[<span class="type">String</span>]) = &#123;</span><br><span class="line">    	rdd.filter(isMatch)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getMatchedRDD2</span></span>(rdd: <span class="type">RDD</span>[<span class="type">String</span>]) = &#123;</span><br><span class="line">    	<span class="keyword">val</span> q = query</span><br><span class="line">    	rdd.filter(_.contains(q))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>4) 练习与测试</p>
   <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spark.core.rdd.serial</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.rdd.<span class="type">RDD</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Spark01_RDD_Serial</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">// 1. 创建 SparkConf 并设置 App 名称</span></span><br><span class="line">    <span class="keyword">val</span> conf: <span class="type">SparkConf</span> = <span class="keyword">new</span> <span class="type">SparkConf</span>().setAppName(<span class="string">"SparkCoreTest"</span>).setMaster(<span class="string">"local[*]"</span>)</span><br><span class="line">    <span class="comment">// 2. 创建 SparkContext，该对象是提交 Spark App 的入口</span></span><br><span class="line">    <span class="keyword">val</span> sc: <span class="type">SparkContext</span> = <span class="keyword">new</span> <span class="type">SparkContext</span>(conf)</span><br><span class="line">    <span class="comment">// 3. 创建一个 RDD</span></span><br><span class="line">    <span class="keyword">val</span> rdd: <span class="type">RDD</span>[<span class="type">String</span>] = sc.makeRDD(<span class="type">Array</span>(<span class="string">"hello world"</span>, <span class="string">"hello spark"</span>, <span class="string">"hive"</span>, <span class="string">"atguigu"</span>))</span><br><span class="line">    <span class="comment">// 3.1 创建一个 Search 对象</span></span><br><span class="line">    <span class="keyword">val</span> search = <span class="keyword">new</span> <span class="type">Search</span>(<span class="string">"hello"</span>)</span><br><span class="line">    <span class="comment">// 3.2 函数传递，打印： ERROR Task not serializable</span></span><br><span class="line">    <span class="comment">// search.getMatch1(rdd).collect().foreach(println)</span></span><br><span class="line">    <span class="comment">// 3.3 属性传递，打印： ERROR Task not serializable</span></span><br><span class="line">    search.getMatch2(rdd).collect().foreach(println)</span><br><span class="line">    <span class="comment">//4. 关闭连接</span></span><br><span class="line">    sc.stop()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 查询对象</span></span><br><span class="line"><span class="comment">// 类的构造参数其实是类的属性,构造参数需要进行闭包检测，其实就等同于类型进行闭包检测。</span></span><br><span class="line"><span class="comment">// class Search(query: String) &#123;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Search</span>(<span class="params">query: <span class="type">String</span></span>) <span class="keyword">extends</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">isMatch</span></span>(s: <span class="type">String</span>): <span class="type">Boolean</span> = &#123;</span><br><span class="line">    s.contains(query) <span class="comment">// 底层其实就是s.contains(this.query)</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 函数序列化案例</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">getMatch1</span></span>(rdd: <span class="type">RDD</span>[<span class="type">String</span>]): <span class="type">RDD</span>[<span class="type">String</span>] = &#123;</span><br><span class="line">    rdd.filter(isMatch)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 属性序列化案例</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">getMatch2</span></span>(rdd: <span class="type">RDD</span>[<span class="type">String</span>]): <span class="type">RDD</span>[<span class="type">String</span>] = &#123;</span><br><span class="line">    rdd.filter(x =&gt; x.contains(query))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-1-4-7-RDD-依赖关系"><a href="#5-1-4-7-RDD-依赖关系" class="headerlink" title="5.1.4.7 RDD 依赖关系"></a>5.1.4.7 RDD 依赖关系</h4><p>回顾在maven中的依赖和间接依赖</p>
<p><img src="/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230920180926032.png" alt="image-20230920180926032"></p>
<p>在RDD中</p>
<p><img src="/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230920181115290.png" alt="image-20230920181115290"></p>
<ul>
<li>相邻的两个RDD的关系称之为依赖关系</li>
<li>新的RDD依赖于旧的RDD</li>
<li>多个连续的RDD的依赖关系，称之为血缘关系</li>
<li>每个RDD会保存血缘关系</li>
</ul>
<p><img src="/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230920181227289.png" alt="image-20230920181227289"></p>
<ul>
<li>RDD不会保存数据的</li>
<li>RDD为了提供容错性，需要将RDD间的关系保存下来</li>
<li>一旦出现错误，可以根据血缘关系将数据源重新读取进行计算</li>
</ul>
<p><img src="/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230920181432749.png" alt="image-20230920181432749"></p>
<h5 id="RDD-血缘关系"><a href="#RDD-血缘关系" class="headerlink" title="RDD 血缘关系"></a>RDD 血缘关系</h5><p>RDD 只支持粗粒度转换，即在大量记录上执行的单个操作。将创建 RDD 的一系列 Lineage（血统）记录下来，以便恢复丢失的分区。RDD 的 Lineage 会记录 RDD 的元数据信息和转换行为，当该 RDD 的部分分区数据丢失时，它可以根据这些信息来重新运算和恢复丢失的数据分区。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> fileRDD: <span class="type">RDD</span>[<span class="type">String</span>] = sc.textFile(<span class="string">"input/1.txt"</span>)</span><br><span class="line">println(fileRDD.toDebugString)</span><br><span class="line">println(<span class="string">"----------------------"</span>)</span><br><span class="line"><span class="keyword">val</span> wordRDD: <span class="type">RDD</span>[<span class="type">String</span>] = fileRDD.flatMap(_.split(<span class="string">" "</span>))</span><br><span class="line">println(wordRDD.toDebugString)</span><br><span class="line">println(<span class="string">"----------------------"</span>)</span><br><span class="line"><span class="keyword">val</span> mapRDD: <span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = wordRDD.map((_,<span class="number">1</span>))</span><br><span class="line">println(mapRDD.toDebugString)</span><br><span class="line">println(<span class="string">"----------------------"</span>)</span><br><span class="line"><span class="keyword">val</span> resultRDD: <span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = mapRDD.reduceByKey(_+_)</span><br><span class="line">println(resultRDD.toDebugString)</span><br><span class="line">resultRDD.collect()</span><br></pre></td></tr></table></figure>

<p>练习与测试</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spark.core.rdd.dep</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.rdd.<span class="type">RDD</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Spark01_RDD_Dep</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">"local[*]"</span>).setAppName(<span class="string">"WordCount"</span>)</span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(sparkConf)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> lines: <span class="type">RDD</span>[<span class="type">String</span>] = sc.textFile(<span class="string">"datas/dep.txt"</span>)</span><br><span class="line">    <span class="comment">// TODO 展示血缘关系</span></span><br><span class="line">    println(lines.toDebugString)</span><br><span class="line">    println(<span class="string">"*********************"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> words: <span class="type">RDD</span>[<span class="type">String</span>] = lines.flatMap(_.split(<span class="string">" "</span>))</span><br><span class="line">    println(words.toDebugString)</span><br><span class="line">    println(<span class="string">"*********************"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> wordToOne: <span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = words.map(word =&gt; (word, <span class="number">1</span>))</span><br><span class="line">    println(wordToOne.toDebugString)</span><br><span class="line">    println(<span class="string">"*********************"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> wordToCount: <span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = wordToOne.reduceByKey(_ + _)</span><br><span class="line">    println(wordToCount.toDebugString)</span><br><span class="line">    println(<span class="string">"*********************"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> array: <span class="type">Array</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = wordToCount.collect()</span><br><span class="line">    array.foreach(println)</span><br><span class="line"></span><br><span class="line">    sc.stop()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="RDD-依赖关系"><a href="#RDD-依赖关系" class="headerlink" title="RDD 依赖关系"></a>RDD 依赖关系</h5><p>这里所谓的依赖关系，其实就是两个相邻 RDD 之间的关系</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> sc: <span class="type">SparkContext</span> = <span class="keyword">new</span> <span class="type">SparkContext</span>(conf)</span><br><span class="line"><span class="keyword">val</span> fileRDD: <span class="type">RDD</span>[<span class="type">String</span>] = sc.textFile(<span class="string">"input/1.txt"</span>)</span><br><span class="line">println(fileRDD.dependencies)</span><br><span class="line">println(<span class="string">"----------------------"</span>)</span><br><span class="line"><span class="keyword">val</span> wordRDD: <span class="type">RDD</span>[<span class="type">String</span>] = fileRDD.flatMap(_.split(<span class="string">" "</span>))</span><br><span class="line">println(wordRDD.dependencies)</span><br><span class="line">println(<span class="string">"----------------------"</span>)</span><br><span class="line"><span class="keyword">val</span> mapRDD: <span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = wordRDD.map((_,<span class="number">1</span>))</span><br><span class="line">println(mapRDD.dependencies)</span><br><span class="line">println(<span class="string">"----------------------"</span>)</span><br><span class="line"><span class="keyword">val</span> resultRDD: <span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = mapRDD.reduceByKey(_+_)</span><br><span class="line">println(resultRDD.dependencies)</span><br><span class="line">resultRDD.collect()</span><br></pre></td></tr></table></figure>

<p>练习与测试</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spark.core.rdd.dep</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.rdd.<span class="type">RDD</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Spark02_RDD_Dep</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">"local[*]"</span>).setAppName(<span class="string">"WordCount"</span>)</span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(sparkConf)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> lines: <span class="type">RDD</span>[<span class="type">String</span>] = sc.textFile(<span class="string">"datas/dep.txt"</span>)</span><br><span class="line">    <span class="comment">// TODO 展示相邻的RDD之间的依赖关系</span></span><br><span class="line">    println(lines.dependencies)</span><br><span class="line">    println(<span class="string">"*********************"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> words: <span class="type">RDD</span>[<span class="type">String</span>] = lines.flatMap(_.split(<span class="string">" "</span>))</span><br><span class="line">    println(words.dependencies)</span><br><span class="line">    println(<span class="string">"*********************"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> wordToOne: <span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = words.map(word =&gt; (word, <span class="number">1</span>))</span><br><span class="line">    println(wordToOne.dependencies)</span><br><span class="line">    println(<span class="string">"*********************"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> wordToCount: <span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = wordToOne.reduceByKey(_ + _)</span><br><span class="line">    println(wordToCount.dependencies)</span><br><span class="line">    println(<span class="string">"*********************"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> array: <span class="type">Array</span>[(<span class="type">String</span>, <span class="type">Int</span>)] = wordToCount.collect()</span><br><span class="line">    array.foreach(println)</span><br><span class="line"></span><br><span class="line">    sc.stop()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="RDD-窄依赖"><a href="#RDD-窄依赖" class="headerlink" title="RDD 窄依赖"></a>RDD 窄依赖</h5><p>窄依赖表示每一个父(上游)RDD 的 Partition 最多被子（下游） RDD 的一个 Partition 使用，窄依赖我们形象的比喻为独生子女。  </p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">OneToOneDependency</span>[<span class="type">T</span>](<span class="params">rdd: <span class="type">RDD</span>[<span class="type">T</span>]</span>) <span class="keyword">extends</span> <span class="title">NarrowDependency</span>[<span class="type">T</span>](<span class="params">rdd</span>)</span></span><br></pre></td></tr></table></figure>

<p><img src="/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230920181641350.png" alt="image-20230920181641350"></p>
<ul>
<li>新的RDD的一个分区的数据依赖于旧的RDD一个分区的数据</li>
<li>这个依赖称之为OneToOne依赖</li>
</ul>
<h5 id="RDD-宽依赖"><a href="#RDD-宽依赖" class="headerlink" title="RDD 宽依赖"></a>RDD 宽依赖</h5><p>宽依赖表示同一个父（上游） RDD 的 Partition 被多个子（下游） RDD 的 Partition 依赖，会引起 Shuffle，总结：宽依赖我们形象的比喻为多生。  </p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ShuffleDependency</span>[<span class="type">K</span>: <span class="type">ClassTag</span>, <span class="type">V</span>: <span class="type">ClassTag</span>, <span class="type">C</span>: <span class="type">ClassTag</span>](<span class="params"></span></span></span><br><span class="line"><span class="class"><span class="params">    @transient private val _rdd: <span class="type">RDD</span>[_ &lt;: <span class="type">Product2</span>[<span class="type">K</span>, <span class="type">V</span>]],</span></span></span><br><span class="line"><span class="class"><span class="params">    val partitioner: <span class="type">Partitioner</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">    val serializer: <span class="type">Serializer</span> = <span class="type">SparkEnv</span>.get.serializer,</span></span></span><br><span class="line"><span class="class"><span class="params">    val keyOrdering: <span class="type">Option</span>[<span class="type">Ordering</span>[<span class="type">K</span>]] = <span class="type">None</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">    val aggregator: <span class="type">Option</span>[<span class="type">Aggregator</span>[<span class="type">K</span>, <span class="type">V</span>, <span class="type">C</span>]] = <span class="type">None</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">    val mapSideCombine: <span class="type">Boolean</span> = false</span>) <span class="keyword">extends</span> <span class="title">Dependency</span>[<span class="type">Product2</span>[<span class="type">K</span>, <span class="type">V</span>]]</span></span><br></pre></td></tr></table></figure>

<p><img src="/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230920181831605.png" alt="image-20230920181831605"></p>
<ul>
<li>新的RDD的一个分区的数据依赖于旧的RDD多个分区的数据</li>
<li>这个依赖称之为Shuffle依赖</li>
</ul>
<h5 id="RDD-阶段划分"><a href="#RDD-阶段划分" class="headerlink" title="RDD 阶段划分"></a>RDD 阶段划分</h5><p>DAG（Directed Acyclic Graph）有向无环图是由点和线组成的拓扑图形，该图形具有方向，不会闭环。例如，DAG 记录了 RDD 的转换过程和任务的阶段。</p>
<p><img src="/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230920175435337.png" alt="image-20230920175435337"></p>
<p><img src="/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230920182229743.png" alt="image-20230920182229743"></p>
<ul>
<li>当RDD中存在shuffle依赖时，阶段会自动增加一个</li>
<li>阶段的数量 = shuffle依赖的数量 + 1</li>
<li>ResultStage只有一个，最后需要执行的阶段</li>
</ul>
<h5 id="RDD-阶段划分源码"><a href="#RDD-阶段划分源码" class="headerlink" title="RDD 阶段划分源码"></a>RDD 阶段划分源码</h5><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">	<span class="comment">// New stage creation may throw an exception if, for example, jobs are run on</span></span><br><span class="line">	<span class="comment">// HadoopRDD whose underlying HDFS files have been deleted.</span></span><br><span class="line">	finalStage = createResultStage(finalRDD, func, partitions, jobId, callSite)</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">	<span class="keyword">case</span> e: <span class="type">Exception</span> =&gt;</span><br><span class="line">		logWarning(<span class="string">"Creating new stage failed due to exception - job: "</span> + jobId, e)</span><br><span class="line">		listener.jobFailed(e)</span><br><span class="line">	<span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line">... ...</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">createResultStage</span></span>(</span><br><span class="line">    rdd: <span class="type">RDD</span>[_],</span><br><span class="line">    func: (<span class="type">TaskContext</span>, <span class="type">Iterator</span>[_]) =&gt; _,</span><br><span class="line">    partitions: <span class="type">Array</span>[<span class="type">Int</span>],</span><br><span class="line">    jobId: <span class="type">Int</span>,</span><br><span class="line">    callSite: <span class="type">CallSite</span>): <span class="type">ResultStage</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> parents = getOrCreateParentStages(rdd, jobId)</span><br><span class="line">    <span class="keyword">val</span> id = nextStageId.getAndIncrement()</span><br><span class="line">    <span class="keyword">val</span> stage = <span class="keyword">new</span> <span class="type">ResultStage</span>(id, rdd, func, partitions, parents, jobId, callSite)</span><br><span class="line">    stageIdToStage(id) = stage</span><br><span class="line">    updateJobIdStageIdMaps(jobId, stage)</span><br><span class="line">    stage</span><br><span class="line">&#125;</span><br><span class="line">... ...	</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">getOrCreateParentStages</span></span>(rdd: <span class="type">RDD</span>[_], firstJobId: <span class="type">Int</span>): <span class="type">List</span>[<span class="type">Stage</span>]= &#123;</span><br><span class="line">		getShuffleDependencies(rdd).map &#123; shuffleDep =&gt;getOrCreateShuffleMapStage(shuffleDep, firstJobId)</span><br><span class="line">	&#125;.toList</span><br><span class="line">&#125;</span><br><span class="line">... ...</span><br><span class="line"><span class="keyword">private</span>[scheduler] <span class="function"><span class="keyword">def</span> <span class="title">getShuffleDependencies</span></span>(rdd: <span class="type">RDD</span>[_]): <span class="type">HashSet</span>[<span class="type">ShuffleDependency</span>[_, _, _]] = &#123;</span><br><span class="line">    <span class="keyword">val</span> parents = <span class="keyword">new</span> <span class="type">HashSet</span>[<span class="type">ShuffleDependency</span>[_, _, _]]</span><br><span class="line">    <span class="keyword">val</span> visited = <span class="keyword">new</span> <span class="type">HashSet</span>[<span class="type">RDD</span>[_]]</span><br><span class="line">    <span class="keyword">val</span> waitingForVisit = <span class="keyword">new</span> <span class="type">Stack</span>[<span class="type">RDD</span>[_]]</span><br><span class="line">    waitingForVisit.push(rdd)</span><br><span class="line">    <span class="keyword">while</span> (waitingForVisit.nonEmpty) &#123;</span><br><span class="line">        <span class="keyword">val</span> toVisit = waitingForVisit.pop()</span><br><span class="line">        <span class="keyword">if</span> (!visited(toVisit)) &#123;</span><br><span class="line">            visited += toVisit</span><br><span class="line">            toVisit.dependencies.foreach &#123;</span><br><span class="line">                <span class="keyword">case</span> shuffleDep: <span class="type">ShuffleDependency</span>[_, _, _] =&gt; </span><br><span class="line">                    parents += shuffleDep</span><br><span class="line">                <span class="keyword">case</span> dependency =&gt; </span><br><span class="line">                    waitingForVisit.push(dependency.rdd)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    parents</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="RDD-任务划分"><a href="#RDD-任务划分" class="headerlink" title="RDD 任务划分"></a>RDD 任务划分</h5><p>RDD 任务切分中间分为： Application、 Job、 Stage 和 Task  </p>
<ul>
<li>Application：初始化一个 SparkContext 即生成一个 Application</li>
<li>Job：一个 Action 算子就会生成一个 Job</li>
<li>Stage： Stage 等于宽依赖(ShuffleDependency)的个数加 1</li>
<li>Task：一个 Stage 阶段中，最后一个 RDD 的分区个数就是 Task 的个数（看源码）</li>
</ul>
<blockquote>
<p><strong>注意： Application-&gt;Job-&gt;Stage-&gt;Task 每一层都是 1 对 n 的关系。</strong>  </p>
</blockquote>
<p><img src="/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230920175947360.png" alt="image-20230920175947360"></p>
<p><img src="/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230920182359385.png" alt="image-20230920182359385"></p>
<ul>
<li>任务的数量 = 当前阶段中最后一个RDD的分区数量</li>
<li>ShuffleMapStage =&gt; ShuffleMapTask  例：ShuffleMapStage阶段中任务称之为ShuffleMapTask</li>
<li>ResultStage =&gt; ResultTask 例：ResultStage 阶段中任务称之为ResultTask</li>
</ul>
<h5 id="RDD-任务划分源码"><a href="#RDD-任务划分源码" class="headerlink" title="RDD 任务划分源码"></a>RDD 任务划分源码</h5><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> tasks: <span class="type">Seq</span>[<span class="type">Task</span>[_]] = <span class="keyword">try</span> &#123;</span><br><span class="line">	stage <span class="keyword">match</span> &#123;</span><br><span class="line">		<span class="keyword">case</span> stage: <span class="type">ShuffleMapStage</span> =&gt;</span><br><span class="line">			partitionsToCompute.map &#123; id =&gt;</span><br><span class="line">				<span class="keyword">val</span> locs = taskIdToLocations(id)</span><br><span class="line">				<span class="keyword">val</span> part = stage.rdd.partitions(id)</span><br><span class="line">				<span class="keyword">new</span> <span class="type">ShuffleMapTask</span>(stage.id, stage.latestInfo.attemptId,taskBinary, part, locs, stage.latestInfo.taskMetrics, properties,<span class="type">Option</span>(jobId),<span class="type">Option</span>(sc.applicationId), sc.applicationAttemptId)</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">case</span> stage: <span class="type">ResultStage</span> =&gt;</span><br><span class="line">			partitionsToCompute.map &#123; id =&gt;</span><br><span class="line">				<span class="keyword">val</span> p: <span class="type">Int</span> = stage.partitions(id)</span><br><span class="line">				<span class="keyword">val</span> part = stage.rdd.partitions(p)</span><br><span class="line">				<span class="keyword">val</span> locs = taskIdToLocations(id)</span><br><span class="line">				<span class="keyword">new</span> <span class="type">ResultTask</span>(stage.id, stage.latestInfo.attemptId,taskBinary, part, locs, id, properties, stage.latestInfo.taskMetrics,<span class="type">Option</span>(jobId), <span class="type">Option</span>(sc.applicationId), sc.applicationAttemptId)</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">... ...</span><br><span class="line">    </span><br><span class="line"><span class="keyword">val</span> partitionsToCompute: <span class="type">Seq</span>[<span class="type">Int</span>] = stage.findMissingPartitions()</span><br><span class="line">... ...</span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">findMissingPartitions</span></span>(): <span class="type">Seq</span>[<span class="type">Int</span>] = &#123;</span><br><span class="line">mapOutputTrackerMaster</span><br><span class="line">.findMissingPartitions(shuffleDep.shuffleId)</span><br><span class="line">.getOrElse(<span class="number">0</span> until numPartitions)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="RDD-窄依赖与宽依赖的阶段任务区别"><a href="#RDD-窄依赖与宽依赖的阶段任务区别" class="headerlink" title="RDD 窄依赖与宽依赖的阶段任务区别"></a>RDD 窄依赖与宽依赖的阶段任务区别</h5><p>窄依赖</p>
<p><img src="/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230920183046400.png" alt="image-20230920183046400"></p>
<p>宽依赖</p>
<p><img src="/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230920183224156.png" alt="image-20230920183224156"></p>
<h4 id="5-1-4-8-RDD-持久化"><a href="#5-1-4-8-RDD-持久化" class="headerlink" title="5.1.4.8 RDD 持久化"></a>5.1.4.8 RDD 持久化</h4><p>RDD对象复用</p>
<p><img src="/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230921174728434.png" alt="image-20230921174728434"></p>
<ul>
<li>RDD中不存储数据</li>
<li>如果一个RDD需要重复使用，那么需要从头再次执行来获取数据</li>
<li>RDD对象可以重用的，但是数据无法重用</li>
</ul>
<p>RDD数据持久化</p>
<p><img src="/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230921175401894.png" alt="image-20230921175401894"></p>
<ul>
<li>RDD对象的持久化操作不一定是为了重用</li>
<li>在数据执行较长，或数据比较重要的场合也可以采用持久化操作</li>
</ul>
<h5 id="RDD-Cache-缓存"><a href="#RDD-Cache-缓存" class="headerlink" title="RDD Cache 缓存"></a>RDD Cache 缓存</h5><p>RDD 通过 Cache 或者 Persist 方法将前面的计算结果缓存，默认情况下会把数据以缓存在 JVM 的堆内存中。但是并不是这两个方法被调用时立即缓存，而是触发后面的 action 算子时，该 RDD 将会被缓存在计算节点的内存中，并供后面重用。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// cache 操作会增加血缘关系，不改变原有的血缘关系</span></span><br><span class="line">println(wordToOneRdd.toDebugString)</span><br><span class="line"><span class="comment">// 数据缓存。</span></span><br><span class="line">wordToOneRdd.cache()</span><br><span class="line"><span class="comment">// 可以更改存储级别</span></span><br><span class="line"><span class="comment">//mapRdd.persist(StorageLevel.MEMORY_AND_DISK_2)</span></span><br></pre></td></tr></table></figure>

<p>存储级别  </p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">StorageLevel</span> </span>&#123;</span><br><span class="line"><span class="keyword">val</span> <span class="type">NONE</span> = <span class="keyword">new</span> <span class="type">StorageLevel</span>(<span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>)</span><br><span class="line"><span class="keyword">val</span> <span class="type">DISK_ONLY</span> = <span class="keyword">new</span> <span class="type">StorageLevel</span>(<span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>)</span><br><span class="line"><span class="keyword">val</span> <span class="type">DISK_ONLY_2</span> = <span class="keyword">new</span> <span class="type">StorageLevel</span>(<span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="number">2</span>)</span><br><span class="line"><span class="keyword">val</span> <span class="type">MEMORY_ONLY</span> = <span class="keyword">new</span> <span class="type">StorageLevel</span>(<span class="literal">false</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">true</span>)</span><br><span class="line"><span class="keyword">val</span> <span class="type">MEMORY_ONLY_2</span> = <span class="keyword">new</span> <span class="type">StorageLevel</span>(<span class="literal">false</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">true</span>, <span class="number">2</span>)</span><br><span class="line"><span class="keyword">val</span> <span class="type">MEMORY_ONLY_SER</span> = <span class="keyword">new</span> <span class="type">StorageLevel</span>(<span class="literal">false</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>)</span><br><span class="line"><span class="keyword">val</span> <span class="type">MEMORY_ONLY_SER_2</span> = <span class="keyword">new</span> <span class="type">StorageLevel</span>(<span class="literal">false</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="number">2</span>)</span><br><span class="line"><span class="keyword">val</span> <span class="type">MEMORY_AND_DISK</span> = <span class="keyword">new</span> <span class="type">StorageLevel</span>(<span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">true</span>)</span><br><span class="line"><span class="keyword">val</span> <span class="type">MEMORY_AND_DISK_2</span> = <span class="keyword">new</span> <span class="type">StorageLevel</span>(<span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">true</span>, <span class="number">2</span>)</span><br><span class="line"><span class="keyword">val</span> <span class="type">MEMORY_AND_DISK_SER</span> = <span class="keyword">new</span> <span class="type">StorageLevel</span>(<span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>)</span><br><span class="line"><span class="keyword">val</span> <span class="type">MEMORY_AND_DISK_SER_2</span> = <span class="keyword">new</span> <span class="type">StorageLevel</span>(<span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="number">2</span>)</span><br><span class="line"><span class="keyword">val</span> <span class="type">OFF_HEAP</span> = <span class="keyword">new</span> <span class="type">StorageLevel</span>(<span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<p><img src="/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20230921172651650.png" alt="image-20230921172651650"></p>
<p>缓存有可能丢失，或者存储于内存的数据由于内存不足而被删除， RDD 的缓存容错机制保证了即使缓存丢失也能保证计算的正确执行。通过基于 RDD 的一系列转换，丢失的数据会被重算，由于 RDD 的各个 Partition 是相对独立的，因此只需要计算丢失的部分即可，并不需要重算全部 Partition。<br>Spark 会自动对一些 Shuffle 操作的中间数据做持久化操作(比如： reduceByKey)。这样做的目的是为了当一个节点 Shuffle 失败了避免重新计算整个输入。但是，在实际使用的时候，如果想重用数据，仍然建议调用 persist 或 cache。</p>
<p>练习与测试</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spark.core.rdd.persist</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.storage.<span class="type">StorageLevel</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Spark01_RDD_Persist</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">"local"</span>).setAppName(<span class="string">"WordCount"</span>)</span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(sparkConf)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO RDD的数据持久化操作-cache-persist</span></span><br><span class="line">    <span class="keyword">val</span> rdd = sc.makeRDD(<span class="type">List</span>(<span class="string">"Hello Scala"</span>, <span class="string">"Hello Spark"</span>))</span><br><span class="line">    <span class="keyword">val</span> flatRDD = rdd.flatMap(_.split(<span class="string">" "</span>))</span><br><span class="line">    <span class="keyword">val</span> mapRDD = flatRDD.map(word =&gt; &#123;</span><br><span class="line">      println(<span class="string">"======"</span>)</span><br><span class="line">      (word, <span class="number">1</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 数据持久化</span></span><br><span class="line">    <span class="comment">// 默认持久化只能将数据保存到内存中，如果想要保存到磁盘文件，需要更改存储级别</span></span><br><span class="line">    <span class="comment">// mapRDD.cache() // 默认保存到内存，与下面persist()方法不带参数一样的效果</span></span><br><span class="line">    <span class="comment">// mapRDD.persist()</span></span><br><span class="line">    <span class="comment">// 持久化操作必须在行动算子执行时完成的</span></span><br><span class="line">    <span class="comment">// RDD对象的持久化操作不一定是为了重用，在数据执行较长，或数据比较重要的场合也可以采用持久化操作</span></span><br><span class="line">    <span class="comment">// 避免流程较长和或者流程非常复杂的情况，因为一旦出现了问题，从头走流程的时候需要耗时的时间较长，所以把耗时较长，或者比较重要的数据进行持久化，性能和安全都能得到保障</span></span><br><span class="line">    mapRDD.persist(<span class="type">StorageLevel</span>.<span class="type">DISK_ONLY</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> reduceRDD = mapRDD.reduceByKey(_ + _)</span><br><span class="line">    reduceRDD.collect().foreach(println)</span><br><span class="line">    println(<span class="string">"*********************"</span>)</span><br><span class="line">    <span class="comment">// 如果上面不设置持久化操作，则重复执行并打印"======"</span></span><br><span class="line">    <span class="comment">// RDD不存储数据。如果一个RDD需要重复使用，那么需要从头再次执行来获取数据</span></span><br><span class="line">    <span class="comment">// RDD对象可以重用，但是数据无法重用</span></span><br><span class="line">    <span class="keyword">val</span> reduceRDD1 = mapRDD.groupByKey()</span><br><span class="line">    reduceRDD1.collect().foreach(println)</span><br><span class="line"></span><br><span class="line">    sc.stop()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="RDD-CheckPoint-检查点"><a href="#RDD-CheckPoint-检查点" class="headerlink" title="RDD CheckPoint 检查点"></a>RDD CheckPoint 检查点</h5><p>所谓的检查点其实就是通过将 RDD 中间结果写入磁盘，由于血缘依赖过长会造成容错成本过高，这样就不如在中间阶段做检查点容错，如果检查点之后有节点出现问题， 可以从检查点开始重做血缘，减少了开销。对 RDD 进行 checkpoint 操作并不会马上被执行，必须执行 Action 操作才能触发。  </p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 设置检查点路径</span></span><br><span class="line">sc.setCheckpointDir(<span class="string">"./checkpoint1"</span>)</span><br><span class="line"><span class="comment">// 创建一个 RDD，读取指定位置文件:hello atguigu atguigu</span></span><br><span class="line"><span class="keyword">val</span> lineRdd: <span class="type">RDD</span>[<span class="type">String</span>] = sc.textFile(<span class="string">"input/1.txt"</span>)</span><br><span class="line"><span class="comment">// 业务逻辑</span></span><br><span class="line"><span class="keyword">val</span> wordRdd: <span class="type">RDD</span>[<span class="type">String</span>] = lineRdd.flatMap(line =&gt; line.split(<span class="string">" "</span>))</span><br><span class="line"><span class="keyword">val</span> wordToOneRdd: <span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">Long</span>)] = wordRdd.map &#123;</span><br><span class="line">	word =&gt; &#123;</span><br><span class="line">    	(word, <span class="type">System</span>.currentTimeMillis())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 增加缓存,避免再重新跑一个 job 做 checkpoint</span></span><br><span class="line">wordToOneRdd.cache()</span><br><span class="line"><span class="comment">// 数据检查点：针对 wordToOneRdd 做检查点计算</span></span><br><span class="line">wordToOneRdd.checkpoint()</span><br><span class="line"><span class="comment">// 触发执行逻辑</span></span><br><span class="line">wordToOneRdd.collect().foreach(println)</span><br></pre></td></tr></table></figure>

<h5 id="缓存和检查点区别"><a href="#缓存和检查点区别" class="headerlink" title="缓存和检查点区别"></a>缓存和检查点区别</h5><p>1）Cache 缓存只是将数据保存起来，不切断血缘依赖。 Checkpoint 检查点切断血缘依赖。<br>2）Cache 缓存的数据通常存储在磁盘、内存等地方，可靠性低。 Checkpoint 的数据通常存储在 HDFS 等容错、高可用的文件系统，可靠性高。<br>3）建议对 checkpoint()的 RDD 使用 Cache 缓存，这样 checkpoint 的 job 只需从 Cache 缓存中读取数据即可，否则需要再从头计算一次 RDD。</p>
<p>练习与测试</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spark.core.rdd.persist</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Spark02_RDD_Persist</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">"local"</span>).setAppName(<span class="string">"WordCount"</span>)</span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(sparkConf)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO RDD的数据持久化操作-checkpoint</span></span><br><span class="line">    <span class="comment">// 设置检查点保存路径</span></span><br><span class="line">    sc.setCheckpointDir(<span class="string">"cp"</span>)</span><br><span class="line">    <span class="keyword">val</span> rdd = sc.makeRDD(<span class="type">List</span>(<span class="string">"Hello Scala"</span>, <span class="string">"Hello Spark"</span>))</span><br><span class="line">    <span class="keyword">val</span> flatRDD = rdd.flatMap(_.split(<span class="string">" "</span>))</span><br><span class="line">    <span class="keyword">val</span> mapRDD = flatRDD.map(word =&gt; &#123;</span><br><span class="line">      println(<span class="string">"======"</span>)</span><br><span class="line">      (word, <span class="number">1</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// checkpoint：需要落盘，需要指定检查点保存路径</span></span><br><span class="line">    <span class="comment">// 检查点路径保存的文件，当作业执行完毕后，不会被删除，而persist如果设置数据落盘，则只是保存临时文件，任务执行完毕会自动删除临时文件</span></span><br><span class="line">    <span class="comment">// 一般保存路径都是在分布式存储系统中，比如：HDFS</span></span><br><span class="line">    mapRDD.checkpoint()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> reduceRDD = mapRDD.reduceByKey(_ + _)</span><br><span class="line">    reduceRDD.collect().foreach(println)</span><br><span class="line">    println(<span class="string">"*********************"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> reduceRDD1 = mapRDD.groupByKey()</span><br><span class="line">    reduceRDD1.collect().foreach(println)</span><br><span class="line"></span><br><span class="line">    sc.stop()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spark.core.rdd.persist</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Spark03_RDD_Persist</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">"local"</span>).setAppName(<span class="string">"WordCount"</span>)</span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(sparkConf)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO RDD的数据持久化操作-cache/persist 和 checkpoint 的区别</span></span><br><span class="line">    <span class="comment">// cache：</span></span><br><span class="line">    <span class="comment">//    将数据临时存储在内存中进行数据重用</span></span><br><span class="line">    <span class="comment">//    数据不安全。如：内存溢出，数据移除，内存重启等</span></span><br><span class="line">    <span class="comment">// persist：</span></span><br><span class="line">    <span class="comment">//    将数据临时存储在磁盘文件中进行数据重用</span></span><br><span class="line">    <span class="comment">//    涉及到磁盘IO，性能较低，但是数据安全，如果作业执行完毕，临时保存的数据文件就会丢失</span></span><br><span class="line">    <span class="comment">// checkpoint：</span></span><br><span class="line">    <span class="comment">//    将数据长久地保存在磁盘文件汇总进行数据重用</span></span><br><span class="line">    <span class="comment">//    涉及到磁盘IO，性能较低，但是数据安全，为了保证数据安全</span></span><br><span class="line">    <span class="comment">//    所以一般情况下，会独立执行作业(从头开始再执行一次)，为了能够提高效率，一般情况下，是需要和cache联合使用</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置检查点保存路径</span></span><br><span class="line">    sc.setCheckpointDir(<span class="string">"cp"</span>)</span><br><span class="line">    <span class="keyword">val</span> rdd = sc.makeRDD(<span class="type">List</span>(<span class="string">"Hello Scala"</span>, <span class="string">"Hello Spark"</span>))</span><br><span class="line">    <span class="keyword">val</span> flatRDD = rdd.flatMap(_.split(<span class="string">" "</span>))</span><br><span class="line">    <span class="keyword">val</span> mapRDD = flatRDD.map(word =&gt; &#123;</span><br><span class="line">      println(<span class="string">"======"</span>)</span><br><span class="line">      (word, <span class="number">1</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 联合使用，避免任务独立执行从头开始再执行一次，直接用内存中取数据，提高效率</span></span><br><span class="line">    mapRDD.cache()</span><br><span class="line">    mapRDD.checkpoint()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> reduceRDD = mapRDD.reduceByKey(_ + _)</span><br><span class="line">    reduceRDD.collect().foreach(println)</span><br><span class="line">    println(<span class="string">"*********************"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> reduceRDD1 = mapRDD.groupByKey()</span><br><span class="line">    reduceRDD1.collect().foreach(println)</span><br><span class="line"></span><br><span class="line">    sc.stop()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spark.core.rdd.persist</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Spark04_RDD_Persist</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">"local"</span>).setAppName(<span class="string">"WordCount"</span>)</span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(sparkConf)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO RDD的数据持久化操作-cache/persist 和 checkpoint 的区别2</span></span><br><span class="line">    <span class="comment">// cache：</span></span><br><span class="line">    <span class="comment">//    将数据临时存储在内存中进行数据重用</span></span><br><span class="line">    <span class="comment">//    数据不安全。如：内存溢出，数据移除，内存重启等</span></span><br><span class="line">    <span class="comment">//    会在血缘关系中添加新的依赖,一旦出现问题（比如内存失效），可以重头读取数据</span></span><br><span class="line">    <span class="comment">// persist：</span></span><br><span class="line">    <span class="comment">//    将数据临时存储在磁盘文件中进行数据重用</span></span><br><span class="line">    <span class="comment">//    涉及到磁盘IO，性能较低，但是数据安全，如果作业执行完毕，临时保存的数据文件就会丢失</span></span><br><span class="line">    <span class="comment">//    会在血缘关系中添加新的依赖,一旦出现问题（比如内存失效），可以重头读取数据</span></span><br><span class="line">    <span class="comment">// checkpoint：</span></span><br><span class="line">    <span class="comment">//    将数据长久地保存在磁盘文件汇总进行数据重用</span></span><br><span class="line">    <span class="comment">//    涉及到磁盘IO，性能较低，但是数据安全，为了保证数据安全</span></span><br><span class="line">    <span class="comment">//    所以一般情况下，会独立执行作业(会重复打印)，为了能够提高效率，一般情况下，是需要和cache联合使用</span></span><br><span class="line">    <span class="keyword">val</span> rdd = sc.makeRDD(<span class="type">List</span>(<span class="string">"Hello Scala"</span>, <span class="string">"Hello Spark"</span>))</span><br><span class="line">    <span class="keyword">val</span> flatRDD = rdd.flatMap(_.split(<span class="string">" "</span>))</span><br><span class="line">    <span class="keyword">val</span> mapRDD = flatRDD.map(word =&gt; &#123;</span><br><span class="line">      (word, <span class="number">1</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    mapRDD.cache()</span><br><span class="line">    println(mapRDD.toDebugString)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> reduceRDD = mapRDD.reduceByKey(_ + _)</span><br><span class="line">    reduceRDD.collect().foreach(println)</span><br><span class="line">    println(<span class="string">"*********************"</span>)</span><br><span class="line">    println(mapRDD.toDebugString)</span><br><span class="line"></span><br><span class="line">    sc.stop()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spark.core.rdd.persist</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Spark05_RDD_Persist</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">"local"</span>).setAppName(<span class="string">"WordCount"</span>)</span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(sparkConf)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO RDD的数据持久化操作-cache/persist 和 checkpoint 的区别3</span></span><br><span class="line">    <span class="comment">// cache：</span></span><br><span class="line">    <span class="comment">//    将数据临时存储在内存中进行数据重用</span></span><br><span class="line">    <span class="comment">//    数据不安全。如：内存溢出，数据移除，内存重启等</span></span><br><span class="line">    <span class="comment">//    会在血缘关系中添加新的依赖,一旦出现问题（比如内存失效），可以重头读取数据</span></span><br><span class="line">    <span class="comment">// persist：</span></span><br><span class="line">    <span class="comment">//    将数据临时存储在磁盘文件中进行数据重用</span></span><br><span class="line">    <span class="comment">//    涉及到磁盘IO，性能较低，但是数据安全，如果作业执行完毕，临时保存的数据文件就会丢失</span></span><br><span class="line">    <span class="comment">//    会在血缘关系中添加新的依赖,一旦出现问题（比如内存失效），可以重头读取数据</span></span><br><span class="line">    <span class="comment">// checkpoint：</span></span><br><span class="line">    <span class="comment">//    将数据长久地保存在磁盘文件汇总进行数据重用</span></span><br><span class="line">    <span class="comment">//    涉及到磁盘IO，性能较低，但是数据安全，为了保证数据安全</span></span><br><span class="line">    <span class="comment">//    所以一般情况下，会独立执行作业(会重复打印)，为了能够提高效率，一般情况下，是需要和cache联合使用</span></span><br><span class="line">    <span class="comment">//    执行过程中，会切断血缘关系，会重新建立新的血缘关系</span></span><br><span class="line">    <span class="comment">//    checkpoint等同于改变了数据源(相当于从检查点开始执行，因此可以看做数据源发生了改变，因此血缘关系也发生改变)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置检查点保存路径</span></span><br><span class="line">    sc.setCheckpointDir(<span class="string">"cp"</span>)</span><br><span class="line">    <span class="keyword">val</span> rdd = sc.makeRDD(<span class="type">List</span>(<span class="string">"Hello Scala"</span>, <span class="string">"Hello Spark"</span>))</span><br><span class="line">    <span class="keyword">val</span> flatRDD = rdd.flatMap(_.split(<span class="string">" "</span>))</span><br><span class="line">    <span class="keyword">val</span> mapRDD = flatRDD.map(word =&gt; &#123;</span><br><span class="line">      (word, <span class="number">1</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    mapRDD.checkpoint()</span><br><span class="line">    println(mapRDD.toDebugString)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> reduceRDD = mapRDD.reduceByKey(_ + _)</span><br><span class="line">    reduceRDD.collect().foreach(println)</span><br><span class="line">    println(<span class="string">"*********************"</span>)</span><br><span class="line">    println(mapRDD.toDebugString)</span><br><span class="line"></span><br><span class="line">    sc.stop()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-1-4-9-RDD-分区器"><a href="#5-1-4-9-RDD-分区器" class="headerlink" title="5.1.4.9 RDD 分区器"></a>5.1.4.9 RDD 分区器</h4><p>Spark 目前支持 Hash 分区和 Range 分区，和用户自定义分区。Hash 分区为当前的默认分区。分区器直接决定了 RDD 中分区的个数、 RDD 中每条数据经过 Shuffle 后进入哪个分区，进而决定了 Reduce 的个数。</p>
<ul>
<li>只有 Key-Value 类型的 RDD 才有分区器，非 Key-Value 类型的 RDD 分区的值是 None</li>
<li>每个 RDD 的分区 ID 范围： 0 ~ (numPartitions - 1)，决定这个值是属于那个分区的</li>
</ul>
<p>1) Hash 分区：对于给定的 key，计算其 hashCode,并除以分区个数取余</p>
   <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HashPartitioner</span>(<span class="params">partitions: <span class="type">Int</span></span>) <span class="keyword">extends</span> <span class="title">Partitioner</span> </span>&#123;</span><br><span class="line">	require(partitions &gt;= <span class="number">0</span>, <span class="string">s"Number of partitions (<span class="subst">$partitions</span>) cannot be negative."</span>)</span><br><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">numPartitions</span></span>: <span class="type">Int</span> = partitions</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getPartition</span></span>(key: <span class="type">Any</span>): <span class="type">Int</span> = key <span class="keyword">match</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="literal">null</span> =&gt; <span class="number">0</span></span><br><span class="line">        <span class="keyword">case</span> _ =&gt; <span class="type">Utils</span>.nonNegativeMod(key.hashCode, numPartitions)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">equals</span></span>(other: <span class="type">Any</span>): <span class="type">Boolean</span> = other <span class="keyword">match</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> h: <span class="type">HashPartitioner</span> =&gt;</span><br><span class="line">            h.numPartitions == numPartitions</span><br><span class="line">        <span class="keyword">case</span> _ =&gt;</span><br><span class="line">            <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">hashCode</span></span>: <span class="type">Int</span> = numPartitions</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2) Range 分区：将一定范围内的数据映射到一个分区中，尽量保证每个分区数据均匀，而且分区间有序</p>
   <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RangePartitioner</span>[<span class="type">K</span>: <span class="type">Ordering</span> : <span class="type">ClassTag</span>, <span class="type">V</span>](<span class="params">partitions: <span class="type">Int</span>,rdd: <span class="type">RDD</span>[_ &lt;: <span class="type">Product2</span>[<span class="type">K</span>, <span class="type">V</span>]],private var ascending: <span class="type">Boolean</span> = true</span>) <span class="keyword">extends</span> <span class="title">Partitioner</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// We allow partitions = 0, which happens when sorting an empty RDD under the</span></span><br><span class="line">    <span class="keyword">default</span> settings</span><br><span class="line">    .</span><br><span class="line">    require(partitions &gt;= <span class="number">0</span>, <span class="string">s"Number of partitions cannot be negative but found</span></span><br><span class="line"><span class="string">    <span class="subst">$partitions</span></span></span><br><span class="line"><span class="string">    ."</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> ordering = implicitly[<span class="type">Ordering</span>[<span class="type">K</span>]]</span><br><span class="line">    <span class="comment">// An array of upper bounds for the first (partitions - 1) partitions</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> rangeBounds: <span class="type">Array</span>[<span class="type">K</span>] = &#123;</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">numPartitions</span></span>: <span class="type">Int</span> = rangeBounds.length + <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> binarySearch: ((<span class="type">Array</span>[<span class="type">K</span>], <span class="type">K</span>) =&gt; <span class="type">Int</span>) =</span><br><span class="line">    <span class="type">CollectionsUtils</span>.makeBinarySearch[<span class="type">K</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getPartition</span></span>(key: <span class="type">Any</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> k = key.asInstanceOf[<span class="type">K</span>]</span><br><span class="line">    <span class="keyword">var</span> partition = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> (rangeBounds.length &lt;= <span class="number">128</span>) &#123;</span><br><span class="line">      <span class="comment">// If we have less than 128 partitions naive search</span></span><br><span class="line">      <span class="keyword">while</span> (partition &lt; rangeBounds.length &amp;&amp; ordering.gt(k,</span><br><span class="line">        rangeBounds(partition))) &#123;</span><br><span class="line">        partition += <span class="number">1</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Determine which binary search method to use only once.</span></span><br><span class="line">      partition = binarySearch(rangeBounds, k)</span><br><span class="line">      <span class="comment">// binarySearch either returns the match location or -[insertion point]-1</span></span><br><span class="line">      <span class="keyword">if</span> (partition &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        partition = -partition - <span class="number">1</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (partition &gt; rangeBounds.length) &#123;</span><br><span class="line">        partition = rangeBounds.length</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ascending) &#123;</span><br><span class="line">      partition</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      rangeBounds.length - partition</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">equals</span></span>(other: <span class="type">Any</span>): <span class="type">Boolean</span> = other <span class="keyword">match</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">hashCode</span></span>(): <span class="type">Int</span> = &#123;</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@throws</span>(classOf[<span class="type">IOException</span>])</span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">writeObject</span></span>(out: <span class="type">ObjectOutputStream</span>): <span class="type">Unit</span> =</span><br><span class="line">    <span class="type">Utils</span>.tryOrIOException &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@throws</span>(classOf[<span class="type">IOException</span>])</span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">readObject</span></span>(in: <span class="type">ObjectInputStream</span>): <span class="type">Unit</span> = <span class="type">Utils</span>.tryOrIOException &#123;</span><br><span class="line">    ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>练习与测试</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spark.core.rdd.part</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">Partitioner</span>, <span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Spark01_RDD_Part</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">"local[*]"</span>).setAppName(<span class="string">"WordCount"</span>)</span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(sparkConf)</span><br><span class="line">    <span class="keyword">val</span> rdd = sc.makeRDD(<span class="type">List</span>(</span><br><span class="line">      (<span class="string">"nba"</span>, <span class="string">"科比"</span>),</span><br><span class="line">      (<span class="string">"cba"</span>, <span class="string">"姚明"</span>),</span><br><span class="line">      (<span class="string">"wnba"</span>, <span class="string">"无"</span>),</span><br><span class="line">      (<span class="string">"nba"</span>, <span class="string">"詹姆斯"</span>)</span><br><span class="line">    ))</span><br><span class="line">    <span class="keyword">val</span> partRDD = rdd.partitionBy(<span class="keyword">new</span> <span class="type">MyPartitioner</span>)</span><br><span class="line">    partRDD.saveAsTextFile(<span class="string">"output"</span>)</span><br><span class="line">    sc.stop()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 自定义分区器</span></span><br><span class="line">  <span class="comment">// 1. 集成Partitioner</span></span><br><span class="line">  <span class="comment">// 2. 重写方法</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">MyPartitioner</span> <span class="keyword">extends</span> <span class="title">Partitioner</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 分区数量</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">numPartitions</span></span>: <span class="type">Int</span> = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回数据的分区索引（从0开始）</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">getPartition</span></span>(key: <span class="type">Any</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">      key <span class="keyword">match</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">"nba"</span> =&gt; <span class="number">0</span></span><br><span class="line">        <span class="keyword">case</span> <span class="string">"cba"</span> =&gt; <span class="number">1</span></span><br><span class="line">        <span class="keyword">case</span> _ =&gt; <span class="number">2</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-1-4-10-RDD-文件读取与保存"><a href="#5-1-4-10-RDD-文件读取与保存" class="headerlink" title="5.1.4.10 RDD 文件读取与保存"></a>5.1.4.10 RDD 文件读取与保存</h4><p>Spark 的数据读取及数据保存可以从两个维度来作区分：文件格式以及文件系统。文件格式分为： text 文件、 csv 文件、 sequence 文件以及 Object 文件；文件系统分为：本地文件系统、 HDFS、 HBASE 以及数据库。  </p>
<ul>
<li><p>text 文件  </p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取输入文件</span></span><br><span class="line"><span class="keyword">val</span> inputRDD: <span class="type">RDD</span>[<span class="type">String</span>] = sc.textFile(<span class="string">"input/1.txt"</span>)</span><br><span class="line"><span class="comment">// 保存数据</span></span><br><span class="line">inputRDD.saveAsTextFile(<span class="string">"output"</span>)</span><br></pre></td></tr></table></figure>
</li>
<li><p>sequence 文件  </p>
<p>SequenceFile 文件是 Hadoop 用来存储二进制形式的 key-value 对而设计的一种平面文件(FlatFile)。 在 SparkContext 中，可以调用 <code>sequenceFile[keyClass, valueClass](path)</code></p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 保存数据为 SequenceFile</span></span><br><span class="line">dataRDD.saveAsSequenceFile(<span class="string">"output"</span>)</span><br><span class="line"><span class="comment">// 读取 SequenceFile 文件</span></span><br><span class="line">sc.sequenceFile[<span class="type">Int</span>,<span class="type">Int</span>](<span class="string">"output"</span>).collect().foreach(println)</span><br></pre></td></tr></table></figure>
</li>
<li><p>object 对象文件</p>
<p>对象文件是将对象序列化后保存的文件，采用 Java 的序列化机制。 可以通过 <code>objectFile[T:ClassTag](path)</code>函数接收一个路径， 读取对象文件， 返回对应的 RDD， 也可以通过调用<code>saveAsObjectFile()</code>实现对对象文件的输出。因为是序列化所以要指定类型。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 保存数据</span></span><br><span class="line">dataRDD.saveAsObjectFile(<span class="string">"output"</span>)</span><br><span class="line"><span class="comment">// 读取数据</span></span><br><span class="line">sc.objectFile[<span class="type">Int</span>](<span class="string">"output"</span>).collect().foreach(println)</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>练习与测试</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spark.core.rdd.io</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Spark01_RDD_IO_Save</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">"local"</span>).setAppName(<span class="string">"WordCount"</span>)</span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(sparkConf)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 文件数据保存</span></span><br><span class="line">    <span class="keyword">val</span> rdd = sc.makeRDD(<span class="type">List</span>(</span><br><span class="line">      (<span class="string">"a"</span>, <span class="number">1</span>),</span><br><span class="line">      (<span class="string">"b"</span>, <span class="number">2</span>),</span><br><span class="line">      (<span class="string">"c"</span>, <span class="number">3</span>)</span><br><span class="line">    ))</span><br><span class="line"></span><br><span class="line">    rdd.saveAsTextFile(<span class="string">"output1"</span>)</span><br><span class="line">    rdd.saveAsObjectFile(<span class="string">"output2"</span>)</span><br><span class="line">    rdd.saveAsSequenceFile(<span class="string">"output3"</span>)</span><br><span class="line">    sc.stop()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spark.core.rdd.io</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Spark01_RDD_IO_Load</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">"local"</span>).setAppName(<span class="string">"WordCount"</span>)</span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(sparkConf)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 文件数据加载</span></span><br><span class="line">    <span class="keyword">val</span> rdd1 = sc.textFile(<span class="string">"output1"</span>)</span><br><span class="line">    println(rdd1.collect().mkString(<span class="string">","</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> rdd2 = sc.objectFile[(<span class="type">String</span>, <span class="type">Int</span>)](<span class="string">"output2"</span>)</span><br><span class="line">    println(rdd2.collect().mkString(<span class="string">","</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意泛型是键值类型</span></span><br><span class="line">    <span class="keyword">val</span> rdd3 = sc.sequenceFile[<span class="type">String</span>, <span class="type">Int</span>](<span class="string">"output3"</span>)</span><br><span class="line">    println(rdd3.collect().mkString(<span class="string">","</span>))</span><br><span class="line"></span><br><span class="line">    sc.stop()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-2-累加器"><a href="#5-2-累加器" class="headerlink" title="5.2 累加器"></a>5.2 累加器</h2><h3 id="5-2-1-实现原理"><a href="#5-2-1-实现原理" class="headerlink" title="5.2.1 实现原理"></a>5.2.1 实现原理</h3><p>累加器用来把 Executor 端变量信息聚合到 Driver 端。在 Driver 程序中定义的变量，在Executor 端的每个 Task 都会得到这个变量的一份新的副本，每个 task 更新这些副本的值后，传回 Driver 端进行 merge。</p>
<p><img src="/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20231010154154383.png" alt="image-20231010154154383"></p>
<h3 id="5-2-2-基础编程"><a href="#5-2-2-基础编程" class="headerlink" title="5.2.2 基础编程"></a>5.2.2 基础编程</h3><h4 id="5-2-2-1-系统累加器"><a href="#5-2-2-1-系统累加器" class="headerlink" title="5.2.2.1 系统累加器"></a>5.2.2.1 系统累加器</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> rdd = sc.makeRDD(<span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>))</span><br><span class="line"><span class="comment">// 声明累加器</span></span><br><span class="line"><span class="keyword">var</span> sum = sc.longAccumulator(<span class="string">"sum"</span>);</span><br><span class="line">rdd.foreach(</span><br><span class="line">    num =&gt; &#123;</span><br><span class="line">        <span class="comment">// 使用累加器</span></span><br><span class="line">        sum.add(num)</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"><span class="comment">// 获取累加器的值</span></span><br><span class="line">println(<span class="string">"sum = "</span> + sum.value)</span><br></pre></td></tr></table></figure>

<h4 id="5-2-2-2-自定义累加器"><a href="#5-2-2-2-自定义累加器" class="headerlink" title="5.2.2.2 自定义累加器"></a>5.2.2.2 自定义累加器</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自定义累加器</span></span><br><span class="line"><span class="comment">// 1. 继承 AccumulatorV2，并设定泛型</span></span><br><span class="line"><span class="comment">// 2. 重写累加器的抽象方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WordCountAccumulator</span> <span class="keyword">extends</span> <span class="title">AccumulatorV2</span>[<span class="type">String</span>, mutable.<span class="type">Map</span>[<span class="type">String</span>,</span></span><br><span class="line"><span class="class"><span class="type">Long</span>]]</span>&#123;</span><br><span class="line"><span class="keyword">var</span> map : mutable.<span class="type">Map</span>[<span class="type">String</span>, <span class="type">Long</span>] = mutable.<span class="type">Map</span>()</span><br><span class="line"><span class="comment">// 累加器是否为初始状态</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">isZero</span></span>: <span class="type">Boolean</span> = &#123;</span><br><span class="line">	map.isEmpty</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 复制累加器</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">copy</span></span>(): <span class="type">AccumulatorV2</span>[<span class="type">String</span>, mutable.<span class="type">Map</span>[<span class="type">String</span>, <span class="type">Long</span>]] = &#123;</span><br><span class="line">	<span class="keyword">new</span> <span class="type">WordCountAccumulator</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 重置累加器</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">reset</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">	map.clear()</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 向累加器中增加数据 (In)</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">add</span></span>(word: <span class="type">String</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">// 查询 map 中是否存在相同的单词</span></span><br><span class="line">    <span class="comment">// 如果有相同的单词，那么单词的数量加 1</span></span><br><span class="line">    <span class="comment">// 如果没有相同的单词，那么在 map 中增加这个单词</span></span><br><span class="line">    map(word) = map.getOrElse(word, <span class="number">0</span>L) + <span class="number">1</span>L</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 合并累加器</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">merge</span></span>(other: <span class="type">AccumulatorV2</span>[<span class="type">String</span>, mutable.<span class="type">Map</span>[<span class="type">String</span>, <span class="type">Long</span>]]):</span><br><span class="line"><span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> map1 = map</span><br><span class="line">    <span class="keyword">val</span> map2 = other.value</span><br><span class="line">    <span class="comment">// 两个 Map 的合并</span></span><br><span class="line">    map = map1.foldLeft(map2)(</span><br><span class="line">        ( innerMap, kv ) =&gt; &#123;</span><br><span class="line">            innerMap(kv._1) = innerMap.getOrElse(kv._1, <span class="number">0</span>L) + kv._2</span><br><span class="line">            innerMap</span><br><span class="line">        &#125;</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回累加器的结果 （Out）</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">value</span></span>: mutable.<span class="type">Map</span>[<span class="type">String</span>, <span class="type">Long</span>] = map</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>练习与测试</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spark.core.acc</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Spark01_Acc</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">"local"</span>).setAppName(<span class="string">"WordCount"</span>)</span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(sparkConf)</span><br><span class="line">    <span class="comment">// TODO 探究为什么不能累加</span></span><br><span class="line">    <span class="keyword">val</span> rdd = sc.makeRDD(<span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line"></span><br><span class="line">    <span class="comment">// val i = rdd.reduce(_ + _)</span></span><br><span class="line">    <span class="keyword">var</span> sum = <span class="number">0</span></span><br><span class="line">    rdd.foreach(num =&gt; &#123;</span><br><span class="line">      sum += num</span><br><span class="line">    &#125;)</span><br><span class="line">    println(<span class="string">"sum: "</span> + sum)</span><br><span class="line"></span><br><span class="line">    sc.stop()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spark.core.acc</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Spark02_Acc</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">"local"</span>).setAppName(<span class="string">"WordCount"</span>)</span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(sparkConf)</span><br><span class="line">    <span class="comment">// TODO 使用系统累加器</span></span><br><span class="line">    <span class="keyword">val</span> rdd = sc.makeRDD(<span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line">    <span class="comment">// 获取系统累加器</span></span><br><span class="line">    <span class="comment">// Spark默认就提供简单数据聚合的累加器</span></span><br><span class="line">    <span class="keyword">val</span> sumAcc = sc.longAccumulator(<span class="string">"sum"</span>)</span><br><span class="line">    <span class="comment">// 此外还有其他不同类型的累加器</span></span><br><span class="line">    <span class="comment">// sc.doubleAccumulator("")</span></span><br><span class="line">    <span class="comment">// sc.collectionAccumulator("")</span></span><br><span class="line">    rdd.foreach(num =&gt; &#123;</span><br><span class="line">      <span class="comment">// 使用累加器</span></span><br><span class="line">      sumAcc.add(num)</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取累加器的值</span></span><br><span class="line">    println(sumAcc.value)</span><br><span class="line">    sc.stop()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spark.core.acc</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Spark03_Acc</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">"local"</span>).setAppName(<span class="string">"WordCount"</span>)</span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(sparkConf)</span><br><span class="line">    <span class="comment">// TODO 累加器的少加和多加的情况分析</span></span><br><span class="line">    <span class="keyword">val</span> rdd = sc.makeRDD(<span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line">    <span class="comment">// 获取系统累加器</span></span><br><span class="line">    <span class="comment">// Spark默认就提供简单数据聚合的累加器</span></span><br><span class="line">    <span class="keyword">val</span> sumAcc = sc.longAccumulator(<span class="string">"sum"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> mapRDD = rdd.map(num =&gt; &#123;</span><br><span class="line">      <span class="comment">// 使用累加器</span></span><br><span class="line">      sumAcc.add(num)</span><br><span class="line">      num</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// mapRDD.cache()</span></span><br><span class="line">    <span class="comment">// 获取累加器的值，会出现两种特殊情况</span></span><br><span class="line">    <span class="comment">// 少加：转换算子中调用累加器，如果没有行动算子的话，那么不会执行</span></span><br><span class="line">    println(sumAcc.value)</span><br><span class="line">    <span class="comment">// 多加：多次调用行动算子，相应的累加操作也会重复执行,如果不想出现多加的情况，可以使用持久化操作</span></span><br><span class="line">    <span class="comment">// 一般情况下，累加器放在行动算子中进行操作</span></span><br><span class="line">    mapRDD.collect()</span><br><span class="line">    mapRDD.collect()</span><br><span class="line">    println(sumAcc.value)</span><br><span class="line">    sc.stop()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spark.core.acc</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.util.<span class="type">AccumulatorV2</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"><span class="keyword">import</span> scala.collection.mutable</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Spark04_Acc</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">"local"</span>).setAppName(<span class="string">"WordCount"</span>)</span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(sparkConf)</span><br><span class="line">    <span class="comment">// TODO 使用自定义累加器完成WordCount</span></span><br><span class="line">    <span class="keyword">val</span> rdd = sc.makeRDD(<span class="type">List</span>(<span class="string">"Hello"</span>, <span class="string">"Spark"</span>, <span class="string">"Scala"</span>, <span class="string">"Hello"</span>))</span><br><span class="line">    rdd.map((_, <span class="number">1</span>)).reduceByKey(_ + _)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自定义累加器</span></span><br><span class="line">    <span class="comment">// 1、创建累加器对象</span></span><br><span class="line">    <span class="comment">// 2、向Spark进行注册</span></span><br><span class="line">    <span class="keyword">val</span> wcAcc = <span class="keyword">new</span> <span class="type">MyAccumulator</span></span><br><span class="line">    sc.register(wcAcc, <span class="string">"wordCountAcc"</span>)</span><br><span class="line"></span><br><span class="line">    rdd.foreach(</span><br><span class="line">      word =&gt; &#123;</span><br><span class="line">        <span class="comment">// 数据累加（使用累加器）</span></span><br><span class="line">        wcAcc.add(word)</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取累加器累加的结果</span></span><br><span class="line">    println(wcAcc.value)</span><br><span class="line">    sc.stop()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  * 自定义数据累加器：WordCount</span></span><br><span class="line"><span class="comment">  * 1、继承AccumulatorV2，定义泛型</span></span><br><span class="line"><span class="comment">  *   IN：累加器输入的数据类型</span></span><br><span class="line"><span class="comment">  *   OUT：累加器返回的数据类型</span></span><br><span class="line"><span class="comment">  * 2、重写方法（6个）</span></span><br><span class="line"><span class="comment">  * */</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">MyAccumulator</span> <span class="keyword">extends</span> <span class="title">AccumulatorV2</span>[<span class="type">String</span>, mutable.<span class="type">Map</span>[<span class="type">String</span>, <span class="type">Long</span>]] </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> wcMap = mutable.<span class="type">Map</span>[<span class="type">String</span>, <span class="type">Long</span>]()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 判断是否是初始状态</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">isZero</span></span>: <span class="type">Boolean</span> = &#123;</span><br><span class="line">      wcMap.isEmpty</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 复制一个新的累加器</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">copy</span></span>(): <span class="type">AccumulatorV2</span>[<span class="type">String</span>, mutable.<span class="type">Map</span>[<span class="type">String</span>, <span class="type">Long</span>]] = &#123;</span><br><span class="line">      <span class="keyword">new</span> <span class="type">MyAccumulator</span>()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 重置累加器</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">reset</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">      wcMap.clear()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取累加器需要计算的值</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">add</span></span>(word: <span class="type">String</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">      <span class="keyword">val</span> newCnt = wcMap.getOrElse(word, <span class="number">0</span>L) + <span class="number">1</span></span><br><span class="line">      wcMap.update(word, newCnt)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Driver合并多个累加器</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">merge</span></span>(other: <span class="type">AccumulatorV2</span>[<span class="type">String</span>, mutable.<span class="type">Map</span>[<span class="type">String</span>, <span class="type">Long</span>]]): <span class="type">Unit</span> = &#123;</span><br><span class="line">      <span class="keyword">val</span> map1 = <span class="keyword">this</span>.wcMap</span><br><span class="line">      <span class="keyword">val</span> map2 = other.value</span><br><span class="line">      map2.foreach &#123;</span><br><span class="line">        <span class="keyword">case</span> (word, count) =&gt; &#123;</span><br><span class="line">          <span class="keyword">val</span> newCount = map1.getOrElse(word, <span class="number">0</span>L) + count</span><br><span class="line">          map1.update(word, newCount)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回累加后的值</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">value</span></span>: mutable.<span class="type">Map</span>[<span class="type">String</span>, <span class="type">Long</span>] = &#123;</span><br><span class="line">      wcMap</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-3-广播变量"><a href="#5-3-广播变量" class="headerlink" title="5.3 广播变量"></a>5.3 广播变量</h2><h3 id="5-3-1-实现原理"><a href="#5-3-1-实现原理" class="headerlink" title="5.3.1 实现原理"></a>5.3.1 实现原理</h3><p>广播变量用来高效分发较大的对象。向所有工作节点发送一个较大的只读值，以供一个或多个 Spark 操作使用。比如，如果你的应用需要向所有节点发送一个较大的只读查询表，广播变量用起来都很顺手。在多个并行操作中使用同一个变量，但是 Spark 默认会为每个任务分别发送闭包数据</p>
<p><img src="/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20231010154250327.png" alt="image-20231010154250327"></p>
<ul>
<li>闭包数据，都是以Task为单位发送的，每个任务中包含闭包数据</li>
<li>这样可能会导致，一个Executor中含有大量重复的数据，并且占用大量的内存</li>
<li>Executor其实就一个JVM，所以在启动时，会自动分配内存</li>
<li>完全可以将任务中的闭包数据放置在Executor的内存中，达到共享的目的</li>
<li>Spark中的广播变量就可以将闭包的数据保存到Executor的内存中</li>
<li>Spark中的广播变量不能够更改 ： 分布式共享只读变量</li>
</ul>
<h3 id="5-3-2-基础编程"><a href="#5-3-2-基础编程" class="headerlink" title="5.3.2 基础编程"></a>5.3.2 基础编程</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> rdd1 = sc.makeRDD(<span class="type">List</span>( (<span class="string">"a"</span>,<span class="number">1</span>), (<span class="string">"b"</span>, <span class="number">2</span>), (<span class="string">"c"</span>, <span class="number">3</span>), (<span class="string">"d"</span>, <span class="number">4</span>) ),<span class="number">4</span>)</span><br><span class="line"><span class="keyword">val</span> list = <span class="type">List</span>( (<span class="string">"a"</span>,<span class="number">4</span>), (<span class="string">"b"</span>, <span class="number">5</span>), (<span class="string">"c"</span>, <span class="number">6</span>), (<span class="string">"d"</span>, <span class="number">7</span>) )</span><br><span class="line"><span class="comment">// 声明广播变量</span></span><br><span class="line"><span class="keyword">val</span> broadcast: <span class="type">Broadcast</span>[<span class="type">List</span>[(<span class="type">String</span>, <span class="type">Int</span>)]] = sc.broadcast(list)</span><br><span class="line"><span class="keyword">val</span> resultRDD: <span class="type">RDD</span>[(<span class="type">String</span>, (<span class="type">Int</span>, <span class="type">Int</span>))] = rdd1.map &#123;</span><br><span class="line">    <span class="keyword">case</span> (key, num) =&gt; &#123;</span><br><span class="line">    <span class="keyword">var</span> num2 = <span class="number">0</span></span><br><span class="line">    <span class="comment">// 使用广播变量</span></span><br><span class="line">    <span class="keyword">for</span> ((k, v) &lt;- broadcast.value) &#123;</span><br><span class="line">        <span class="keyword">if</span> (k == key) &#123;</span><br><span class="line">        	num2 = v</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    (key, (num, num2))</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>练习与测试</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spark.core.acc</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"><span class="keyword">import</span> scala.collection.mutable</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Spark05_Bc</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> =  &#123;</span><br><span class="line">    <span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">"local"</span>).setAppName(<span class="string">"WordCount"</span>)</span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(sparkConf)</span><br><span class="line">    <span class="comment">// TODO 出现内存数据过多问题</span></span><br><span class="line">    <span class="keyword">val</span> rdd1 = sc.makeRDD(<span class="type">List</span>((<span class="string">"a"</span>, <span class="number">1</span>), (<span class="string">"b"</span>, <span class="number">2</span>), (<span class="string">"c"</span>, <span class="number">3</span>)))</span><br><span class="line">    <span class="comment">// val rdd2 = sc.makeRDD(List(("a", 4), ("b", 5), ("c", 6)))</span></span><br><span class="line">    <span class="comment">// join会导致数据量集合增长，并且会影响shuffle的性能，不推荐使用</span></span><br><span class="line">    <span class="comment">// val joinRDD = rdd1.join(rdd2)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ("a", 1), ("b", 2), ("c", 3)</span></span><br><span class="line">    <span class="comment">// (a, (1, 4)), (b, (2, 5)), (c,(3,5))</span></span><br><span class="line">    <span class="keyword">val</span> map = mutable.<span class="type">Map</span>((<span class="string">"a"</span>, <span class="number">4</span>), (<span class="string">"b"</span>, <span class="number">5</span>), (<span class="string">"c"</span>, <span class="number">6</span>))</span><br><span class="line">    rdd1.map &#123;</span><br><span class="line">      <span class="keyword">case</span> (w, c) =&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> l = map.getOrElse(w, <span class="number">0</span>)</span><br><span class="line">        (w, (c, l))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;.collect().foreach(println)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// joinRDD.collect().foreach(println)</span></span><br><span class="line">    sc.stop()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spark.core.acc</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"><span class="keyword">import</span> scala.collection.mutable</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Spark06_Bc</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">"local"</span>).setAppName(<span class="string">"WordCount"</span>)</span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(sparkConf)</span><br><span class="line">    <span class="comment">// TODO 广播变量</span></span><br><span class="line">    <span class="keyword">val</span> rdd1 = sc.makeRDD(<span class="type">List</span>((<span class="string">"a"</span>, <span class="number">1</span>), (<span class="string">"b"</span>, <span class="number">2</span>), (<span class="string">"c"</span>, <span class="number">3</span>)))</span><br><span class="line">    <span class="comment">// val rdd2 = sc.makeRDD(List(("a", 4), ("b", 5), ("c", 6)))</span></span><br><span class="line">    <span class="comment">// join会导致数据量集合增长，并且会影响shuffle的性能，不推荐使用</span></span><br><span class="line">    <span class="comment">// val joinRDD = rdd1.join(rdd2)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> map = mutable.<span class="type">Map</span>((<span class="string">"a"</span>, <span class="number">4</span>), (<span class="string">"b"</span>, <span class="number">5</span>), (<span class="string">"c"</span>, <span class="number">6</span>))</span><br><span class="line">    <span class="comment">// 封装广播变量</span></span><br><span class="line">    <span class="keyword">val</span> bc = sc.broadcast(map)</span><br><span class="line">    rdd1.map &#123;</span><br><span class="line">      <span class="keyword">case</span> (w, c) =&gt; &#123;</span><br><span class="line">        <span class="comment">// 访问广播变量</span></span><br><span class="line">        <span class="keyword">val</span> l = bc.value.getOrElse(w, <span class="number">0</span>)</span><br><span class="line">        (w, (c, l))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;.collect().foreach(println)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// joinRDD.collect().foreach(println)</span></span><br><span class="line">    sc.stop()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="第6章-Spark-案例实操"><a href="#第6章-Spark-案例实操" class="headerlink" title="第6章 Spark 案例实操"></a>第6章 Spark 案例实操</h1><p>在之前的学习中，我们已经学习了 Spark 的基础编程方式，接下来，我们看看在实际的工作中如何使用这些 API 实现具体的需求。这些需求是电商网站的真实需求，所以在实现功能前，咱们必须先将数据准备好。</p>
<p><img src="/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20240318154740609.png" alt="image-20240318154740609"></p>
<p>上面的数据图是从数据文件中截取的一部分内容，表示为电商网站的用户行为数据，主要包含用户的 4 种行为： 搜索，点击，下单，支付。 数据规则如下：  </p>
<p>数据文件中每行数据采用下划线分隔数据</p>
<ul>
<li>每一行数据表示用户的一次行为，这个行为只能是 4 种行为的一种</li>
<li>如果搜索关键字为 null,表示数据不是搜索数据</li>
<li>如果点击的品类 ID 和产品 ID 为-1，表示数据不是点击数据</li>
<li>针对于下单行为，一次可以下单多个商品，所以品类 ID 和产品 ID 可以是多个， id 之间采用逗号分隔，如果本次不是下单行为，则数据采用 null 表示</li>
<li>支付行为和下单行为类似</li>
</ul>
<p>详细字段说明：</p>
<table>
<thead>
<tr>
<th>编号</th>
<th>字段名称</th>
<th>字段类型</th>
<th>字段含义</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>date</td>
<td>String</td>
<td>用户点击行为的日期</td>
</tr>
<tr>
<td>2</td>
<td>user_id</td>
<td>Long</td>
<td>用户的 ID</td>
</tr>
<tr>
<td>3</td>
<td>session_id</td>
<td>String</td>
<td>Session 的 ID</td>
</tr>
<tr>
<td>4</td>
<td>page_id</td>
<td>Long</td>
<td>某个页面的 ID</td>
</tr>
<tr>
<td>5</td>
<td>action_time</td>
<td>String</td>
<td>动作的时间点</td>
</tr>
<tr>
<td>6</td>
<td>search_keyword</td>
<td>String</td>
<td>用户搜索的关键词</td>
</tr>
<tr>
<td>7</td>
<td>click_category_id</td>
<td>Long</td>
<td>某一个商品品类的 ID</td>
</tr>
<tr>
<td>8</td>
<td>click_product_id</td>
<td>Long</td>
<td>某一个商品的 ID</td>
</tr>
<tr>
<td>9</td>
<td>order_category_ids</td>
<td>String</td>
<td>一次订单中所有品类的 ID 集合</td>
</tr>
<tr>
<td>10</td>
<td>order_product_ids</td>
<td>String</td>
<td>一次订单中所有商品的 ID 集合</td>
</tr>
<tr>
<td>11</td>
<td>pay_category_ids</td>
<td>String</td>
<td>一次支付中所有品类的 ID 集合</td>
</tr>
<tr>
<td>12</td>
<td>pay_product_ids</td>
<td>String</td>
<td>一次支付中所有商品的 ID 集合</td>
</tr>
<tr>
<td>13</td>
<td>city_id</td>
<td>Long</td>
<td>城市 id</td>
</tr>
</tbody></table>
<p>样例类：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用户访问动作表</span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">UserVisitAction</span>(<span class="params"></span></span></span><br><span class="line"><span class="class"><span class="params">    date: <span class="type">String</span>,//用户点击行为的日期</span></span></span><br><span class="line"><span class="class"><span class="params">    user_id: <span class="type">Long</span>,//用户的 <span class="type">ID</span></span></span></span><br><span class="line"><span class="class"><span class="params">    session_id: <span class="type">String</span>,//<span class="type">Session</span> 的 <span class="type">ID</span></span></span></span><br><span class="line"><span class="class"><span class="params">    page_id: <span class="type">Long</span>,//某个页面的 <span class="type">ID</span></span></span></span><br><span class="line"><span class="class"><span class="params">    action_time: <span class="type">String</span>,//动作的时间点</span></span></span><br><span class="line"><span class="class"><span class="params">    search_keyword: <span class="type">String</span>,//用户搜索的关键词</span></span></span><br><span class="line"><span class="class"><span class="params">    click_category_id: <span class="type">Long</span>,//某一个商品品类的 <span class="type">ID</span></span></span></span><br><span class="line"><span class="class"><span class="params">    click_product_id: <span class="type">Long</span>,//某一个商品的 <span class="type">ID</span></span></span></span><br><span class="line"><span class="class"><span class="params">    order_category_ids: <span class="type">String</span>,//一次订单中所有品类的 <span class="type">ID</span> 集合</span></span></span><br><span class="line"><span class="class"><span class="params">    order_product_ids: <span class="type">String</span>,//一次订单中所有商品的 <span class="type">ID</span> 集合</span></span></span><br><span class="line"><span class="class"><span class="params">    pay_category_ids: <span class="type">String</span>,//一次支付中所有品类的 <span class="type">ID</span> 集合</span></span></span><br><span class="line"><span class="class"><span class="params">    pay_product_ids: <span class="type">String</span>,//一次支付中所有商品的 <span class="type">ID</span> 集合</span></span></span><br><span class="line"><span class="class"><span class="params">    city_id: <span class="type">Long</span> //城市 id</span></span></span><br><span class="line"><span class="class"><span class="params"></span>)</span></span><br></pre></td></tr></table></figure>

<h2 id="6-1-需求-1：Top10-热门品类"><a href="#6-1-需求-1：Top10-热门品类" class="headerlink" title="6.1 需求 1：Top10 热门品类"></a>6.1 需求 1：Top10 热门品类</h2><p><img src="/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20240318155127794.png" alt="image-20240318155127794"></p>
<h3 id="6-1-1-需求说明"><a href="#6-1-1-需求说明" class="headerlink" title="6.1.1 需求说明"></a>6.1.1 需求说明</h3><p>品类是指产品的分类，大型电商网站品类分多级，咱们的项目中品类只有一级，不同的公司可能对热门的定义不一样。我们按照每个品类的点击、下单、支付的量来统计热门品类。</p>
<p>鞋 点击数 下单数 支付数<br>衣服 点击数 下单数 支付数<br>电脑 点击数 下单数 支付数</p>
<p>例如，综合排名 = 点击数<em>20%+下单数</em>30%+支付数*50%  </p>
<p>本项目需求优化为： <strong>先按照点击数排名，靠前的就排名高；如果点击数相同，再比较下单数；下单数再相同，就比较支付数。</strong>  </p>
<p>思路图解：</p>
<p><img src="/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20240319101749536.png" alt="image-20240319101749536"></p>
<h3 id="6-1-2-实现方案一"><a href="#6-1-2-实现方案一" class="headerlink" title="6.1.2 实现方案一"></a>6.1.2 实现方案一</h3><h4 id="6-1-2-1-需求分析"><a href="#6-1-2-1-需求分析" class="headerlink" title="6.1.2.1 需求分析"></a>6.1.2.1 需求分析</h4><p>分别统计每个品类点击的次数，下单的次数和支付的次数：<br>（品类，点击总数）（品类，下单总数）（品类，支付总数）</p>
<h4 id="6-1-2-2-需求实现"><a href="#6-1-2-2-需求实现" class="headerlink" title="6.1.2.2 需求实现"></a>6.1.2.2 需求实现</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spark.core.req</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.rdd.<span class="type">RDD</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Spark01_Req01_HotCategoryTop10Analysis</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">// TODO 案例实操-电商网站的真实需求-user_visit_action.txt</span></span><br><span class="line">    <span class="comment">// TODO Top10热门品类</span></span><br><span class="line">    <span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">"local[*]"</span>).setAppName(<span class="string">"WordCount"</span>)</span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(sparkConf)</span><br><span class="line">    <span class="comment">// 1. 读取原始日志数据</span></span><br><span class="line">    <span class="keyword">val</span> actionRDD = sc.textFile(<span class="string">"datas/user_visit_action.txt"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 读取品类的点击数量：(品类ID, 点击数量)</span></span><br><span class="line">    <span class="keyword">val</span> clickActionRDD = actionRDD.filter(</span><br><span class="line">      action =&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> datas = action.split(<span class="string">"_"</span>)</span><br><span class="line">        datas(<span class="number">6</span>) != <span class="string">"-1"</span></span><br><span class="line">      &#125;)</span><br><span class="line">    <span class="keyword">val</span> clickCountRDD = clickActionRDD.map(action =&gt; &#123;</span><br><span class="line">      <span class="keyword">val</span> datas = action.split(<span class="string">"_"</span>)</span><br><span class="line">      (datas(<span class="number">6</span>), <span class="number">1</span>)</span><br><span class="line">    &#125;).reduceByKey(_ + _)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 读取品类的下单数量：(品类ID, 下单数量)</span></span><br><span class="line">    <span class="keyword">val</span> orderActionRDD = actionRDD.filter(</span><br><span class="line">      action =&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> datas = action.split(<span class="string">"_"</span>)</span><br><span class="line">        datas(<span class="number">8</span>) != <span class="string">"null"</span></span><br><span class="line">      &#125;)</span><br><span class="line">    <span class="keyword">val</span> orderCountRDD = orderActionRDD.flatMap(action =&gt; &#123;</span><br><span class="line">      <span class="keyword">val</span> datas = action.split(<span class="string">"_"</span>)</span><br><span class="line">      <span class="keyword">val</span> cid = datas(<span class="number">8</span>)</span><br><span class="line">      <span class="keyword">val</span> cids = cid.split(<span class="string">","</span>)</span><br><span class="line">      cids.map(id =&gt; (id, <span class="number">1</span>))</span><br><span class="line">    &#125;).reduceByKey(_ + _)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 读取品类的支付数量：(品类ID, 支付数量)</span></span><br><span class="line">    <span class="keyword">val</span> payActionRDD = actionRDD.filter(</span><br><span class="line">      action =&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> datas = action.split(<span class="string">"_"</span>)</span><br><span class="line">        datas(<span class="number">10</span>) != <span class="string">"null"</span></span><br><span class="line">      &#125;)</span><br><span class="line">    <span class="keyword">val</span> payCountRDD = payActionRDD.flatMap(action =&gt; &#123;</span><br><span class="line">      <span class="keyword">val</span> datas = action.split(<span class="string">"_"</span>)</span><br><span class="line">      <span class="keyword">val</span> cid = datas(<span class="number">10</span>)</span><br><span class="line">      <span class="keyword">val</span> cids = cid.split(<span class="string">","</span>)</span><br><span class="line">      cids.map(id =&gt; (id, <span class="number">1</span>))</span><br><span class="line">    &#125;).reduceByKey(_ + _)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 将品类进行排序，并且取前10名</span></span><br><span class="line">    <span class="comment">//    1) 点击数量排序 2) 下单数量排序 3) 支付数量排序</span></span><br><span class="line">    <span class="comment">//    元组排序：先比较第一个，在比较第二个，再比较第三个，以此类推</span></span><br><span class="line">    <span class="comment">//    先形成：(品类ID, (点击数量, 下单数量, 支付数量))</span></span><br><span class="line">    <span class="comment">//    join, zip, leftOuterJoin, cogroup 经过对比，使用cogroup = connect + group</span></span><br><span class="line">    <span class="keyword">val</span> cogroupRDD: <span class="type">RDD</span>[(<span class="type">String</span>, (<span class="type">Iterable</span>[<span class="type">Int</span>], <span class="type">Iterable</span>[<span class="type">Int</span>], <span class="type">Iterable</span>[<span class="type">Int</span>]))] = clickCountRDD.cogroup(orderCountRDD, payCountRDD)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> analysisRDD = cogroupRDD.mapValues &#123;</span><br><span class="line">      <span class="keyword">case</span> (clickIter, orderIter, payIter) =&gt; &#123;</span><br><span class="line">        <span class="keyword">var</span> clickCnt = <span class="number">0</span></span><br><span class="line">        <span class="keyword">val</span> iter1 = clickIter.iterator</span><br><span class="line">        <span class="keyword">if</span> (iter1.hasNext) &#123;</span><br><span class="line">          clickCnt = iter1.next()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> orderCnt = <span class="number">0</span></span><br><span class="line">        <span class="keyword">val</span> iter2 = orderIter.iterator</span><br><span class="line">        <span class="keyword">if</span> (iter2.hasNext) &#123;</span><br><span class="line">          orderCnt = iter2.next()</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> payCnt = <span class="number">0</span></span><br><span class="line">        <span class="keyword">val</span> iter3 = payIter.iterator</span><br><span class="line">        <span class="keyword">if</span> (iter3.hasNext) &#123;</span><br><span class="line">          payCnt = iter3.next()</span><br><span class="line">        &#125;</span><br><span class="line">        (clickCnt, orderCnt, payCnt)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> resultRDD = analysisRDD.sortBy(_._2, <span class="literal">false</span>).take(<span class="number">10</span>)</span><br><span class="line">    <span class="comment">// 6. 将结果采集到控制台打印</span></span><br><span class="line">    resultRDD.foreach(println)</span><br><span class="line"></span><br><span class="line">    sc.stop()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-1-3-实现方案二"><a href="#6-1-3-实现方案二" class="headerlink" title="6.1.3 实现方案二"></a>6.1.3 实现方案二</h3><h4 id="6-1-3-1-需求分析"><a href="#6-1-3-1-需求分析" class="headerlink" title="6.1.3.1 需求分析"></a>6.1.3.1 需求分析</h4><p>一次性统计每个品类点击的次数，下单的次数和支付的次数：<br>（品类，（点击总数，下单总数，支付总数））  </p>
<h4 id="6-1-3-2-需求实现"><a href="#6-1-3-2-需求实现" class="headerlink" title="6.1.3.2 需求实现"></a>6.1.3.2 需求实现</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spark.core.req</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Spark02_Req01_HotCategoryTop10Analysis</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">// TODO 案例实操-电商网站的真实需求-user_visit_action.txt</span></span><br><span class="line">    <span class="comment">// TODO Top10热门品类-第二种方案</span></span><br><span class="line">    <span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">"local[*]"</span>).setAppName(<span class="string">"WordCount"</span>)</span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(sparkConf)</span><br><span class="line">    <span class="comment">// Q1：actionRDD重复使用</span></span><br><span class="line">    <span class="comment">// Q2：cogroup性能可能较低，因为cogroup 有可能存在shuffle</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 读取原始日志数据</span></span><br><span class="line">    <span class="keyword">val</span> actionRDD = sc.textFile(<span class="string">"datas/user_visit_action.txt"</span>)</span><br><span class="line">    <span class="comment">// 解决Q1的问题</span></span><br><span class="line">    actionRDD.cache()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 读取品类的点击数量：(品类ID, 点击数量)</span></span><br><span class="line">    <span class="keyword">val</span> clickActionRDD = actionRDD.filter(</span><br><span class="line">      action =&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> datas = action.split(<span class="string">"_"</span>)</span><br><span class="line">        datas(<span class="number">6</span>) != <span class="string">"-1"</span></span><br><span class="line">      &#125;)</span><br><span class="line">    <span class="keyword">val</span> clickCountRDD = clickActionRDD.map(action =&gt; &#123;</span><br><span class="line">      <span class="keyword">val</span> datas = action.split(<span class="string">"_"</span>)</span><br><span class="line">      (datas(<span class="number">6</span>), <span class="number">1</span>)</span><br><span class="line">    &#125;).reduceByKey(_ + _)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 读取品类的下单数量：(品类ID, 下单数量)</span></span><br><span class="line">    <span class="keyword">val</span> orderActionRDD = actionRDD.filter(</span><br><span class="line">      action =&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> datas = action.split(<span class="string">"_"</span>)</span><br><span class="line">        datas(<span class="number">8</span>) != <span class="string">"null"</span></span><br><span class="line">      &#125;)</span><br><span class="line">    <span class="keyword">val</span> orderCountRDD = orderActionRDD.flatMap(action =&gt; &#123;</span><br><span class="line">      <span class="keyword">val</span> datas = action.split(<span class="string">"_"</span>)</span><br><span class="line">      <span class="keyword">val</span> cid = datas(<span class="number">8</span>)</span><br><span class="line">      <span class="keyword">val</span> cids = cid.split(<span class="string">","</span>)</span><br><span class="line">      cids.map(id =&gt; (id, <span class="number">1</span>))</span><br><span class="line">    &#125;).reduceByKey(_ + _)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 读取品类的支付数量：(品类ID, 支付数量)</span></span><br><span class="line">    <span class="keyword">val</span> payActionRDD = actionRDD.filter(</span><br><span class="line">      action =&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> datas = action.split(<span class="string">"_"</span>)</span><br><span class="line">        datas(<span class="number">10</span>) != <span class="string">"null"</span></span><br><span class="line">      &#125;)</span><br><span class="line">    <span class="keyword">val</span> payCountRDD = payActionRDD.flatMap(action =&gt; &#123;</span><br><span class="line">      <span class="keyword">val</span> datas = action.split(<span class="string">"_"</span>)</span><br><span class="line">      <span class="keyword">val</span> cid = datas(<span class="number">10</span>)</span><br><span class="line">      <span class="keyword">val</span> cids = cid.split(<span class="string">","</span>)</span><br><span class="line">      cids.map(id =&gt; (id, <span class="number">1</span>))</span><br><span class="line">    &#125;).reduceByKey(_ + _)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 将品类进行排序，并且取前10名</span></span><br><span class="line">    <span class="comment">//    1) 点击数量排序 2) 下单数量排序 3) 支付数量排序</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//    (品类ID, 点击数量) =&gt; (品类ID, (点击数量, 0, 0))</span></span><br><span class="line">    <span class="comment">//    (品类ID, 下单数量) =&gt; (品类ID, (0, 下单数量, 0))</span></span><br><span class="line">    <span class="comment">//                合并 =&gt; (品类ID, (点击数量, 下单数量, 0))</span></span><br><span class="line">    <span class="comment">//    (品类ID, 支付数量) =&gt; (品类ID, (0, 0, 支付数量))</span></span><br><span class="line">    <span class="comment">//                合并 =&gt; (品类ID, (点击数量, 下单数量, 支付数量))</span></span><br><span class="line">    <span class="comment">//    最终得到：(品类ID, (点击数量, 下单数量, 支付数量))</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> rdd1 = clickCountRDD.map &#123;</span><br><span class="line">      <span class="keyword">case</span> (cid, cnt) =&gt; &#123;</span><br><span class="line">        (cid, (cnt, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> rdd2 = orderCountRDD.map &#123;</span><br><span class="line">      <span class="keyword">case</span> (cid, cnt) =&gt; &#123;</span><br><span class="line">        (cid, (<span class="number">0</span>, cnt, <span class="number">0</span>))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> rdd3 = payCountRDD.map &#123;</span><br><span class="line">      <span class="keyword">case</span> (cid, cnt) =&gt; &#123;</span><br><span class="line">        (cid, (<span class="number">0</span>, <span class="number">0</span>, cnt))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将三个数据源合并在一起，统一进行聚合计算</span></span><br><span class="line">    <span class="comment">// 解决Q2的问题</span></span><br><span class="line">    <span class="keyword">val</span> sourceRDD = rdd1.union(rdd2).union(rdd3)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> analysisRDD = sourceRDD.reduceByKey(</span><br><span class="line">      (t1, t2) =&gt; &#123;</span><br><span class="line">        (t1._1 + t2._1, t1._2 + t2._2, t1._3 + t2._3)</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> resultRDD = analysisRDD.sortBy(_._2, <span class="literal">false</span>).take(<span class="number">10</span>)</span><br><span class="line">    <span class="comment">// 6. 将结果采集到控制台打印</span></span><br><span class="line">    resultRDD.foreach(println)</span><br><span class="line"></span><br><span class="line">    sc.stop()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spark.core.req</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.rdd.<span class="type">RDD</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Spark03_Req01_HotCategoryTop10Analysis</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">// TODO 案例实操-电商网站的真实需求-user_visit_action.txt</span></span><br><span class="line">    <span class="comment">// TODO Top10热门品类-第三种方案</span></span><br><span class="line">    <span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">"local[*]"</span>).setAppName(<span class="string">"WordCount"</span>)</span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(sparkConf)</span><br><span class="line">    <span class="comment">// Q1：还是存在大量的shuffle操作（reduceByKey）</span></span><br><span class="line">    <span class="comment">// reduceByKey 聚合算子，spark底层本身会提供优化（预聚合、缓存）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 读取原始日志数据</span></span><br><span class="line">    <span class="keyword">val</span> actionRDD = sc.textFile(<span class="string">"datas/user_visit_action.txt"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 将数据转换结构</span></span><br><span class="line">    <span class="comment">// 点击的场合：(品类ID, (1, 0, 0))</span></span><br><span class="line">    <span class="comment">// 下单的场合：(品类ID, (0, 1, 0))</span></span><br><span class="line">    <span class="comment">// 支付的场合：(品类ID, (0, 0, 1))</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解决Q1的问题</span></span><br><span class="line">    <span class="keyword">val</span> flatRDD: <span class="type">RDD</span>[(<span class="type">String</span>, (<span class="type">Int</span>, <span class="type">Int</span>, <span class="type">Int</span>))] = actionRDD.flatMap(action =&gt; &#123;</span><br><span class="line">      <span class="keyword">val</span> datas = action.split(<span class="string">"_"</span>)</span><br><span class="line">      <span class="keyword">if</span> (datas(<span class="number">6</span>) != <span class="string">"-1"</span>) &#123;</span><br><span class="line">        <span class="comment">// 点击场合</span></span><br><span class="line">        <span class="type">List</span>((datas(<span class="number">6</span>), (<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>)))</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (datas(<span class="number">8</span>) != <span class="string">"null"</span>) &#123;</span><br><span class="line">        <span class="comment">// 下单场合</span></span><br><span class="line">        <span class="keyword">val</span> ids = datas(<span class="number">8</span>).split(<span class="string">","</span>)</span><br><span class="line">        ids.map(id =&gt; (id, (<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>)))</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (datas(<span class="number">10</span>) != <span class="string">"null"</span>) &#123;</span><br><span class="line">        <span class="comment">// 支付场合</span></span><br><span class="line">        <span class="keyword">val</span> ids = datas(<span class="number">10</span>).split(<span class="string">","</span>)</span><br><span class="line">        ids.map(id =&gt; (id, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)))</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">Nil</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 将相同的品类ID的数据进行分组聚合</span></span><br><span class="line">    <span class="comment">// 得到：(品类ID, (点击数量, 下单数量, 支付数量))</span></span><br><span class="line">    <span class="keyword">val</span> analysisRDD = flatRDD.reduceByKey(</span><br><span class="line">      (t1, t2) =&gt; &#123;</span><br><span class="line">        (t1._1 + t2._1, t1._2 + t2._2, t1._3 + t2._3)</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">    <span class="comment">// 4. 将统计结果根据数量进行降序排列，取前10名</span></span><br><span class="line">    <span class="keyword">val</span> resultRDD = analysisRDD.sortBy(_._2, <span class="literal">false</span>).take(<span class="number">10</span>)</span><br><span class="line">    <span class="comment">// 5. 将结果采集到控制台打印</span></span><br><span class="line">    resultRDD.foreach(println)</span><br><span class="line"></span><br><span class="line">    sc.stop()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="6-1-4-实现方案三"><a href="#6-1-4-实现方案三" class="headerlink" title="6.1.4 实现方案三"></a>6.1.4 实现方案三</h3><h4 id="6-1-4-1-需求分析"><a href="#6-1-4-1-需求分析" class="headerlink" title="6.1.4.1 需求分析"></a>6.1.4.1 需求分析</h4><p>使用累加器的方式聚合数据</p>
<h4 id="6-1-4-2-需求实现"><a href="#6-1-4-2-需求实现" class="headerlink" title="6.1.4.2 需求实现"></a>6.1.4.2 需求实现</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spark.core.req</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.util.<span class="type">AccumulatorV2</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"><span class="keyword">import</span> scala.collection.mutable</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Spark04_Req01_HotCategoryTop10Analysis</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">// TODO 案例实操-电商网站的真实需求-user_visit_action.txt</span></span><br><span class="line">    <span class="comment">// TODO Top10热门品类-第四种方案</span></span><br><span class="line">    <span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">"local[*]"</span>).setAppName(<span class="string">"WordCount"</span>)</span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(sparkConf)</span><br><span class="line">    <span class="comment">// Q1：能不能彻底去掉shuffle</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 读取原始日志数据</span></span><br><span class="line">    <span class="keyword">val</span> actionRDD = sc.textFile(<span class="string">"datas/user_visit_action.txt"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 注册累加器</span></span><br><span class="line">    <span class="keyword">val</span> acc = <span class="keyword">new</span> <span class="type">HotCategoryAccumulator</span>()</span><br><span class="line">    sc.register(acc, <span class="string">"hotCategory"</span>)</span><br><span class="line"></span><br><span class="line">    actionRDD.foreach(action =&gt; &#123;</span><br><span class="line">      <span class="keyword">val</span> datas = action.split(<span class="string">"_"</span>)</span><br><span class="line">      <span class="keyword">if</span> (datas(<span class="number">6</span>) != <span class="string">"-1"</span>) &#123;</span><br><span class="line">        <span class="comment">// 点击场合</span></span><br><span class="line">        acc.add((datas(<span class="number">6</span>), <span class="string">"click"</span>))</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (datas(<span class="number">8</span>) != <span class="string">"null"</span>) &#123;</span><br><span class="line">        <span class="comment">// 下单场合</span></span><br><span class="line">        <span class="keyword">val</span> ids = datas(<span class="number">8</span>).split(<span class="string">","</span>)</span><br><span class="line">        ids.foreach(id =&gt; acc.add(id, <span class="string">"order"</span>))</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (datas(<span class="number">10</span>) != <span class="string">"null"</span>) &#123;</span><br><span class="line">        <span class="comment">// 支付场合</span></span><br><span class="line">        <span class="keyword">val</span> ids = datas(<span class="number">10</span>).split(<span class="string">","</span>)</span><br><span class="line">        ids.foreach(id =&gt; acc.add(id, <span class="string">"pay"</span>))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 将结果采集到控制台打印</span></span><br><span class="line">    <span class="keyword">val</span> accVal: mutable.<span class="type">Map</span>[<span class="type">String</span>, <span class="type">HostCategory</span>] = acc.value</span><br><span class="line">    <span class="keyword">val</span> categories: mutable.<span class="type">Iterable</span>[<span class="type">HostCategory</span>] = accVal.map(_._2)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> sort: <span class="type">List</span>[<span class="type">HostCategory</span>] = categories.toList.sortWith(</span><br><span class="line">      (left, right) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (left.clickCnt &gt; right.clickCnt) &#123;</span><br><span class="line">          <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (left.clickCnt == right.clickCnt) &#123;</span><br><span class="line">          <span class="keyword">if</span> (left.orderCnt &gt; right.orderCnt) &#123;</span><br><span class="line">            <span class="literal">true</span></span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">if</span> (left.orderCnt == right.orderCnt) &#123;</span><br><span class="line">            left.payCnt &gt; right.payCnt</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="literal">false</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">    sort.take(<span class="number">10</span>).foreach(println)</span><br><span class="line">    sc.stop()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  * 自定义累加器</span></span><br><span class="line"><span class="comment">  * 1、继承AccumulatorV2，定义泛型</span></span><br><span class="line"><span class="comment">  *   IN：累加器输入的数据类型：(品类ID, 行为类型)</span></span><br><span class="line"><span class="comment">  *   OUT：累加器返回的数据类型：mutable.Map[String,HostCategory]</span></span><br><span class="line"><span class="comment">  * 2、重写方法（6个）</span></span><br><span class="line"><span class="comment">  * */</span></span><br><span class="line">  <span class="comment">// 解决Q1的问题</span></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">HotCategoryAccumulator</span> <span class="keyword">extends</span> <span class="title">AccumulatorV2</span>[(<span class="type">String</span>, <span class="type">String</span>), mutable.<span class="type">Map</span>[<span class="type">String</span>, <span class="type">HostCategory</span>]] </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> hcMap = mutable.<span class="type">Map</span>[<span class="type">String</span>, <span class="type">HostCategory</span>]()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">isZero</span></span>: <span class="type">Boolean</span> = &#123;</span><br><span class="line">      hcMap.isEmpty</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">copy</span></span>(): <span class="type">AccumulatorV2</span>[(<span class="type">String</span>, <span class="type">String</span>), mutable.<span class="type">Map</span>[<span class="type">String</span>, <span class="type">HostCategory</span>]] = &#123;</span><br><span class="line">      <span class="keyword">new</span> <span class="type">HotCategoryAccumulator</span>()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">reset</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">      hcMap.clear()</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">add</span></span>(v: (<span class="type">String</span>, <span class="type">String</span>)): <span class="type">Unit</span> = &#123;</span><br><span class="line">      <span class="keyword">val</span> cid = v._1</span><br><span class="line">      <span class="keyword">val</span> actionType = v._2</span><br><span class="line">      <span class="keyword">val</span> category: <span class="type">HostCategory</span> = hcMap.getOrElse(cid, <span class="type">HostCategory</span>(cid, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">      <span class="keyword">if</span> (actionType == <span class="string">"click"</span>) &#123;</span><br><span class="line">        category.clickCnt += <span class="number">1</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (actionType == <span class="string">"order"</span>) &#123;</span><br><span class="line">        category.orderCnt += <span class="number">1</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (actionType == <span class="string">"pay"</span>) &#123;</span><br><span class="line">        category.payCnt += <span class="number">1</span></span><br><span class="line">      &#125;</span><br><span class="line">      hcMap.update(cid, category)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">merge</span></span>(other: <span class="type">AccumulatorV2</span>[(<span class="type">String</span>, <span class="type">String</span>), mutable.<span class="type">Map</span>[<span class="type">String</span>, <span class="type">HostCategory</span>]]): <span class="type">Unit</span> = &#123;</span><br><span class="line">      <span class="keyword">val</span> map1 = <span class="keyword">this</span>.hcMap</span><br><span class="line">      <span class="keyword">val</span> map2 = other.value</span><br><span class="line">      map2.foreach &#123;</span><br><span class="line">        <span class="keyword">case</span> (cid, hc) =&gt; &#123;</span><br><span class="line">          <span class="keyword">val</span> category = map1.getOrElse(cid, <span class="type">HostCategory</span>(cid, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">          category.clickCnt += hc.clickCnt</span><br><span class="line">          category.orderCnt += hc.orderCnt</span><br><span class="line">          category.payCnt += hc.payCnt</span><br><span class="line">          map1.update(cid, category)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">value</span></span>: mutable.<span class="type">Map</span>[<span class="type">String</span>, <span class="type">HostCategory</span>] = &#123;</span><br><span class="line">      hcMap</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">HostCategory</span>(<span class="params">var cid: <span class="type">String</span>, var clickCnt: <span class="type">Int</span>, var orderCnt: <span class="type">Int</span>, var payCnt: <span class="type">Int</span></span>)</span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure>

<h2 id="6-2-需求-2：Top10-热门品类中每个品类的-Top10-活跃-Session-统计"><a href="#6-2-需求-2：Top10-热门品类中每个品类的-Top10-活跃-Session-统计" class="headerlink" title="6.2 需求 2：Top10 热门品类中每个品类的 Top10 活跃 Session 统计"></a>6.2 需求 2：Top10 热门品类中每个品类的 Top10 活跃 Session 统计</h2><h3 id="6-2-1-需求说明"><a href="#6-2-1-需求说明" class="headerlink" title="6.2.1 需求说明"></a>6.2.1 需求说明</h3><p>在需求一的基础上，增加每个品类用户 session 的点击统计</p>
<h3 id="6-2-2-需求分析"><a href="#6-2-2-需求分析" class="headerlink" title="6.2.2 需求分析"></a>6.2.2 需求分析</h3><h3 id="6-2-3-功能实现"><a href="#6-2-3-功能实现" class="headerlink" title="6.2.3 功能实现"></a>6.2.3 功能实现</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spark.core.req</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.rdd.<span class="type">RDD</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Spark05_Req02_HotCategoryTop10SessionAnalysis</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">// TODO 案例实操-电商网站的真实需求-user_visit_action.txt</span></span><br><span class="line">    <span class="comment">// TODO Top10 热门品类中每个品类的 Top10 活跃 Session 统计 - 在需求一的基础上，增加每个品类用户 session 的点击统计</span></span><br><span class="line">    <span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">"local[*]"</span>).setAppName(<span class="string">"WordCount"</span>)</span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(sparkConf)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> actionRDD = sc.textFile(<span class="string">"datas/user_visit_action.txt"</span>)</span><br><span class="line"></span><br><span class="line">    actionRDD.cache()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> top10Ids: <span class="type">Array</span>[<span class="type">String</span>] = top10Category(actionRDD)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 过滤原始数据,保留点击和前10品类ID</span></span><br><span class="line">    <span class="keyword">val</span> filterActionRDD = actionRDD.filter(</span><br><span class="line">      action =&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> datas = action.split(<span class="string">"_"</span>)</span><br><span class="line">        <span class="keyword">if</span> (datas(<span class="number">6</span>) != <span class="string">"-1"</span>) &#123;</span><br><span class="line">          top10Ids.contains(datas(<span class="number">6</span>))</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 根据品类ID和sessionid进行点击量的统计</span></span><br><span class="line">    <span class="keyword">val</span> reduceRDD: <span class="type">RDD</span>[((<span class="type">String</span>, <span class="type">String</span>), <span class="type">Int</span>)] = filterActionRDD.map(action =&gt; &#123;</span><br><span class="line">      <span class="keyword">val</span> datas = action.split(<span class="string">"_"</span>)</span><br><span class="line">      ((datas(<span class="number">6</span>), datas(<span class="number">2</span>)), <span class="number">1</span>)</span><br><span class="line">    &#125;).reduceByKey(_ + _)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 将统计的结果进行结构的转换</span></span><br><span class="line">    <span class="comment">// ((品类ID, sessionId), sum) =&gt; (品类ID, (sessionId, sum))</span></span><br><span class="line">    <span class="keyword">val</span> mapRDD = reduceRDD.map&#123;</span><br><span class="line">      <span class="keyword">case</span> ((cid, sid),sum) =&gt; &#123;</span><br><span class="line">        (cid, (sid,sum))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4. 相同的品类进行分组</span></span><br><span class="line">    <span class="keyword">val</span> groupRDD: <span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">Iterable</span>[(<span class="type">String</span>, <span class="type">Int</span>)])] = mapRDD.groupByKey()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5. 将分组后的数据进行点击量的排序，取前10名</span></span><br><span class="line">    <span class="keyword">val</span> resultRDD = groupRDD.mapValues(_.toList.sortBy(_._2)(<span class="type">Ordering</span>.<span class="type">Int</span>.reverse).take(<span class="number">10</span>))</span><br><span class="line"></span><br><span class="line">    resultRDD.collect().foreach(println)</span><br><span class="line"></span><br><span class="line">    sc.stop()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">top10Category</span></span>(actionRDD: <span class="type">RDD</span>[<span class="type">String</span>]) = &#123;</span><br><span class="line">    <span class="keyword">val</span> flatRDD: <span class="type">RDD</span>[(<span class="type">String</span>, (<span class="type">Int</span>, <span class="type">Int</span>, <span class="type">Int</span>))] = actionRDD.flatMap(action =&gt; &#123;</span><br><span class="line">      <span class="keyword">val</span> datas = action.split(<span class="string">"_"</span>)</span><br><span class="line">      <span class="keyword">if</span> (datas(<span class="number">6</span>) != <span class="string">"-1"</span>) &#123;</span><br><span class="line">        <span class="comment">// 点击场合</span></span><br><span class="line">        <span class="type">List</span>((datas(<span class="number">6</span>), (<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>)))</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (datas(<span class="number">8</span>) != <span class="string">"null"</span>) &#123;</span><br><span class="line">        <span class="comment">// 下单场合</span></span><br><span class="line">        <span class="keyword">val</span> ids = datas(<span class="number">8</span>).split(<span class="string">","</span>)</span><br><span class="line">        ids.map(id =&gt; (id, (<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>)))</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (datas(<span class="number">10</span>) != <span class="string">"null"</span>) &#123;</span><br><span class="line">        <span class="comment">// 支付场合</span></span><br><span class="line">        <span class="keyword">val</span> ids = datas(<span class="number">10</span>).split(<span class="string">","</span>)</span><br><span class="line">        ids.map(id =&gt; (id, (<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)))</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">Nil</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">val</span> analysisRDD = flatRDD.reduceByKey(</span><br><span class="line">      (t1, t2) =&gt; &#123;</span><br><span class="line">        (t1._1 + t2._1, t1._2 + t2._2, t1._3 + t2._3)</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">    analysisRDD.sortBy(_._2, <span class="literal">false</span>).take(<span class="number">10</span>).map(_._1)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-3-需求-3：页面单跳转换率统计"><a href="#6-3-需求-3：页面单跳转换率统计" class="headerlink" title="6.3 需求 3：页面单跳转换率统计"></a>6.3 需求 3：页面单跳转换率统计</h2><h3 id="6-3-1-需求说明"><a href="#6-3-1-需求说明" class="headerlink" title="6.3.1 需求说明"></a>6.3.1 需求说明</h3><p>1）页面单跳转化率  </p>
<p>计算页面单跳转化率，什么是页面单跳转换率，比如一个用户在一次 Session 过程中访问的页面路径 3,5,7,9,10,21，那么页面 3 跳到页面 5 叫一次单跳， 7-9 也叫一次单跳，那么单跳转化率就是要统计页面点击的概率。</p>
<p>比如：计算 3-5 的单跳转化率，先获取符合条件的 Session 对于页面 3 的访问次数（PV）为 A，然后获取符合条件的 Session 中访问了页面 3 又紧接着访问了页面 5 的次数为 B，那么 B/A 就是 3-5 的页面单跳转化率。  </p>
<p><img src="/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20240318155648375.png" alt="image-20240318155648375"></p>
<p>2）统计页面单跳转化率意义</p>
<p>产品经理和运营总监，可以根据这个指标，去尝试分析，整个网站，产品，各个页面的表现怎么样，是不是需要去优化产品的布局；吸引用户最终可以进入最后的支付页面。<br>数据分析师，可以此数据做更深一步的计算和分析。<br>企业管理层，可以看到整个公司的网站，各个页面的之间的跳转的表现如何，可以适当调整公司的经营战略或策略。</p>
<h3 id="6-3-2-需求分析"><a href="#6-3-2-需求分析" class="headerlink" title="6.3.2 需求分析"></a>6.3.2 需求分析</h3><h3 id="6-3-3-功能实现"><a href="#6-3-3-功能实现" class="headerlink" title="6.3.3 功能实现"></a>6.3.3 功能实现</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.atguigu.spark.core.req</span><br><span class="line"><span class="keyword">import</span> org.apache.spark.rdd.<span class="type">RDD</span></span><br><span class="line"><span class="keyword">import</span> org.apache.spark.&#123;<span class="type">SparkConf</span>, <span class="type">SparkContext</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">Spark06_Req03_PageflowAnalysis</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">// TODO 案例实操-电商网站的真实需求-user_visit_action.txt</span></span><br><span class="line">    <span class="comment">// TODO 页面单跳转换率统计</span></span><br><span class="line">    <span class="keyword">val</span> sparkConf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">"local[*]"</span>).setAppName(<span class="string">"WordCount"</span>)</span><br><span class="line">    <span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(sparkConf)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> actionRDD = sc.textFile(<span class="string">"datas/user_visit_action.txt"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> actionDataRDD = actionRDD.map(</span><br><span class="line">      action =&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> datas = action.split(<span class="string">"_"</span>)</span><br><span class="line">        <span class="type">UserVisitAction</span>(</span><br><span class="line">          datas(<span class="number">0</span>),</span><br><span class="line">          datas(<span class="number">1</span>).toLong,</span><br><span class="line">          datas(<span class="number">2</span>),</span><br><span class="line">          datas(<span class="number">3</span>).toLong,</span><br><span class="line">          datas(<span class="number">4</span>),</span><br><span class="line">          datas(<span class="number">5</span>),</span><br><span class="line">          datas(<span class="number">6</span>).toLong,</span><br><span class="line">          datas(<span class="number">7</span>).toLong,</span><br><span class="line">          datas(<span class="number">8</span>),</span><br><span class="line">          datas(<span class="number">9</span>),</span><br><span class="line">          datas(<span class="number">10</span>),</span><br><span class="line">          datas(<span class="number">11</span>),</span><br><span class="line">          datas(<span class="number">12</span>).toLong</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">    actionDataRDD.cache()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 对指定的页面连续跳转进行统计单挑转换率</span></span><br><span class="line">    <span class="comment">// 1-2 2-3 3-4 4-5 5-6 6-7</span></span><br><span class="line">    <span class="keyword">val</span> ids = <span class="type">List</span>[<span class="type">Long</span>](<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>)</span><br><span class="line">    <span class="keyword">val</span> okflowIds: <span class="type">List</span>[(<span class="type">Long</span>, <span class="type">Long</span>)] = ids.zip(ids.tail)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO  计算分母</span></span><br><span class="line">    <span class="keyword">val</span> pageIdToCountMap: <span class="type">Map</span>[<span class="type">Long</span>, <span class="type">Long</span>] = actionDataRDD</span><br><span class="line">    .filter(</span><br><span class="line">      action =&gt; &#123;</span><br><span class="line">        <span class="comment">// init: 去除7页面，7页面没有作为分母的机会</span></span><br><span class="line">        ids.init.contains(action.page_id)</span><br><span class="line">      &#125;)</span><br><span class="line">    .map(</span><br><span class="line">      action =&gt; &#123;</span><br><span class="line">        (action.page_id, <span class="number">1</span>L)</span><br><span class="line">      &#125;</span><br><span class="line">    ).reduceByKey(_ + _).collect().toMap</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 计算分子</span></span><br><span class="line">    <span class="comment">// 根据session进行分组</span></span><br><span class="line">    <span class="keyword">val</span> sessionRDD: <span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">Iterable</span>[<span class="type">UserVisitAction</span>])] = actionDataRDD.groupBy(_.session_id)</span><br><span class="line">    <span class="comment">// 分组后，根据访问时间进行排序（升序）</span></span><br><span class="line">    <span class="keyword">val</span> mvRDD: <span class="type">RDD</span>[(<span class="type">String</span>, <span class="type">List</span>[((<span class="type">Long</span>, <span class="type">Long</span>), <span class="type">Int</span>)])] = sessionRDD.mapValues(</span><br><span class="line">      iter =&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> sortList = iter.toList.sortBy(_.action_time)</span><br><span class="line">        <span class="keyword">val</span> flowIds: <span class="type">List</span>[<span class="type">Long</span>] = sortList.map(_.page_id)</span><br><span class="line">        <span class="comment">// 使用滑动窗口或者zip拉链</span></span><br><span class="line">        <span class="comment">// Sliding: 滑窗</span></span><br><span class="line">        <span class="comment">// [1,2,3,4]</span></span><br><span class="line">        <span class="comment">// [1,2], [2,3], [3,4]</span></span><br><span class="line">        <span class="comment">// zip: 拉链</span></span><br><span class="line">        <span class="comment">// [1,2,3,4]</span></span><br><span class="line">        <span class="comment">// [2,3,4]</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// val iterator: Iterator[List[Long]] = flowIds.sliding(2)</span></span><br><span class="line">        <span class="keyword">val</span> pageflowIds: <span class="type">List</span>[(<span class="type">Long</span>, <span class="type">Long</span>)] = flowIds.zip(flowIds.tail)</span><br><span class="line">        <span class="comment">// 将不合法的页面跳转进行过滤</span></span><br><span class="line">        pageflowIds.filter(</span><br><span class="line">          t =&gt; okflowIds.contains(t)</span><br><span class="line">        )</span><br><span class="line">        .map(</span><br><span class="line">          t =&gt; (t, <span class="number">1</span>)</span><br><span class="line">        )</span><br><span class="line">      &#125;</span><br><span class="line">    )</span><br><span class="line">    <span class="comment">// ((1,2),1)</span></span><br><span class="line">    <span class="keyword">val</span> flatRDD: <span class="type">RDD</span>[((<span class="type">Long</span>, <span class="type">Long</span>), <span class="type">Int</span>)] = mvRDD.map(_._2).flatMap(list =&gt; list)</span><br><span class="line">    <span class="comment">// ((1,2),1) =&gt; ((1,2),sum)</span></span><br><span class="line">    <span class="keyword">val</span> dataRDD: <span class="type">RDD</span>[((<span class="type">Long</span>, <span class="type">Long</span>), <span class="type">Int</span>)] = flatRDD.reduceByKey(_ + _)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO 计算单挑转换率</span></span><br><span class="line">    <span class="comment">// 分子除以分母</span></span><br><span class="line">    dataRDD.foreach &#123;</span><br><span class="line">      <span class="keyword">case</span> ((pageId1, pageId2),sum) =&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> lon = pageIdToCountMap.getOrElse(pageId1, <span class="number">0</span>L)</span><br><span class="line">        println(<span class="string">s"页面<span class="subst">$&#123;pageId1&#125;</span>跳转到页面<span class="subst">$&#123;pageId2&#125;</span>单挑转换率为："</span> + (sum.toDouble / lon))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    sc.stop()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//用户访问动作表</span></span><br><span class="line">  <span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">UserVisitAction</span>(<span class="params"></span></span></span><br><span class="line"><span class="class"><span class="params">    date: <span class="type">String</span>, //用户点击行为的日期</span></span></span><br><span class="line"><span class="class"><span class="params">    user_id: <span class="type">Long</span>, //用户的 <span class="type">ID</span></span></span></span><br><span class="line"><span class="class"><span class="params">    session_id: <span class="type">String</span>, //<span class="type">Session</span> 的 <span class="type">ID</span></span></span></span><br><span class="line"><span class="class"><span class="params">    page_id: <span class="type">Long</span>, //某个页面的 <span class="type">ID</span></span></span></span><br><span class="line"><span class="class"><span class="params">    action_time: <span class="type">String</span>, //动作的时间点</span></span></span><br><span class="line"><span class="class"><span class="params">    search_keyword: <span class="type">String</span>, //用户搜索的关键词</span></span></span><br><span class="line"><span class="class"><span class="params">    click_category_id: <span class="type">Long</span>, //某一个商品品类的 <span class="type">ID</span></span></span></span><br><span class="line"><span class="class"><span class="params">    click_product_id: <span class="type">Long</span>, //某一个商品的 <span class="type">ID</span></span></span></span><br><span class="line"><span class="class"><span class="params">    order_category_ids: <span class="type">String</span>, //一次订单中所有品类的 <span class="type">ID</span> 集合</span></span></span><br><span class="line"><span class="class"><span class="params">    order_product_ids: <span class="type">String</span>, //一次订单中所有商品的 <span class="type">ID</span> 集合</span></span></span><br><span class="line"><span class="class"><span class="params">    pay_category_ids: <span class="type">String</span>, //一次支付中所有品类的 <span class="type">ID</span> 集合</span></span></span><br><span class="line"><span class="class"><span class="params">    pay_product_ids: <span class="type">String</span>, //一次支付中所有商品的 <span class="type">ID</span> 集合</span></span></span><br><span class="line"><span class="class"><span class="params">    city_id: <span class="type">Long</span> //城市 id</span></span></span><br><span class="line"><span class="class"><span class="params">  </span>)</span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure>

<h1 id="第七章-三层架构"><a href="#第七章-三层架构" class="headerlink" title="第七章 三层架构"></a>第七章 三层架构</h1><p>三层架构（不涉及前端，且不同于MVC的开发过程中的普遍架构）</p>
<p><img src="/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/image-20240319153521432.png" alt="image-20240319153521432"></p>
<p>分层案例，查阅个人练习项目</p>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>Rui Zhang
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://yoursite.com/2023/07/03/SparkCore%E7%AC%94%E8%AE%B0/" title="SparkCore笔记">http://yoursite.com/2023/07/03/SparkCore笔记/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Spark/" rel="tag"># Spark</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/10/26/Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%AF%A6%E8%A7%A3/" rel="prev" title="Lambda表达式详解">
      <i class="fa fa-chevron-left"></i> Lambda表达式详解
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/10/16/Vue%E7%AC%94%E8%AE%B0/" rel="next" title="Vue笔记">
      Vue笔记 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#第1章-Spark-概述"><span class="nav-number">1.</span> <span class="nav-text">第1章 Spark 概述</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-Spark-是什么"><span class="nav-number">1.1.</span> <span class="nav-text">1.1 Spark 是什么</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-Spark-and-Hadoop"><span class="nav-number">1.2.</span> <span class="nav-text">1.2 Spark and Hadoop</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-3-Spark-or-Hadoop"><span class="nav-number">1.3.</span> <span class="nav-text">1.3 Spark or Hadoop</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-4-Spark-核心模块"><span class="nav-number">1.4.</span> <span class="nav-text">1.4 Spark 核心模块</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第2章-Spark-快速上手"><span class="nav-number">2.</span> <span class="nav-text">第2章 Spark 快速上手</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-创建-Maven-项目"><span class="nav-number">2.1.</span> <span class="nav-text">2.1 创建 Maven 项目</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-1-增加-Scala-插件"><span class="nav-number">2.1.1.</span> <span class="nav-text">2.1.1 增加 Scala 插件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-2-增加依赖关系"><span class="nav-number">2.1.2.</span> <span class="nav-text">2.1.2 增加依赖关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-3-WordCount"><span class="nav-number">2.1.3.</span> <span class="nav-text">2.1.3 WordCount</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-4-异常处理"><span class="nav-number">2.1.4.</span> <span class="nav-text">2.1.4 异常处理</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第3章-Spark-运行环境"><span class="nav-number">3.</span> <span class="nav-text">第3章 Spark 运行环境</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-Local-模式"><span class="nav-number">3.1.</span> <span class="nav-text">3.1 Local 模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-1-解压缩文件"><span class="nav-number">3.1.1.</span> <span class="nav-text">3.1.1 解压缩文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-2-启动-Local-环境"><span class="nav-number">3.1.2.</span> <span class="nav-text">3.1.2 启动 Local 环境</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-3-命令行工具"><span class="nav-number">3.1.3.</span> <span class="nav-text">3.1.3 命令行工具</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-4-退出本地模式"><span class="nav-number">3.1.4.</span> <span class="nav-text">3.1.4 退出本地模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-5-提交应用"><span class="nav-number">3.1.5.</span> <span class="nav-text">3.1.5 提交应用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-Standalone-模式"><span class="nav-number">3.2.</span> <span class="nav-text">3.2 Standalone 模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-1-解压缩文件"><span class="nav-number">3.2.1.</span> <span class="nav-text">3.2.1 解压缩文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-2-修改配置文件"><span class="nav-number">3.2.2.</span> <span class="nav-text">3.2.2 修改配置文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-3-启动集群"><span class="nav-number">3.2.3.</span> <span class="nav-text">3.2.3 启动集群</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-4-提交应用"><span class="nav-number">3.2.4.</span> <span class="nav-text">3.2.4 提交应用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-5-提交参数说明"><span class="nav-number">3.2.5.</span> <span class="nav-text">3.2.5 提交参数说明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-6-配置历史服务"><span class="nav-number">3.2.6.</span> <span class="nav-text">3.2.6 配置历史服务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-7-配置高可用（-HA）"><span class="nav-number">3.2.7.</span> <span class="nav-text">3.2.7 配置高可用（ HA）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3-Yarn-模式"><span class="nav-number">3.3.</span> <span class="nav-text">3.3 Yarn 模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-1-解压缩文件"><span class="nav-number">3.3.1.</span> <span class="nav-text">3.3.1 解压缩文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-2-修改配置文件"><span class="nav-number">3.3.2.</span> <span class="nav-text">3.3.2 修改配置文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-3-启动-HDFS-以及-YARN-集群"><span class="nav-number">3.3.3.</span> <span class="nav-text">3.3.3 启动 HDFS 以及 YARN 集群</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-4-提交应用"><span class="nav-number">3.3.4.</span> <span class="nav-text">3.3.4 提交应用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-5-配置历史服务器"><span class="nav-number">3.3.5.</span> <span class="nav-text">3.3.5 配置历史服务器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-4-K8S-amp-Mesos-模式"><span class="nav-number">3.4.</span> <span class="nav-text">3.4 K8S &amp; Mesos 模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-5-Windows-模式"><span class="nav-number">3.5.</span> <span class="nav-text">3.5 Windows 模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-1-解压缩文件"><span class="nav-number">3.5.1.</span> <span class="nav-text">3.5.1 解压缩文件</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-2-启动本地环境"><span class="nav-number">3.5.2.</span> <span class="nav-text">3.5.2 启动本地环境</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-3-命令行提交应用"><span class="nav-number">3.5.3.</span> <span class="nav-text">3.5.3 命令行提交应用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-6-部署模式对比"><span class="nav-number">3.6.</span> <span class="nav-text">3.6 部署模式对比</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-7-端口号"><span class="nav-number">3.7.</span> <span class="nav-text">3.7 端口号</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第4章-Spark-运行架构"><span class="nav-number">4.</span> <span class="nav-text">第4章 Spark 运行架构</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#4-1-运行架构"><span class="nav-number">4.1.</span> <span class="nav-text">4.1 运行架构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-2-核心组件"><span class="nav-number">4.2.</span> <span class="nav-text">4.2 核心组件</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-1-Driver"><span class="nav-number">4.2.1.</span> <span class="nav-text">4.2.1 Driver</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-2-Executor"><span class="nav-number">4.2.2.</span> <span class="nav-text">4.2.2 Executor</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-3-Master-amp-Worker"><span class="nav-number">4.2.3.</span> <span class="nav-text">4.2.3 Master &amp; Worker</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-4-ApplicationMaster"><span class="nav-number">4.2.4.</span> <span class="nav-text">4.2.4 ApplicationMaster</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-3-核心概念"><span class="nav-number">4.3.</span> <span class="nav-text">4.3 核心概念</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-1-Executor-与-Core"><span class="nav-number">4.3.1.</span> <span class="nav-text">4.3.1 Executor 与 Core</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-2-并行度（-Parallelism）"><span class="nav-number">4.3.2.</span> <span class="nav-text">4.3.2 并行度（ Parallelism）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-3-有向无环图（-DAG）"><span class="nav-number">4.3.3.</span> <span class="nav-text">4.3.3 有向无环图（ DAG）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-4-提交流程"><span class="nav-number">4.4.</span> <span class="nav-text">4.4 提交流程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-1-Yarn-Client-模式"><span class="nav-number">4.4.1.</span> <span class="nav-text">4.4.1 Yarn Client 模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-2-Yarn-Cluster-模式"><span class="nav-number">4.4.2.</span> <span class="nav-text">4.4.2 Yarn Cluster 模式</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第5章-Spark-核心编程"><span class="nav-number">5.</span> <span class="nav-text">第5章 Spark 核心编程</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#5-1-RDD"><span class="nav-number">5.1.</span> <span class="nav-text">5.1 RDD</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-1-什么是-RDD"><span class="nav-number">5.1.1.</span> <span class="nav-text">5.1.1 什么是 RDD</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-2-核心属性"><span class="nav-number">5.1.2.</span> <span class="nav-text">5.1.2 核心属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-3-执行原理"><span class="nav-number">5.1.3.</span> <span class="nav-text">5.1.3 执行原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-4-基础编程"><span class="nav-number">5.1.4.</span> <span class="nav-text">5.1.4 基础编程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-4-1-RDD-创建"><span class="nav-number">5.1.4.1.</span> <span class="nav-text">5.1.4.1 RDD 创建</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-4-2-RDD-并行度与分区"><span class="nav-number">5.1.4.2.</span> <span class="nav-text">5.1.4.2 RDD 并行度与分区</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-4-3-RDD-转换算子"><span class="nav-number">5.1.4.3.</span> <span class="nav-text">5.1.4.3 RDD 转换算子</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Value类型"><span class="nav-number">5.1.4.3.1.</span> <span class="nav-text">Value类型</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#map"><span class="nav-number">5.1.4.3.1.1.</span> <span class="nav-text">map</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#mapPartitions"><span class="nav-number">5.1.4.3.1.2.</span> <span class="nav-text">mapPartitions</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#mapPartitionsWithIndex"><span class="nav-number">5.1.4.3.1.3.</span> <span class="nav-text">mapPartitionsWithIndex</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#flatMap"><span class="nav-number">5.1.4.3.1.4.</span> <span class="nav-text">flatMap</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#glom"><span class="nav-number">5.1.4.3.1.5.</span> <span class="nav-text">glom</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#groupBy"><span class="nav-number">5.1.4.3.1.6.</span> <span class="nav-text">groupBy</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#filter"><span class="nav-number">5.1.4.3.1.7.</span> <span class="nav-text">filter</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#sample"><span class="nav-number">5.1.4.3.1.8.</span> <span class="nav-text">sample</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#distinct"><span class="nav-number">5.1.4.3.1.9.</span> <span class="nav-text">distinct</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#coalesce"><span class="nav-number">5.1.4.3.1.10.</span> <span class="nav-text">coalesce</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#repartition"><span class="nav-number">5.1.4.3.1.11.</span> <span class="nav-text">repartition</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#sortBy"><span class="nav-number">5.1.4.3.1.12.</span> <span class="nav-text">sortBy</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#双-Value-类型"><span class="nav-number">5.1.4.3.2.</span> <span class="nav-text">双 Value 类型</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#intersection"><span class="nav-number">5.1.4.3.2.1.</span> <span class="nav-text">intersection</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#union"><span class="nav-number">5.1.4.3.2.2.</span> <span class="nav-text">union</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#subtract"><span class="nav-number">5.1.4.3.2.3.</span> <span class="nav-text">subtract</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#zip"><span class="nav-number">5.1.4.3.2.4.</span> <span class="nav-text">zip</span></a></li></ol></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Key-Value-类型"><span class="nav-number">5.1.4.3.3.</span> <span class="nav-text">Key - Value 类型</span></a><ol class="nav-child"><li class="nav-item nav-level-6"><a class="nav-link" href="#partitionBy"><span class="nav-number">5.1.4.3.3.1.</span> <span class="nav-text">partitionBy</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#reduceByKey"><span class="nav-number">5.1.4.3.3.2.</span> <span class="nav-text">reduceByKey</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#groupByKey"><span class="nav-number">5.1.4.3.3.3.</span> <span class="nav-text">groupByKey</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#aggregateByKey"><span class="nav-number">5.1.4.3.3.4.</span> <span class="nav-text">aggregateByKey</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#foldByKey"><span class="nav-number">5.1.4.3.3.5.</span> <span class="nav-text">foldByKey</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#combineByKey"><span class="nav-number">5.1.4.3.3.6.</span> <span class="nav-text">combineByKey</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#sortByKey"><span class="nav-number">5.1.4.3.3.7.</span> <span class="nav-text">sortByKey</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#join"><span class="nav-number">5.1.4.3.3.8.</span> <span class="nav-text">join</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#leftOuterJoin"><span class="nav-number">5.1.4.3.3.9.</span> <span class="nav-text">leftOuterJoin</span></a></li><li class="nav-item nav-level-6"><a class="nav-link" href="#cogroup"><span class="nav-number">5.1.4.3.3.10.</span> <span class="nav-text">cogroup</span></a></li></ol></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-4-4-案例实操"><span class="nav-number">5.1.4.4.</span> <span class="nav-text">5.1.4.4 案例实操</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-4-5-RDD-行动算子"><span class="nav-number">5.1.4.5.</span> <span class="nav-text">5.1.4.5 RDD 行动算子</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#reduce"><span class="nav-number">5.1.4.5.1.</span> <span class="nav-text">reduce</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#collect"><span class="nav-number">5.1.4.5.2.</span> <span class="nav-text">collect</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#count"><span class="nav-number">5.1.4.5.3.</span> <span class="nav-text">count</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#first"><span class="nav-number">5.1.4.5.4.</span> <span class="nav-text">first</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#take"><span class="nav-number">5.1.4.5.5.</span> <span class="nav-text">take</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#takeOrdered"><span class="nav-number">5.1.4.5.6.</span> <span class="nav-text">takeOrdered</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#aggregate"><span class="nav-number">5.1.4.5.7.</span> <span class="nav-text">aggregate</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#fold"><span class="nav-number">5.1.4.5.8.</span> <span class="nav-text">fold</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#countByKey"><span class="nav-number">5.1.4.5.9.</span> <span class="nav-text">countByKey</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#save-相关算子"><span class="nav-number">5.1.4.5.10.</span> <span class="nav-text">save 相关算子</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#foreach"><span class="nav-number">5.1.4.5.11.</span> <span class="nav-text">foreach</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-4-6-RDD-序列化"><span class="nav-number">5.1.4.6.</span> <span class="nav-text">5.1.4.6 RDD 序列化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-4-7-RDD-依赖关系"><span class="nav-number">5.1.4.7.</span> <span class="nav-text">5.1.4.7 RDD 依赖关系</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#RDD-血缘关系"><span class="nav-number">5.1.4.7.1.</span> <span class="nav-text">RDD 血缘关系</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#RDD-依赖关系"><span class="nav-number">5.1.4.7.2.</span> <span class="nav-text">RDD 依赖关系</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#RDD-窄依赖"><span class="nav-number">5.1.4.7.3.</span> <span class="nav-text">RDD 窄依赖</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#RDD-宽依赖"><span class="nav-number">5.1.4.7.4.</span> <span class="nav-text">RDD 宽依赖</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#RDD-阶段划分"><span class="nav-number">5.1.4.7.5.</span> <span class="nav-text">RDD 阶段划分</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#RDD-阶段划分源码"><span class="nav-number">5.1.4.7.6.</span> <span class="nav-text">RDD 阶段划分源码</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#RDD-任务划分"><span class="nav-number">5.1.4.7.7.</span> <span class="nav-text">RDD 任务划分</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#RDD-任务划分源码"><span class="nav-number">5.1.4.7.8.</span> <span class="nav-text">RDD 任务划分源码</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#RDD-窄依赖与宽依赖的阶段任务区别"><span class="nav-number">5.1.4.7.9.</span> <span class="nav-text">RDD 窄依赖与宽依赖的阶段任务区别</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-4-8-RDD-持久化"><span class="nav-number">5.1.4.8.</span> <span class="nav-text">5.1.4.8 RDD 持久化</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#RDD-Cache-缓存"><span class="nav-number">5.1.4.8.1.</span> <span class="nav-text">RDD Cache 缓存</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#RDD-CheckPoint-检查点"><span class="nav-number">5.1.4.8.2.</span> <span class="nav-text">RDD CheckPoint 检查点</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#缓存和检查点区别"><span class="nav-number">5.1.4.8.3.</span> <span class="nav-text">缓存和检查点区别</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-4-9-RDD-分区器"><span class="nav-number">5.1.4.9.</span> <span class="nav-text">5.1.4.9 RDD 分区器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-1-4-10-RDD-文件读取与保存"><span class="nav-number">5.1.4.10.</span> <span class="nav-text">5.1.4.10 RDD 文件读取与保存</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-2-累加器"><span class="nav-number">5.2.</span> <span class="nav-text">5.2 累加器</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-1-实现原理"><span class="nav-number">5.2.1.</span> <span class="nav-text">5.2.1 实现原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-2-基础编程"><span class="nav-number">5.2.2.</span> <span class="nav-text">5.2.2 基础编程</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-2-1-系统累加器"><span class="nav-number">5.2.2.1.</span> <span class="nav-text">5.2.2.1 系统累加器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-2-2-2-自定义累加器"><span class="nav-number">5.2.2.2.</span> <span class="nav-text">5.2.2.2 自定义累加器</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-3-广播变量"><span class="nav-number">5.3.</span> <span class="nav-text">5.3 广播变量</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-1-实现原理"><span class="nav-number">5.3.1.</span> <span class="nav-text">5.3.1 实现原理</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-2-基础编程"><span class="nav-number">5.3.2.</span> <span class="nav-text">5.3.2 基础编程</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第6章-Spark-案例实操"><span class="nav-number">6.</span> <span class="nav-text">第6章 Spark 案例实操</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#6-1-需求-1：Top10-热门品类"><span class="nav-number">6.1.</span> <span class="nav-text">6.1 需求 1：Top10 热门品类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-1-需求说明"><span class="nav-number">6.1.1.</span> <span class="nav-text">6.1.1 需求说明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-2-实现方案一"><span class="nav-number">6.1.2.</span> <span class="nav-text">6.1.2 实现方案一</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-1-2-1-需求分析"><span class="nav-number">6.1.2.1.</span> <span class="nav-text">6.1.2.1 需求分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-1-2-2-需求实现"><span class="nav-number">6.1.2.2.</span> <span class="nav-text">6.1.2.2 需求实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-3-实现方案二"><span class="nav-number">6.1.3.</span> <span class="nav-text">6.1.3 实现方案二</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-1-3-1-需求分析"><span class="nav-number">6.1.3.1.</span> <span class="nav-text">6.1.3.1 需求分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-1-3-2-需求实现"><span class="nav-number">6.1.3.2.</span> <span class="nav-text">6.1.3.2 需求实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-4-实现方案三"><span class="nav-number">6.1.4.</span> <span class="nav-text">6.1.4 实现方案三</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#6-1-4-1-需求分析"><span class="nav-number">6.1.4.1.</span> <span class="nav-text">6.1.4.1 需求分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-1-4-2-需求实现"><span class="nav-number">6.1.4.2.</span> <span class="nav-text">6.1.4.2 需求实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-2-需求-2：Top10-热门品类中每个品类的-Top10-活跃-Session-统计"><span class="nav-number">6.2.</span> <span class="nav-text">6.2 需求 2：Top10 热门品类中每个品类的 Top10 活跃 Session 统计</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-1-需求说明"><span class="nav-number">6.2.1.</span> <span class="nav-text">6.2.1 需求说明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-2-需求分析"><span class="nav-number">6.2.2.</span> <span class="nav-text">6.2.2 需求分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-3-功能实现"><span class="nav-number">6.2.3.</span> <span class="nav-text">6.2.3 功能实现</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-3-需求-3：页面单跳转换率统计"><span class="nav-number">6.3.</span> <span class="nav-text">6.3 需求 3：页面单跳转换率统计</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-1-需求说明"><span class="nav-number">6.3.1.</span> <span class="nav-text">6.3.1 需求说明</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-2-需求分析"><span class="nav-number">6.3.2.</span> <span class="nav-text">6.3.2 需求分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-3-功能实现"><span class="nav-number">6.3.3.</span> <span class="nav-text">6.3.3 功能实现</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第七章-三层架构"><span class="nav-number">7.</span> <span class="nav-text">第七章 三层架构</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Rui Zhang"
      src="/images/head.jpg">
  <p class="site-author-name" itemprop="name">Rui Zhang</p>
  <div class="site-description" itemprop="description">不在沉默中爆发，就在沉默中灭亡</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">52</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">22</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">22</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2021 – 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Rui Zhang</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">1.7m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">25:10</span>
</div>




        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":120,"height":230},"mobile":{"show":true},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/clicklove.js"></script>
