<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Gemini","version":"7.7.2","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="第 1 章 Explain 查看执行计划在 clickhouse 20.6 版本之前要查看 SQL 语句的执行计划需要设置日志级别为 trace 才能可以看到， 并且只能真正执行 sql，在执行日志里面查看。 在 20.6 版本引入了原生的执行计划的语法。在 20.6.3 版本成为正式版本的功能。   本文档基于目前较新稳定版 21.7.3.14。   1.1 基本语法12EXPLAIN [AST">
<meta property="og:type" content="article">
<meta property="og:title" content="ClickHouse高级进阶">
<meta property="og:url" content="http://yoursite.com/2024/09/23/ClickHouse%E9%AB%98%E7%BA%A7%E8%BF%9B%E9%98%B6/index.html">
<meta property="og:site_name" content="没有尾巴的小驴">
<meta property="og:description" content="第 1 章 Explain 查看执行计划在 clickhouse 20.6 版本之前要查看 SQL 语句的执行计划需要设置日志级别为 trace 才能可以看到， 并且只能真正执行 sql，在执行日志里面查看。 在 20.6 版本引入了原生的执行计划的语法。在 20.6.3 版本成为正式版本的功能。   本文档基于目前较新稳定版 21.7.3.14。   1.1 基本语法12EXPLAIN [AST">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://yoursite.com/2024/09/23/ClickHouse%E9%AB%98%E7%BA%A7%E8%BF%9B%E9%98%B6/image-20240923183211569.png">
<meta property="og:image" content="http://yoursite.com/2024/09/23/ClickHouse%E9%AB%98%E7%BA%A7%E8%BF%9B%E9%98%B6/image-20240926182817176.png">
<meta property="og:image" content="http://yoursite.com/2024/09/23/ClickHouse%E9%AB%98%E7%BA%A7%E8%BF%9B%E9%98%B6/image-20241022102453303.png">
<meta property="article:published_time" content="2024-09-23T07:00:15.000Z">
<meta property="article:modified_time" content="2025-06-25T08:08:45.236Z">
<meta property="article:author" content="Rui Zhang">
<meta property="article:tag" content="ClickHouse">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/2024/09/23/ClickHouse%E9%AB%98%E7%BA%A7%E8%BF%9B%E9%98%B6/image-20240923183211569.png">

<link rel="canonical" href="http://yoursite.com/2024/09/23/ClickHouse%E9%AB%98%E7%BA%A7%E8%BF%9B%E9%98%B6/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true
  };
</script>

  <title>ClickHouse高级进阶 | 没有尾巴的小驴</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">没有尾巴的小驴</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">记录生活</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-fw fa-user"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签<span class="badge">22</span></a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类<span class="badge">22</span></a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档<span class="badge">52</span></a>

  </li>
  </ul>

</nav>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block " lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2024/09/23/ClickHouse%E9%AB%98%E7%BA%A7%E8%BF%9B%E9%98%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/head.jpg">
      <meta itemprop="name" content="Rui Zhang">
      <meta itemprop="description" content="不在沉默中爆发，就在沉默中灭亡">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="没有尾巴的小驴">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          ClickHouse高级进阶
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2024-09-23 15:00:15" itemprop="dateCreated datePublished" datetime="2024-09-23T15:00:15+08:00">2024-09-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2025-06-25 16:08:45" itemprop="dateModified" datetime="2025-06-25T16:08:45+08:00">2025-06-25</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ClickHouse/" itemprop="url" rel="index"><span itemprop="name">ClickHouse</span></a>
                </span>
            </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="fa fa-file-word-o"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>26k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="fa fa-clock-o"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>24 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h1 id="第-1-章-Explain-查看执行计划"><a href="#第-1-章-Explain-查看执行计划" class="headerlink" title="第 1 章 Explain 查看执行计划"></a>第 1 章 Explain 查看执行计划</h1><p>在 clickhouse 20.6 版本之前要查看 SQL 语句的执行计划需要设置日志级别为 trace 才能可以看到， 并且只能真正执行 sql，在执行日志里面查看。 在 20.6 版本引入了原生的执行计划的语法。在 20.6.3 版本成为正式版本的功能。 </p>
<p> 本文档基于目前较新稳定版 21.7.3.14。  </p>
<h2 id="1-1-基本语法"><a href="#1-1-基本语法" class="headerlink" title="1.1 基本语法"></a>1.1 基本语法</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> [AST | SYNTAX | PLAN | PIPELINE] [setting = <span class="keyword">value</span>, ...]</span><br><span class="line"><span class="keyword">SELECT</span> ... [<span class="keyword">FORMAT</span> ...]</span><br></pre></td></tr></table></figure>

<ul>
<li><p>PLAN： 用于查看执行计划，默认值。</p>
<ul>
<li>header 打印计划中各个步骤的 head 说明，默认关闭，默认值 0;</li>
<li>description 打印计划中各个步骤的描述，默认开启，默认值 1；</li>
<li>actions 打印计划中各个步骤的详细信息，默认关闭，默认值 0。  </li>
</ul>
</li>
<li><p>AST ： 用于查看语法树;</p>
</li>
<li><p>SYNTAX： 用于优化语法;</p>
</li>
<li><p>PIPELINE： 用于查看 PIPELINE 计划。</p>
<ul>
<li>header 打印计划中各个步骤的 head 说明，默认关闭;</li>
<li>graph 用 DOT 图形语言描述管道图，默认关闭，需要查看相关的图形需要配合graphviz 查看；</li>
<li>actions 如果开启了 graph，紧凑打印打，默认开启。<br>注： PLAN 和 PIPELINE 还可以进行额外的显示设置，如上参数所示。  </li>
</ul>
</li>
</ul>
<h2 id="1-2-案例实操"><a href="#1-2-案例实操" class="headerlink" title="1.2 案例实操"></a>1.2 案例实操</h2><h3 id="1-2-1-新版本使用-EXPLAIN"><a href="#1-2-1-新版本使用-EXPLAIN" class="headerlink" title="1.2.1 新版本使用 EXPLAIN"></a>1.2.1 新版本使用 EXPLAIN</h3><p>可以再安装一个 20.6 以上版本，或者直接在官网的在线 demo，选择高版本进行测试。  </p>
<p>1） 查看 PLAIN  </p>
<p>简单查询  </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> plan <span class="keyword">select</span> arrayJoin([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="literal">null</span>,<span class="literal">null</span>]);</span><br></pre></td></tr></table></figure>

<p>复杂 SQL 的执行计划  </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> <span class="keyword">select</span> <span class="keyword">database</span>,<span class="keyword">table</span>,<span class="keyword">count</span>(<span class="number">1</span>) cnt <span class="keyword">from</span> system.parts <span class="keyword">where</span></span><br><span class="line"><span class="keyword">database</span> <span class="keyword">in</span> (<span class="string">'datasets'</span>,<span class="string">'system'</span>) <span class="keyword">group</span> <span class="keyword">by</span> <span class="keyword">database</span>,<span class="keyword">table</span> <span class="keyword">order</span> <span class="keyword">by</span></span><br><span class="line"><span class="keyword">database</span>,cnt <span class="keyword">desc</span> <span class="keyword">limit</span> <span class="number">2</span> <span class="keyword">by</span> <span class="keyword">database</span>;</span><br></pre></td></tr></table></figure>

<p>打开全部的参数的执行计划  </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> header=<span class="number">1</span>, actions=<span class="number">1</span>,description=<span class="number">1</span> <span class="keyword">SELECT</span> <span class="built_in">number</span> <span class="keyword">from</span></span><br><span class="line">system.numbers <span class="keyword">limit</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>2） AST 语法树  </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> AST <span class="keyword">SELECT</span> <span class="built_in">number</span> <span class="keyword">from</span> system.numbers <span class="keyword">limit</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure>

<p>3） SYNTAX 语法优化  </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//先做一次查询</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">number</span> = <span class="number">1</span> ? <span class="string">'hello'</span> : (<span class="built_in">number</span> = <span class="number">2</span> ? <span class="string">'world'</span> : <span class="string">'atguigu'</span>) <span class="keyword">FROM</span></span><br><span class="line">numbers(<span class="number">10</span>);</span><br><span class="line">//查看语法优化</span><br><span class="line"><span class="keyword">EXPLAIN</span> SYNTAX <span class="keyword">SELECT</span> <span class="built_in">number</span> = <span class="number">1</span> ? <span class="string">'hello'</span> : (<span class="built_in">number</span> = <span class="number">2</span> ? <span class="string">'world'</span> :</span><br><span class="line"><span class="string">'atguigu'</span>) <span class="keyword">FROM</span> numbers(<span class="number">10</span>);</span><br><span class="line">//开启三元运算符优化</span><br><span class="line"><span class="keyword">SET</span> optimize_if_chain_to_multiif = <span class="number">1</span>;</span><br><span class="line">//再次查看语法优化</span><br><span class="line"><span class="keyword">EXPLAIN</span> SYNTAX <span class="keyword">SELECT</span> <span class="built_in">number</span> = <span class="number">1</span> ? <span class="string">'hello'</span> : (<span class="built_in">number</span> = <span class="number">2</span> ? <span class="string">'world'</span> :</span><br><span class="line"><span class="string">'atguigu'</span>) <span class="keyword">FROM</span> numbers(<span class="number">10</span>);</span><br><span class="line">//返回优化后的语句</span><br><span class="line"><span class="keyword">SELECT</span> multiIf(<span class="built_in">number</span> = <span class="number">1</span>, \<span class="string">'hello\'</span>, <span class="built_in">number</span> = <span class="number">2</span>, \<span class="string">'world\'</span>, \<span class="string">'xyz\'</span>)</span><br><span class="line"><span class="keyword">FROM</span> numbers(<span class="number">10</span>)</span><br></pre></td></tr></table></figure>

<p>4）查看 PIPELINE  </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> PIPELINE <span class="keyword">SELECT</span> <span class="keyword">sum</span>(<span class="built_in">number</span>) <span class="keyword">FROM</span> numbers_mt(<span class="number">100000</span>) <span class="keyword">GROUP</span> <span class="keyword">BY</span></span><br><span class="line"><span class="built_in">number</span> % <span class="number">20</span>;</span><br><span class="line">//打开其他参数</span><br><span class="line"><span class="keyword">EXPLAIN</span> PIPELINE header=<span class="number">1</span>,graph=<span class="number">1</span> <span class="keyword">SELECT</span> <span class="keyword">sum</span>(<span class="built_in">number</span>) <span class="keyword">FROM</span></span><br><span class="line">numbers_mt(<span class="number">10000</span>) <span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="built_in">number</span>%<span class="number">20</span>;</span><br></pre></td></tr></table></figure>

<h3 id="1-2-2-老版本查看执行计划"><a href="#1-2-2-老版本查看执行计划" class="headerlink" title="1.2.2 老版本查看执行计划"></a>1.2.2 老版本查看执行计划</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clickhouse-client -h 主机名 --send_logs_level=trace &lt;&lt;&lt; "sql" &gt; /dev/null</span><br></pre></td></tr></table></figure>

<p>其中， send_logs_level 参数指定日志等级为 trace， &lt;&lt;&lt;将 SQL 语句重定向至 clickhouse-client 进行查询， &gt; /dev/null 将查询结果重定向到空设备吞掉，以便观察日志。  </p>
<p>注意：<br>1、 通过将 ClickHouse 的服务日志，设置到 DEBUG 或者 TRACE 级别， 才可以变相实现<br>EXPLAIN 查询的作用。<br>2、 需要真正的执行 SQL 查询， CH 才能打印计划日志，所以如果表的数据量很大，最好<br>借助 LIMIT 子句，减小查询返回的数据量。  </p>
<h1 id="第-2-章-建表优化"><a href="#第-2-章-建表优化" class="headerlink" title="第 2 章 建表优化"></a>第 2 章 建表优化</h1><h2 id="2-1-数据类型"><a href="#2-1-数据类型" class="headerlink" title="2.1 数据类型"></a>2.1 数据类型</h2><h3 id="2-1-1-时间字段的类型"><a href="#2-1-1-时间字段的类型" class="headerlink" title="2.1.1 时间字段的类型"></a>2.1.1 时间字段的类型</h3><p>建表时能用数值型或日期时间型表示的字段就不要用字符串，全 String 类型在以 Hive为中心的数仓建设中常见，但 ClickHouse 环境不应受此影响。</p>
<p>虽然 ClickHouse 底层将 DateTime 存储为时间戳 Long 类型，但不建议存储 Long 类型，因为 DateTime 不需要经过函数转换处理，执行效率高、可读性好。  </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> t_type2(</span><br><span class="line">    <span class="keyword">id</span> UInt32,</span><br><span class="line">    sku_id <span class="keyword">String</span>,</span><br><span class="line">    total_amount <span class="built_in">Decimal</span>(<span class="number">16</span>,<span class="number">2</span>) ,</span><br><span class="line">    create_time Int32</span><br><span class="line">) <span class="keyword">engine</span> =ReplacingMergeTree(create_time)</span><br><span class="line">    <span class="keyword">partition</span> <span class="keyword">by</span> toYYYYMMDD(toDate(create_time)) –-需要转换一次，否则报错</span><br><span class="line">    primary <span class="keyword">key</span> (<span class="keyword">id</span>)</span><br><span class="line">    <span class="keyword">order</span> <span class="keyword">by</span> (<span class="keyword">id</span>, sku_id);</span><br></pre></td></tr></table></figure>

<h3 id="2-1-2-空值存储类型"><a href="#2-1-2-空值存储类型" class="headerlink" title="2.1.2 空值存储类型"></a>2.1.2 空值存储类型</h3><p>官方已经指出 Nullable 类型几乎总是会拖累性能，因为<strong>存储 Nullable 列时需要创建一个额外的文件来存储 NULL 的标记</strong>，并且 <strong>Nullable 列无法被索引</strong>。因此除非极特殊情况，应直接使用字段默认值表示空，或者自行指定一个在业务中无意义的值（例如用-1 表示没有商品ID）。  </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> t_null(x <span class="built_in">Int8</span>, y Nullable(<span class="built_in">Int8</span>)) <span class="keyword">ENGINE</span> TinyLog;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> t_null <span class="keyword">VALUES</span> (<span class="number">1</span>, <span class="literal">NULL</span>), (<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">SELECT</span> x + y <span class="keyword">FROM</span> t_null;</span><br></pre></td></tr></table></figure>

<p>查看存储的文件： （没有权限就用 root 用户）  </p>
<p><img src="/2024/09/23/ClickHouse%E9%AB%98%E7%BA%A7%E8%BF%9B%E9%98%B6/image-20240923183211569.png" alt="image-20240923183211569"></p>
<p>官网说明： <a href="https://clickhouse.tech/docs/zh/sql-reference/data-types/nullable/" target="_blank" rel="noopener">https://clickhouse.tech/docs/zh/sql-reference/data-types/nullable/</a>  </p>
<h2 id="2-2-分区和索引"><a href="#2-2-分区和索引" class="headerlink" title="2.2 分区和索引"></a>2.2 分区和索引</h2><p>分区粒度根据业务特点决定，不宜过粗或过细。一般选择按天分区，也可以指定为 Tuple()，以单表一亿数据为例，分区大小控制在 10-30 个为最佳。</p>
<p>必须指定索引列， ClickHouse 中的索引列即排序列，通过 order by 指定，一般在查询条件中经常被用来充当筛选条件的属性被纳入进来；可以是单一维度，也可以是组合维度的索引；通常需要满足高级列在前、查询频率大的在前原则；还有基数特别大的不适合做索引列，如用户表的 userid 字段；通常筛选后的数据满足在百万以内为最佳。  </p>
<p>比如官方案例的 hits_v1 表：  </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">……</span><br><span class="line">PARTITION BY toYYYYMM(EventDate)</span><br><span class="line">ORDER BY (CounterID, EventDate, intHash32(UserID))</span><br><span class="line">……</span><br></pre></td></tr></table></figure>

<p>visits_v1 表：  </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">……</span><br><span class="line">PARTITION BY toYYYYMM(StartDate)</span><br><span class="line">ORDER BY (CounterID, StartDate, intHash32(UserID), VisitID)</span><br><span class="line">……</span><br></pre></td></tr></table></figure>

<h2 id="2-3-表参数"><a href="#2-3-表参数" class="headerlink" title="2.3 表参数"></a>2.3 表参数</h2><p>Index_granularity 是用来控制索引粒度的， 默认是 8192， 如非必须不建议调整。</p>
<p>如果表中不是必须保留全量历史数据，建议指定 TTL（生存时间值），可以免去手动过期历史数据的麻烦， TTL 也可以通过 alter table 语句随时修改。（参考基础文档 4.4.5 数据 TTL）  </p>
<h2 id="2-4-写入和删除优化"><a href="#2-4-写入和删除优化" class="headerlink" title="2.4 写入和删除优化"></a>2.4 写入和删除优化</h2><p>（1） 尽量不要执行单条或小批量删除和插入操作，这样会产生小分区文件，给后台<br>Merge 任务带来巨大压力<br>（2） 不要一次写入太多分区，或数据写入太快，数据写入太快会导致 Merge 速度跟不<br>上而报错，一般建议每秒钟发起 2-3 次写入操作，每次操作写入 2w~5w 条数据（依服务器<br>性能而定）</p>
<p>  写入过快报错， 报错信息：  </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. Code: 252, e.displayText() = DB::Exception: Too many parts(304).</span><br><span class="line">Merges are processing significantly slower than inserts</span><br><span class="line">2. Code: 241, e.displayText() = DB::Exception: Memory limit (for query)</span><br><span class="line">exceeded:would <span class="keyword">use</span> <span class="number">9.37</span> GiB (attempt <span class="keyword">to</span> <span class="keyword">allocate</span> <span class="keyword">chunk</span> <span class="keyword">of</span> <span class="number">301989888</span></span><br><span class="line"><span class="keyword">bytes</span>), maximum: <span class="number">9.31</span> GiB</span><br></pre></td></tr></table></figure>

<p>处理方式：<br>“ Too many parts 处理 ” ：使用 WAL 预写日志，提高写入性能。in_memory_parts_enable_wal 默认为 true</p>
<p>在服务器内存充裕的情况下增加内存配额，一般通过 max_memory_usage 来实现</p>
<p>在服务器内存不充裕的情况下，建议将超出部分内容分配到系统硬盘上，但会降低执行速度，一般通过 max_bytes_before_external_group_by、max_bytes_before_external_sort 参数来实现。  </p>
<h2 id="2-5-常见配置"><a href="#2-5-常见配置" class="headerlink" title="2.5 常见配置"></a>2.5 常见配置</h2><p>配置项主要在 config.xml 或 users.xml 中， 基本上都在 users.xml 里  </p>
<ul>
<li>config.xml 的配置项<br><a href="https://clickhouse.tech/docs/en/operations/server-configuration-parameters/settings/" target="_blank" rel="noopener">https://clickhouse.tech/docs/en/operations/server-configuration-parameters/settings/</a></li>
<li>users.xml 的配置项<br><a href="https://clickhouse.tech/docs/en/operations/settings/settings/" target="_blank" rel="noopener">https://clickhouse.tech/docs/en/operations/settings/settings/</a>  </li>
</ul>
<h3 id="2-5-1-CPU-资源"><a href="#2-5-1-CPU-资源" class="headerlink" title="2.5.1 CPU 资源"></a>2.5.1 CPU 资源</h3><table>
<thead>
<tr>
<th>配置</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>background_pool_size</td>
<td>后台线程池的大小， merge 线程就是在该线程池中执行，该线程池 不仅仅是给 merge 线程用的，默认值 16，允许的前提下建议改成 c pu 个数的 2 倍（线程数） 。</td>
</tr>
<tr>
<td>background_schedule_pool_size</td>
<td>执行后台任务（ 复制表、 Kafka 流、 DNS 缓存更新） 的线程数。 默 认 128， 建议改成 cpu 个数的 2 倍（线程数）。</td>
</tr>
<tr>
<td>background_distributed_schedule_ pool_size</td>
<td>设置为分布式发送执行后台任务的线程数，默认 16， 建议改成 cpu 个数的 2 倍（线程数） 。</td>
</tr>
<tr>
<td>max_concurrent_queries</td>
<td>最大并发处理的请求数(包含 select,insert 等)，默认值 100，推荐 1 50(不够再加)~300。</td>
</tr>
<tr>
<td>max_threads</td>
<td>设置单个查询所能使用的最大 cpu 个数，默认是 cpu 核数</td>
</tr>
</tbody></table>
<h3 id="2-5-2-内存资源"><a href="#2-5-2-内存资源" class="headerlink" title="2.5.2 内存资源"></a>2.5.2 内存资源</h3><table>
<thead>
<tr>
<th>配置</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>max_memory_usage</td>
<td>此参数在 users.xml 中,表示单次 Query 占用内存最大值，该值可 以设置的比较大，这样可以提升集群查询的上限。 保留一点给 OS，比如 128G 内存的机器，设置为 100GB。</td>
</tr>
<tr>
<td>max_bytes_before_external_group_ by</td>
<td>一般按照 max_memory_usage 的一半设置内存，当 group 使用内 存超过阈值后会刷新到磁盘进行。 因为 clickhouse 聚合分两个阶段：查询并及建立中间数据、合并中 间数据， 结合上一项，建议 50GB。</td>
</tr>
<tr>
<td>max_bytes_before_external_sort</td>
<td>当 order by 已使用 max_bytes_before_external_sort 内存就进行 溢写磁盘(基于磁盘排序)，如果不设置该值，那么当内存不够时直接 抛错，设置了该值 order by 可以正常完成，但是速度相对存内存来 说肯定要慢点(实测慢的非常多，无法接受)。</td>
</tr>
<tr>
<td>max_table_size_to_drop</td>
<td>此参数在 config.xml 中，应用于需要删除表或分区的情况，默认是 50GB，意思是如果删除 50GB 以上的分区表会失败。 建议修改为 0， 这样不管多大的分区表都可以删除。</td>
</tr>
</tbody></table>
<h3 id="2-5-3-存储"><a href="#2-5-3-存储" class="headerlink" title="2.5.3 存储"></a>2.5.3 存储</h3><p>ClickHouse 不支持设置多数据目录，为了提升数据 io 性能，可以挂载虚拟券组，一个券组绑定多块物理磁盘提升读写性能，多数据查询场景 SSD 会比普通机械硬盘快 2-3 倍。  </p>
<h1 id="第-3-章-ClickHouse-语法优化规则"><a href="#第-3-章-ClickHouse-语法优化规则" class="headerlink" title="第 3 章 ClickHouse 语法优化规则"></a>第 3 章 ClickHouse 语法优化规则</h1><p>ClickHouse 的 SQL 优化规则是基于 RBO(Rule Based Optimization)，下面是一些优化规则  </p>
<h2 id="3-1-准备测试用表"><a href="#3-1-准备测试用表" class="headerlink" title="3.1 准备测试用表"></a>3.1 准备测试用表</h2><p>1） 上传官方的数据集  </p>
<p>将 visits_v1.tar 和 hits_v1.tar 上传到虚拟机，解压到 clickhouse 数据路径下  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 解压到 clickhouse 数据路径</span><br><span class="line">sudo tar -xvf hits_v1.tar -C /var/lib/clickhouse</span><br><span class="line">sudo tar -xvf visits_v1.tar -C /var/lib/clickhouse</span><br><span class="line">//修改所属用户</span><br><span class="line">sudo chown -R clickhouse:clickhouse /var/lib/clickhouse/data/datasets</span><br><span class="line">sudo chown -R clickhouse:clickhouse /var/lib/clickhouse/metadata/datasets</span><br></pre></td></tr></table></figure>

<p>2） 重启 clickhouse-server  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo clickhouse restart</span><br></pre></td></tr></table></figure>

<p>3） 执行查询  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">clickhouse-client --query "SELECT COUNT(*) FROM datasets.hits_v1"</span><br><span class="line">clickhouse-client --query "SELECT COUNT(*) FROM datasets.visits_v1"</span><br></pre></td></tr></table></figure>

<p>注意：官方的 tar 包，包含了建库、建表语句、数据内容，这种方式不需要手动建库、建表，最方便。<br>hits_v1 表有 130 多个字段， 880 多万条数据<br>visits_v1 表有 180 多个字段， 160 多万条数据  </p>
<h2 id="3-2-COUNT-优化"><a href="#3-2-COUNT-优化" class="headerlink" title="3.2 COUNT 优化"></a>3.2 COUNT 优化</h2><p>在调用 count 函数时， 如果使用的是 count() 或者 count(*)， 且没有 where 条件， 则会直接使用 system.tables 的 total_rows， 例如:  </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> <span class="keyword">count</span>()<span class="keyword">FROM</span> datasets.hits_v1;</span><br><span class="line"></span><br><span class="line">Union</span><br><span class="line">	Expression (Projection)</span><br><span class="line">		Expression (Before ORDER BY and <span class="keyword">SELECT</span>)</span><br><span class="line">			MergingAggregated</span><br><span class="line">				ReadNothing (Optimized trivial <span class="keyword">count</span>)</span><br></pre></td></tr></table></figure>

<p>注意 Optimized trivial count ，这是对 count 的优化。<br>如果 count 具体的列字段，则不会使用此项优化：  </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> <span class="keyword">SELECT</span> <span class="keyword">count</span>(CounterID) <span class="keyword">FROM</span> datasets.hits_v1;</span><br><span class="line">Union</span><br><span class="line">	Expression (Projection)</span><br><span class="line">		Expression (Before ORDER BY and <span class="keyword">SELECT</span>)</span><br><span class="line">			Aggregating</span><br><span class="line">				Expression (<span class="keyword">Before</span> <span class="keyword">GROUP</span> <span class="keyword">BY</span>)</span><br><span class="line">					ReadFromStorage (<span class="keyword">Read</span> <span class="keyword">from</span> MergeTree)</span><br></pre></td></tr></table></figure>

<h2 id="3-3-消除子查询重复字段"><a href="#3-3-消除子查询重复字段" class="headerlink" title="3.3 消除子查询重复字段"></a>3.3 消除子查询重复字段</h2><p>下面语句子查询中有两个重复的 id 字段， 会被去重:  </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> SYNTAX <span class="keyword">SELECT</span></span><br><span class="line">    a.UserID,</span><br><span class="line">    b.VisitID,</span><br><span class="line">    a.URL,</span><br><span class="line">    b.UserID</span><br><span class="line">    <span class="keyword">FROM</span></span><br><span class="line">    hits_v1 <span class="keyword">AS</span> a</span><br><span class="line">    <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> (</span><br><span class="line">        <span class="keyword">SELECT</span></span><br><span class="line">            UserID,</span><br><span class="line">            UserID <span class="keyword">as</span> HaHa,	</span><br><span class="line">            VisitID</span><br><span class="line">        <span class="keyword">FROM</span> visits_v1) <span class="keyword">AS</span> b</span><br><span class="line">    <span class="keyword">USING</span> (UserID)</span><br><span class="line">    <span class="keyword">limit</span> <span class="number">3</span>;</span><br><span class="line">	</span><br><span class="line">//返回优化语句：</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    UserID,</span><br><span class="line">    VisitID,</span><br><span class="line">    <span class="keyword">URL</span>,</span><br><span class="line">    b.UserID</span><br><span class="line"><span class="keyword">FROM</span> hits_v1 <span class="keyword">AS</span> a</span><br><span class="line"><span class="keyword">ALL</span> <span class="keyword">LEFT</span> <span class="keyword">JOIN</span></span><br><span class="line">(</span><br><span class="line">    <span class="keyword">SELECT</span></span><br><span class="line">        UserID,</span><br><span class="line">        VisitID</span><br><span class="line">    <span class="keyword">FROM</span> visits_v1</span><br><span class="line">) <span class="keyword">AS</span> b <span class="keyword">USING</span> (UserID)</span><br><span class="line"><span class="keyword">LIMIT</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>

<h2 id="3-4-谓词下推"><a href="#3-4-谓词下推" class="headerlink" title="3.4 谓词下推"></a>3.4 谓词下推</h2><p>当 group by 有 having 子句，但是没有 with cube、 with rollup 或者 with totals 修饰的时候， having 过滤会下推到 where 提前过滤。例如下面的查询， HAVING name 变成了 WHERE name，在 group by 之前过滤：</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> SYNTAX </span><br><span class="line">    <span class="keyword">SELECT</span> UserID <span class="keyword">FROM</span> hits_v1 <span class="keyword">GROUP</span> <span class="keyword">BY</span> UserID <span class="keyword">HAVING</span> UserID =<span class="string">'8585742290196126178'</span>;</span><br><span class="line">    </span><br><span class="line">//返回优化语句</span><br><span class="line"><span class="keyword">SELECT</span> UserID</span><br><span class="line"><span class="keyword">FROM</span> hits_v1</span><br><span class="line"><span class="keyword">WHERE</span> UserID = \<span class="string">'8585742290196126178\'</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> UserID</span><br></pre></td></tr></table></figure>

<p>子查询也支持谓词下推：  </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> SYNTAX</span><br><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">(</span><br><span class="line">    <span class="keyword">SELECT</span> UserID</span><br><span class="line">    <span class="keyword">FROM</span> visits_v1</span><br><span class="line">)</span><br><span class="line"><span class="keyword">WHERE</span> UserID = <span class="string">'8585742290196126178'</span></span><br><span class="line"></span><br><span class="line">//返回优化后的语句</span><br><span class="line"><span class="keyword">SELECT</span> UserID</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">(</span><br><span class="line">    <span class="keyword">SELECT</span> UserID</span><br><span class="line">    <span class="keyword">FROM</span> visits_v1</span><br><span class="line">    <span class="keyword">WHERE</span> UserID = \<span class="string">'8585742290196126178\'</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">WHERE</span> UserID = \<span class="string">'8585742290196126178\'</span></span><br></pre></td></tr></table></figure>

<p>再来一个复杂例子：  </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> SYNTAX</span><br><span class="line">    <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> (</span><br><span class="line">        <span class="keyword">SELECT</span></span><br><span class="line">        *</span><br><span class="line">        <span class="keyword">FROM</span></span><br><span class="line">        (</span><br><span class="line">        	<span class="keyword">SELECT</span></span><br><span class="line">        		UserID</span><br><span class="line">        	<span class="keyword">FROM</span> visits_v1)</span><br><span class="line">    <span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line">        <span class="keyword">SELECT</span></span><br><span class="line">        *</span><br><span class="line">        <span class="keyword">FROM</span></span><br><span class="line">        (</span><br><span class="line">        	<span class="keyword">SELECT</span></span><br><span class="line">        		UserID</span><br><span class="line">        	<span class="keyword">FROM</span> visits_v1)</span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">WHERE</span> UserID = <span class="string">'8585742290196126178'</span></span><br><span class="line">    </span><br><span class="line">//返回优化后的语句</span><br><span class="line"><span class="keyword">SELECT</span> UserID</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">(</span><br><span class="line">    <span class="keyword">SELECT</span> UserID</span><br><span class="line">    <span class="keyword">FROM</span></span><br><span class="line">    (</span><br><span class="line">        <span class="keyword">SELECT</span> UserID</span><br><span class="line">        <span class="keyword">FROM</span> visits_v1</span><br><span class="line">        <span class="keyword">WHERE</span> UserID = \<span class="string">'8585742290196126178\'</span></span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">WHERE</span> UserID = \<span class="string">'8585742290196126178\'</span></span><br><span class="line">    <span class="keyword">UNION</span> <span class="keyword">ALL</span></span><br><span class="line">    <span class="keyword">SELECT</span> UserID</span><br><span class="line">    <span class="keyword">FROM</span></span><br><span class="line">    (</span><br><span class="line">        <span class="keyword">SELECT</span> UserID</span><br><span class="line">        <span class="keyword">FROM</span> visits_v1</span><br><span class="line">        <span class="keyword">WHERE</span> UserID = \<span class="string">'8585742290196126178\'</span></span><br><span class="line">    )</span><br><span class="line">    <span class="keyword">WHERE</span> UserID = \<span class="string">'8585742290196126178\'</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">WHERE</span> UserID = \<span class="string">'8585742290196126178\'</span></span><br></pre></td></tr></table></figure>

<h2 id="3-5-聚合计算外推"><a href="#3-5-聚合计算外推" class="headerlink" title="3.5 聚合计算外推"></a>3.5 聚合计算外推</h2><p>聚合函数内的计算， 会外推， 例如：  </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> SYNTAX</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">sum</span>(UserID * <span class="number">2</span>)</span><br><span class="line"><span class="keyword">FROM</span> visits_v1</span><br><span class="line"></span><br><span class="line">//返回优化后的语句</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">sum</span>(UserID) * <span class="number">2</span></span><br><span class="line"><span class="keyword">FROM</span> visits_v1</span><br></pre></td></tr></table></figure>

<h2 id="3-6-聚合函数消除"><a href="#3-6-聚合函数消除" class="headerlink" title="3.6 聚合函数消除"></a>3.6 聚合函数消除</h2><p>如果对聚合键，也就是 group by key 使用 min、 max、 any 聚合函数，则将函数消除，<br>例如：  </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> SYNTAX</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    <span class="keyword">sum</span>(UserID * <span class="number">2</span>),</span><br><span class="line">    <span class="keyword">max</span>(VisitID),</span><br><span class="line">    <span class="keyword">max</span>(UserID)</span><br><span class="line"><span class="keyword">FROM</span> visits_v1</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> UserID</span><br><span class="line"></span><br><span class="line">//返回优化后的语句</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    <span class="keyword">sum</span>(UserID) * <span class="number">2</span>,</span><br><span class="line">    <span class="keyword">max</span>(VisitID),</span><br><span class="line">    UserID</span><br><span class="line"><span class="keyword">FROM</span> visits_v1</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> UserID</span><br></pre></td></tr></table></figure>

<h2 id="3-7-删除重复的-order-by-key"><a href="#3-7-删除重复的-order-by-key" class="headerlink" title="3.7 删除重复的 order by key"></a>3.7 删除重复的 order by key</h2><p>例如下面的语句，重复的聚合键 id 字段会被去重:  </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> SYNTAX</span><br><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> visits_v1</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line">    UserID <span class="keyword">ASC</span>,</span><br><span class="line">    UserID <span class="keyword">ASC</span>,</span><br><span class="line">    VisitID <span class="keyword">ASC</span>,</span><br><span class="line">    VisitID <span class="keyword">ASC</span></span><br><span class="line"></span><br><span class="line">//返回优化后的语句：</span><br><span class="line"><span class="keyword">select</span></span><br><span class="line">……</span><br><span class="line"><span class="keyword">FROM</span> visits_v1</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span></span><br><span class="line">    UserID <span class="keyword">ASC</span>,</span><br><span class="line">    VisitID <span class="keyword">ASC</span></span><br></pre></td></tr></table></figure>

<h2 id="3-8-删除重复的-limit-by-key"><a href="#3-8-删除重复的-limit-by-key" class="headerlink" title="3.8 删除重复的 limit by key"></a>3.8 删除重复的 limit by key</h2><p>例如下面的语句， 重复声明的 name 字段会被去重：  </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> SYNTAX</span><br><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> visits_v1</span><br><span class="line"><span class="keyword">LIMIT</span> <span class="number">3</span> <span class="keyword">BY</span></span><br><span class="line">    VisitID,</span><br><span class="line">    VisitID</span><br><span class="line"><span class="keyword">LIMIT</span> <span class="number">10</span></span><br><span class="line"></span><br><span class="line">//返回优化后的语句：</span><br><span class="line"><span class="keyword">select</span></span><br><span class="line">……</span><br><span class="line"><span class="keyword">FROM</span> visits_v1</span><br><span class="line"><span class="keyword">LIMIT</span> <span class="number">3</span> <span class="keyword">BY</span> VisitID</span><br><span class="line"><span class="keyword">LIMIT</span> <span class="number">10</span></span><br></pre></td></tr></table></figure>

<h2 id="3-9-删除重复的-USING-Key"><a href="#3-9-删除重复的-USING-Key" class="headerlink" title="3.9 删除重复的 USING Key"></a>3.9 删除重复的 USING Key</h2><p>例如下面的语句，重复的关联键 id 字段会被去重：  </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> SYNTAX</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    a.UserID,</span><br><span class="line">    a.UserID,</span><br><span class="line">    b.VisitID,</span><br><span class="line">    a.URL,</span><br><span class="line">    b.UserID</span><br><span class="line"><span class="keyword">FROM</span> hits_v1 <span class="keyword">AS</span> a</span><br><span class="line"><span class="keyword">LEFT</span> <span class="keyword">JOIN</span> visits_v1 <span class="keyword">AS</span> b <span class="keyword">USING</span> (UserID, UserID)</span><br><span class="line"></span><br><span class="line">//返回优化后的语句：</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    UserID,</span><br><span class="line">    UserID,</span><br><span class="line">    VisitID,</span><br><span class="line">    <span class="keyword">URL</span>,</span><br><span class="line">    b.UserID</span><br><span class="line"><span class="keyword">FROM</span> hits_v1 <span class="keyword">AS</span> a</span><br><span class="line"><span class="keyword">ALL</span> <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> visits_v1 <span class="keyword">AS</span> b <span class="keyword">USING</span> (UserID)</span><br></pre></td></tr></table></figure>

<h2 id="3-10-标量替换"><a href="#3-10-标量替换" class="headerlink" title="3.10 标量替换"></a>3.10 标量替换</h2><p>如果子查询只返回一行数据， 在被引用的时候用标量替换， 例如下面语句中的 total_disk_usage 字段： </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> SYNTAX</span><br><span class="line"><span class="keyword">WITH</span></span><br><span class="line">(</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="keyword">sum</span>(<span class="keyword">bytes</span>)</span><br><span class="line">    <span class="keyword">FROM</span> system.parts</span><br><span class="line">    <span class="keyword">WHERE</span> active</span><br><span class="line">) <span class="keyword">AS</span> total_disk_usage</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    (<span class="keyword">sum</span>(<span class="keyword">bytes</span>) / total_disk_usage) * <span class="number">100</span> <span class="keyword">AS</span> table_disk_usage,</span><br><span class="line">    <span class="keyword">table</span></span><br><span class="line"><span class="keyword">FROM</span> system.parts</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">table</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> table_disk_usage <span class="keyword">DESC</span></span><br><span class="line"><span class="keyword">LIMIT</span> <span class="number">10</span>;</span><br><span class="line">//返回优化后的语句：</span><br><span class="line"><span class="keyword">WITH</span> <span class="keyword">CAST</span>(<span class="number">0</span>, \<span class="string">'UInt64\'</span>) <span class="keyword">AS</span> total_disk_usage</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    (<span class="keyword">sum</span>(<span class="keyword">bytes</span>) / total_disk_usage) * <span class="number">100</span> <span class="keyword">AS</span> table_disk_usage,</span><br><span class="line">    <span class="keyword">table</span></span><br><span class="line"><span class="keyword">FROM</span> system.parts</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">table</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> table_disk_usage <span class="keyword">DESC</span></span><br><span class="line"><span class="keyword">LIMIT</span> <span class="number">10</span></span><br></pre></td></tr></table></figure>

<h2 id="3-11-三元运算优化"><a href="#3-11-三元运算优化" class="headerlink" title="3.11 三元运算优化"></a>3.11 三元运算优化</h2><p>如果开启了 optimize_if_chain_to_multiif 参数，三元运算符会被替换成 multiIf 函数，<br>例如：  </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">EXPLAIN</span> SYNTAX</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">number</span> = <span class="number">1</span> ? <span class="string">'hello'</span> : (<span class="built_in">number</span> = <span class="number">2</span> ? <span class="string">'world'</span> : <span class="string">'atguigu'</span>)</span><br><span class="line"><span class="keyword">FROM</span> numbers(<span class="number">10</span>)</span><br><span class="line"><span class="keyword">settings</span> optimize_if_chain_to_multiif = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">//返回优化后的语句：</span><br><span class="line"><span class="keyword">SELECT</span> multiIf(<span class="built_in">number</span> = <span class="number">1</span>, \<span class="string">'hello\'</span>, <span class="built_in">number</span> = <span class="number">2</span>, \<span class="string">'world\'</span>, \<span class="string">'atguigu\'</span>)</span><br><span class="line"><span class="keyword">FROM</span> numbers(<span class="number">10</span>)</span><br><span class="line"><span class="keyword">SETTINGS</span> optimize_if_chain_to_multiif = <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h1 id="第-4-章-查询优化"><a href="#第-4-章-查询优化" class="headerlink" title="第 4 章 查询优化"></a>第 4 章 查询优化</h1><h2 id="4-1-单表查询"><a href="#4-1-单表查询" class="headerlink" title="4.1 单表查询"></a>4.1 单表查询</h2><h3 id="4-1-1-Prewhere-替代-where"><a href="#4-1-1-Prewhere-替代-where" class="headerlink" title="4.1.1 Prewhere 替代 where"></a>4.1.1 Prewhere 替代 where</h3><p>Prewhere 和 where 语句的作用相同， 用来过滤数据。不同之处在于 prewhere 只支持MergeTree 族系列引擎的表，首先会读取指定的列数据，来判断数据过滤，等待数据过滤之后再读取 select 声明的列字段来补全其余属性。</p>
<p>当查询列明显多于筛选列时使用 Prewhere 可十倍提升查询性能， Prewhere 会自动优化执行过滤阶段的数据读取方式，降低 io 操作。</p>
<p>在某些场合下， prewhere 语句比 where 语句处理的数据量更少性能更高。  </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#关闭 where 自动转 prewhere(默认情况下， where 条件会自动优化成 prewhere)</span></span><br><span class="line"><span class="keyword">set</span> optimize_move_to_prewhere=<span class="number">0</span>;</span><br><span class="line"><span class="comment"># 使用 where</span></span><br><span class="line"><span class="keyword">select</span> WatchID,</span><br><span class="line">    JavaEnable,</span><br><span class="line">    Title,</span><br><span class="line">    GoodEvent,</span><br><span class="line">    EventTime,</span><br><span class="line">    EventDate,</span><br><span class="line">    CounterID,</span><br><span class="line">    ClientIP,</span><br><span class="line">    ClientIP6,</span><br><span class="line">    RegionID,</span><br><span class="line">    UserID,</span><br><span class="line">    CounterClass,</span><br><span class="line">    OS,</span><br><span class="line">    UserAgent,</span><br><span class="line">    <span class="keyword">URL</span>,</span><br><span class="line">    Referer,</span><br><span class="line">    URLDomain,</span><br><span class="line">    RefererDomain,</span><br><span class="line">    <span class="keyword">Refresh</span>,</span><br><span class="line">    IsRobot,</span><br><span class="line">    RefererCategories,</span><br><span class="line">    URLCategories,</span><br><span class="line">    URLRegions,</span><br><span class="line">    RefererRegions,</span><br><span class="line">    ResolutionWidth,</span><br><span class="line">    ResolutionHeight,</span><br><span class="line">    ResolutionDepth,</span><br><span class="line">    FlashMajor,</span><br><span class="line">    FlashMinor,</span><br><span class="line">    FlashMinor2</span><br><span class="line"><span class="keyword">from</span> datasets.hits_v1 <span class="keyword">where</span> UserID=<span class="string">'3198390223272470366'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 prewhere 关键字</span></span><br><span class="line"><span class="keyword">select</span> WatchID,</span><br><span class="line">    JavaEnable,</span><br><span class="line">    Title,</span><br><span class="line">    GoodEvent,</span><br><span class="line">    EventTime,</span><br><span class="line">    EventDate,</span><br><span class="line">    CounterID,</span><br><span class="line">    ClientIP,</span><br><span class="line">    ClientIP6,</span><br><span class="line">    RegionID,</span><br><span class="line">    UserID,</span><br><span class="line">    CounterClass,</span><br><span class="line">    OS,</span><br><span class="line">    UserAgent,</span><br><span class="line">    <span class="keyword">URL</span>,</span><br><span class="line">    Referer,</span><br><span class="line">    URLDomain,</span><br><span class="line">    RefererDomain,</span><br><span class="line">    <span class="keyword">Refresh</span>,</span><br><span class="line">    IsRobot,</span><br><span class="line">    RefererCategories,</span><br><span class="line">    URLCategories,</span><br><span class="line">    URLRegions,</span><br><span class="line">    RefererRegions,</span><br><span class="line">    ResolutionWidth,</span><br><span class="line">    ResolutionHeight,</span><br><span class="line">    ResolutionDepth,</span><br><span class="line">    FlashMajor,</span><br><span class="line">    FlashMinor,</span><br><span class="line">    FlashMinor2</span><br><span class="line"><span class="keyword">from</span> datasets.hits_v1 prewhere UserID=<span class="string">'3198390223272470366'</span>;</span><br></pre></td></tr></table></figure>

<p>默认情况，我们肯定不会关闭 where 自动优化成 prewhere，但是某些场景即使开启优<br>化，也不会自动转换成 prewhere，需要手动指定 prewhere：</p>
<ul>
<li>使用常量表达式</li>
<li>使用默认值为 alias 类型的字段</li>
<li>包含了 arrayJOIN， globalIn， globalNotIn 或者 indexHint 的查询</li>
<li>select 查询的列字段和 where 的谓词相同</li>
<li>使用了主键字段  </li>
</ul>
<h3 id="4-1-2-数据采样"><a href="#4-1-2-数据采样" class="headerlink" title="4.1.2 数据采样"></a>4.1.2 数据采样</h3><p>通过采样运算可极大提升数据分析的性能  </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Title,<span class="keyword">count</span>(*) <span class="keyword">AS</span> PageViews</span><br><span class="line"><span class="keyword">FROM</span> hits_v1</span><br><span class="line"><span class="keyword">SAMPLE</span> <span class="number">0.1</span> <span class="comment">#代表采样 10%的数据,也可以是具体的条数</span></span><br><span class="line"><span class="keyword">WHERE</span> CounterID =<span class="number">57</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> Title</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> PageViews <span class="keyword">DESC</span> <span class="keyword">LIMIT</span> <span class="number">1000</span></span><br></pre></td></tr></table></figure>

<p>采样修饰符只有在 MergeTree engine 表中才有效，且在创建表时需要指定采样策略。  </p>
<h3 id="4-1-3-列裁剪与分区裁剪"><a href="#4-1-3-列裁剪与分区裁剪" class="headerlink" title="4.1.3 列裁剪与分区裁剪"></a>4.1.3 列裁剪与分区裁剪</h3><p>数据量太大时应避免使用 select * 操作，查询的性能会与查询的字段大小和数量成线性表换，字段越少，消耗的 io 资源越少，性能就会越高。  </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">反例：</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> datasets.hits_v1;</span><br><span class="line"></span><br><span class="line">正例：</span><br><span class="line"><span class="keyword">select</span> WatchID,</span><br><span class="line">    JavaEnable,</span><br><span class="line">    Title,</span><br><span class="line">    GoodEvent,</span><br><span class="line">    EventTime,</span><br><span class="line">    EventDate,</span><br><span class="line">    CounterID,</span><br><span class="line">    ClientIP,</span><br><span class="line">    ClientIP6,</span><br><span class="line">    RegionID,</span><br><span class="line">    UserID</span><br><span class="line"><span class="keyword">from</span> datasets.hits_v1;</span><br></pre></td></tr></table></figure>

<p>分区裁剪就是只读取需要的分区， 在过滤条件中指定。  </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> WatchID,</span><br><span class="line">    JavaEnable,</span><br><span class="line">    Title,</span><br><span class="line">    GoodEvent,</span><br><span class="line">    EventTime,</span><br><span class="line">    EventDate,</span><br><span class="line">    CounterID,</span><br><span class="line">    ClientIP,</span><br><span class="line">    ClientIP6,</span><br><span class="line">    RegionID,</span><br><span class="line">    UserID</span><br><span class="line"><span class="keyword">from</span> datasets.hits_v1</span><br><span class="line"><span class="keyword">where</span> EventDate=<span class="string">'2014-03-23'</span>;</span><br></pre></td></tr></table></figure>

<h3 id="4-1-4-orderby-结合-where、-limit"><a href="#4-1-4-orderby-结合-where、-limit" class="headerlink" title="4.1.4 orderby 结合 where、 limit"></a>4.1.4 orderby 结合 where、 limit</h3><p>千万以上数据集进行 order by 查询时需要搭配 where 条件和 limit 语句一起使用。  </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#正例：</span></span><br><span class="line"><span class="keyword">SELECT</span> UserID,Age</span><br><span class="line"><span class="keyword">FROM</span> hits_v1</span><br><span class="line"><span class="keyword">WHERE</span> CounterID=<span class="number">57</span></span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> Age <span class="keyword">DESC</span> <span class="keyword">LIMIT</span> <span class="number">1000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#反例：</span></span><br><span class="line"><span class="keyword">SELECT</span> UserID,Age</span><br><span class="line"><span class="keyword">FROM</span> hits_v1</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> Age <span class="keyword">DESC</span></span><br></pre></td></tr></table></figure>

<h3 id="4-1-5-避免构建虚拟列"><a href="#4-1-5-避免构建虚拟列" class="headerlink" title="4.1.5 避免构建虚拟列"></a>4.1.5 避免构建虚拟列</h3><p>如非必须， 不要在结果集上构建虚拟列，虚拟列非常消耗资源浪费性能，可以考虑在前端进行处理，或者在表中构造实际字段进行额外存储。 </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">反例：</span><br><span class="line"><span class="keyword">SELECT</span> Income,Age,Income/Age <span class="keyword">as</span> IncRate <span class="keyword">FROM</span> datasets.hits_v1;</span><br><span class="line">正例：拿到 Income 和 Age 后， 考虑在前端进行处理，或者在表中构造实际字段进行额外存储</span><br><span class="line"><span class="keyword">SELECT</span> Income,Age <span class="keyword">FROM</span> datasets.hits_v1;</span><br></pre></td></tr></table></figure>

<h3 id="4-1-6-uniqCombined-替代-distinct"><a href="#4-1-6-uniqCombined-替代-distinct" class="headerlink" title="4.1.6 uniqCombined 替代 distinct"></a>4.1.6 uniqCombined 替代 distinct</h3><p>性能可提升 10 倍以上， uniqCombined 底层采用类似 HyperLogLog 算法实现， 能接收 2%<br>左右的数据误差， 可直接使用这种去重方式提升查询性能。 Count(distinct )会使用 uniqExact<br>精确去重。</p>
<p>不建议在千万级不同数据上执行 distinct 去重查询，改为近似去重 uniqCombined  </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">反例：</span><br><span class="line"><span class="keyword">select</span> <span class="keyword">count</span>(<span class="keyword">distinct</span> <span class="keyword">rand</span>()) <span class="keyword">from</span> hits_v1;</span><br><span class="line">正例：</span><br><span class="line"><span class="keyword">SELECT</span> uniqCombined(<span class="keyword">rand</span>()) <span class="keyword">from</span> datasets.hits_v1</span><br></pre></td></tr></table></figure>

<h3 id="4-1-7-使用物化视图"><a href="#4-1-7-使用物化视图" class="headerlink" title="4.1.7 使用物化视图"></a>4.1.7 使用物化视图</h3><p>参考第 6 章。  </p>
<h3 id="4-1-8-其他注意事项"><a href="#4-1-8-其他注意事项" class="headerlink" title="4.1.8 其他注意事项"></a>4.1.8 其他注意事项</h3><p>（1）查询熔断<br>为了避免因个别慢查询引起的服务雪崩的问题，除了可以为单个查询设置超时以外，还可以配置周期熔断，在一个查询周期内，如果用户频繁进行慢查询操作超出规定阈值后将无法继续进行查询操作。</p>
<p>（2）关闭虚拟内存<br>物理内存和虚拟内存的数据交换，会导致查询变慢，资源允许的情况下关闭虚拟内存。</p>
<p>（3）配置 join_use_nulls<br>为每一个账户添加 join_use_nulls 配置，左表中的一条记录在右表中不存在，右表的相应字段会返回该字段相应数据类型的默认值，而不是标准 SQL 中的 Null 值。</p>
<p>（4）批量写入时先排序<br>批量写入数据时，必须控制每个批次的数据中涉及到的分区的数量，在写入之前最好对需要导入的数据进行排序。无序的数据或者涉及的分区太多，会导致ClickHouse 无法及时对新导入的数据进行合并，从而影响查询性能。</p>
<p>（5）关注 CPU<br>cpu 一般在 50%左右会出现查询波动，达到 70%会出现大范围的查询超时， cpu 是最关键的指标，要非常关注。  </p>
<h2 id="4-2-多表关联"><a href="#4-2-多表关联" class="headerlink" title="4.2 多表关联"></a>4.2 多表关联</h2><h3 id="4-2-1-准备表和数据"><a href="#4-2-1-准备表和数据" class="headerlink" title="4.2.1 准备表和数据"></a>4.2.1 准备表和数据</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建小表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> visits_v2</span><br><span class="line"><span class="keyword">ENGINE</span> = CollapsingMergeTree(<span class="keyword">Sign</span>)</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> toYYYYMM(StartDate)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> (CounterID, StartDate, intHash32(UserID), VisitID)</span><br><span class="line"><span class="keyword">SAMPLE</span> <span class="keyword">BY</span> intHash32(UserID)</span><br><span class="line"><span class="keyword">SETTINGS</span> index_granularity = <span class="number">8192</span></span><br><span class="line"><span class="keyword">as</span> <span class="keyword">select</span> * <span class="keyword">from</span> visits_v1 <span class="keyword">limit</span> <span class="number">10000</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建 join 结果表：避免控制台疯狂打印数据</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> hits_v2</span><br><span class="line"><span class="keyword">ENGINE</span> = MergeTree()</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> toYYYYMM(EventDate)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> (CounterID, EventDate, intHash32(UserID))</span><br><span class="line"><span class="keyword">SAMPLE</span> <span class="keyword">BY</span> intHash32(UserID)</span><br><span class="line"><span class="keyword">SETTINGS</span> index_granularity = <span class="number">8192</span></span><br><span class="line"><span class="keyword">as</span> <span class="keyword">select</span> * <span class="keyword">from</span> hits_v1 <span class="keyword">where</span> <span class="number">1</span>=<span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-2-用-IN-代替-JOIN"><a href="#4-2-2-用-IN-代替-JOIN" class="headerlink" title="4.2.2 用 IN 代替 JOIN"></a>4.2.2 用 IN 代替 JOIN</h3><p>当多表联查时， 查询的数据仅从其中一张表出时， 可考虑用 IN 操作而不是 JOIN  </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> hits_v2</span><br><span class="line"><span class="keyword">select</span> a.* <span class="keyword">from</span> hits_v1 a <span class="keyword">where</span> a. CounterID <span class="keyword">in</span> (<span class="keyword">select</span> CounterID <span class="keyword">from</span></span><br><span class="line">visits_v1);</span><br><span class="line"><span class="comment">#反例：使用 join</span></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">table</span> hits_v2</span><br><span class="line"><span class="keyword">select</span> a.* <span class="keyword">from</span> hits_v1 a <span class="keyword">left</span> <span class="keyword">join</span> visits_v1 b <span class="keyword">on</span> a. CounterID=b.</span><br><span class="line">CounterID;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-3-大小表-JOIN"><a href="#4-2-3-大小表-JOIN" class="headerlink" title="4.2.3 大小表 JOIN"></a>4.2.3 大小表 JOIN</h3><p>多表 join 时要满足小表在右的原则， 右表关联时被加载到内存中与左表进行比较，ClickHouse 中无论是 Left join 、 Right join 还是 Inner join 永远都是拿着右表中的每一条记录到左表中查找该记录是否存在， 所以右表必须是小表。  </p>
<p>（1） 小表在右  </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">table</span> hits_v2</span><br><span class="line"><span class="keyword">select</span> a.* <span class="keyword">from</span> hits_v1 a <span class="keyword">left</span> <span class="keyword">join</span> visits_v2 b <span class="keyword">on</span> a. CounterID=b.CounterID;</span><br></pre></td></tr></table></figure>

<p>（2） 大表在右  </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> <span class="keyword">table</span> hits_v2</span><br><span class="line"><span class="keyword">select</span> a.* <span class="keyword">from</span> visits_v2 b <span class="keyword">left</span> <span class="keyword">join</span> hits_v1 a <span class="keyword">on</span> a. CounterID=b.CounterID;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-4-注意谓词下推（版本差异）"><a href="#4-2-4-注意谓词下推（版本差异）" class="headerlink" title="4.2.4 注意谓词下推（版本差异）"></a>4.2.4 注意谓词下推（版本差异）</h3><p>ClickHouse 在 join 查询时不会主动发起谓词下推的操作，需要每个子查询提前完成过滤操作，需要注意的是，是否执行谓词下推，对性能影响差别很大（新版本中已经不存在此问题，但是需要注意谓词的位置的不同依然有性能的差异）  </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Explain</span> syntax</span><br><span class="line"><span class="keyword">select</span> a.* <span class="keyword">from</span> hits_v1 a <span class="keyword">left</span> <span class="keyword">join</span> visits_v2 b <span class="keyword">on</span> a. CounterID=b.</span><br><span class="line">CounterID</span><br><span class="line"><span class="keyword">having</span> a.EventDate = <span class="string">'2014-03-17'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">Explain</span> syntax</span><br><span class="line"><span class="keyword">select</span> a.* <span class="keyword">from</span> hits_v1 a <span class="keyword">left</span> <span class="keyword">join</span> visits_v2 b <span class="keyword">on</span> a. CounterID=b.</span><br><span class="line">CounterID</span><br><span class="line"><span class="keyword">having</span> b.StartDate = <span class="string">'2014-03-17'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> hits_v2</span><br><span class="line"><span class="keyword">select</span> a.* <span class="keyword">from</span> hits_v1 a <span class="keyword">left</span> <span class="keyword">join</span> visits_v2 b <span class="keyword">on</span> a. CounterID=b.</span><br><span class="line">CounterID</span><br><span class="line"><span class="keyword">where</span> a.EventDate = <span class="string">'2014-03-17'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> hits_v2</span><br><span class="line">    <span class="keyword">select</span> a.* <span class="keyword">from</span> (</span><br><span class="line">    <span class="keyword">select</span> * <span class="keyword">from</span></span><br><span class="line">    hits_v1</span><br><span class="line"><span class="keyword">where</span> EventDate = <span class="string">'2014-03-17'</span></span><br><span class="line">) a <span class="keyword">left</span> <span class="keyword">join</span> visits_v2 b <span class="keyword">on</span> a. CounterID=b. CounterID;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-5-分布式表使用-GLOBAL"><a href="#4-2-5-分布式表使用-GLOBAL" class="headerlink" title="4.2.5 分布式表使用 GLOBAL"></a>4.2.5 分布式表使用 GLOBAL</h3><p>两张分布式表上的 IN 和 JOIN 之前必须加上 GLOBAL 关键字， 右表只会在接收查询请求的那个节点查询一次，并将其分发到其他节点上。如果不加 GLOBAL 关键字的话，每个节点都会单独发起一次对右表的查询，而右表又是分布式表，就导致右表一共会被查询 N²次（N是该分布式表的分片数量），这就是查询放大，会带来很大开销。  </p>
<h3 id="4-2-6-使用字典表"><a href="#4-2-6-使用字典表" class="headerlink" title="4.2.6 使用字典表"></a>4.2.6 使用字典表</h3><p>将一些需要关联分析的业务创建成字典表进行 join 操作，前提是字典表不宜太大，因为字典表会常驻内存  </p>
<h3 id="4-2-7-提前过滤"><a href="#4-2-7-提前过滤" class="headerlink" title="4.2.7 提前过滤"></a>4.2.7 提前过滤</h3><p>通过增加逻辑过滤可以减少数据扫描，达到提高执行速度及降低内存消耗的目的  </p>
<h1 id="第-5-章-数据一致性（重点）"><a href="#第-5-章-数据一致性（重点）" class="headerlink" title="第 5 章 数据一致性（重点）"></a>第 5 章 数据一致性（重点）</h1><p>查询 CK 手册发现，即便对数据一致性支持最好的 Mergetree，也只是保证最终一致性：  </p>
<p><img src="/2024/09/23/ClickHouse%E9%AB%98%E7%BA%A7%E8%BF%9B%E9%98%B6/image-20240926182817176.png" alt="image-20240926182817176"></p>
<p>我们在使用 ReplacingMergeTree、 SummingMergeTree 这类表引擎的时候，会出现短暂数据不一致的情况。<br>在某些对一致性非常敏感的场景，通常有以下几种解决方案。  </p>
<h2 id="5-1-准备测试表和数据"><a href="#5-1-准备测试表和数据" class="headerlink" title="5.1 准备测试表和数据"></a>5.1 准备测试表和数据</h2><p>（1） 创建表  </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> test_a(</span><br><span class="line">    user_id UInt64,</span><br><span class="line">    score <span class="keyword">String</span>,</span><br><span class="line">    deleted UInt8 <span class="keyword">DEFAULT</span> <span class="number">0</span>,</span><br><span class="line">    create_time DateTime <span class="keyword">DEFAULT</span> toDateTime(<span class="number">0</span>)</span><br><span class="line">)<span class="keyword">ENGINE</span>= ReplacingMergeTree(create_time)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> user_id;</span><br></pre></td></tr></table></figure>

<p>其中:<br>user_id 是数据去重更新的标识;<br>create_time 是版本号字段，每组数据中 create_time 最大的一行表示最新的数据;<br>deleted 是自定的一个标记位，比如 0 代表未删除， 1 代表删除数据。  </p>
<p>（2） 写入 1000 万 测试数据  </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">TABLE</span> test_a(user_id,score)</span><br><span class="line"><span class="keyword">WITH</span>(</span><br><span class="line">	<span class="keyword">SELECT</span> [<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>,<span class="string">'D'</span>,<span class="string">'E'</span>,<span class="string">'F'</span>,<span class="string">'G'</span>]</span><br><span class="line">)<span class="keyword">AS</span> dict</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">number</span> <span class="keyword">AS</span> user_id, dict[<span class="built_in">number</span>%<span class="number">7</span>+<span class="number">1</span>] <span class="keyword">FROM</span> numbers(<span class="number">10000000</span>);</span><br></pre></td></tr></table></figure>

<p>（3） 修改前 50 万 行数据，修改内容包括 name 字段和 create_time 版本号字段  </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">TABLE</span> test_a(user_id,score,create_time)</span><br><span class="line"><span class="keyword">WITH</span>(</span><br><span class="line">	<span class="keyword">SELECT</span> [<span class="string">'AA'</span>,<span class="string">'BB'</span>,<span class="string">'CC'</span>,<span class="string">'DD'</span>,<span class="string">'EE'</span>,<span class="string">'FF'</span>,<span class="string">'GG'</span>]</span><br><span class="line">)<span class="keyword">AS</span> dict</span><br><span class="line"><span class="keyword">SELECT</span> <span class="built_in">number</span> <span class="keyword">AS</span> user_id, dict[<span class="built_in">number</span>%<span class="number">7</span>+<span class="number">1</span>], <span class="keyword">now</span>() <span class="keyword">AS</span> create_time <span class="keyword">FROM</span></span><br><span class="line">numbers(<span class="number">500000</span>);</span><br></pre></td></tr></table></figure>

<p>（4）统计总数  </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>() <span class="keyword">FROM</span> test_a;</span><br><span class="line">10500000</span><br></pre></td></tr></table></figure>

<p>还未触发分区合并，所以还未去重。  </p>
<h2 id="5-2-手动-OPTIMIZE"><a href="#5-2-手动-OPTIMIZE" class="headerlink" title="5.2 手动 OPTIMIZE"></a>5.2 手动 OPTIMIZE</h2><p>在写入数据后，立刻执行 OPTIMIZE 强制触发新写入分区的合并动作。  </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">OPTIMIZE</span> <span class="keyword">TABLE</span> test_a <span class="keyword">FINAL</span>;</span><br><span class="line">语法： <span class="keyword">OPTIMIZE</span> <span class="keyword">TABLE</span> [db.]<span class="keyword">name</span> [<span class="keyword">ON</span> CLUSTER cluster] [<span class="keyword">PARTITION</span> <span class="keyword">partition</span> |</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">ID</span> <span class="string">'partition_id'</span>] [<span class="keyword">FINAL</span>] [<span class="keyword">DEDUPLICATE</span> [<span class="keyword">BY</span> expression]]</span><br></pre></td></tr></table></figure>

<h2 id="5-3-通过-Group-by-去重"><a href="#5-3-通过-Group-by-去重" class="headerlink" title="5.3 通过 Group by 去重"></a>5.3 通过 Group by 去重</h2><p>（1）执行去重的查询  </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    user_id ,</span><br><span class="line">    argMax(score, create_time) <span class="keyword">AS</span> score,</span><br><span class="line">    argMax(deleted, create_time) <span class="keyword">AS</span> deleted,</span><br><span class="line">    <span class="keyword">max</span>(create_time) <span class="keyword">AS</span> ctime</span><br><span class="line"><span class="keyword">FROM</span> test_a</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> user_id</span><br><span class="line"><span class="keyword">HAVING</span> deleted = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>函数说明：</p>
<ul>
<li>argMax(field1， field2):按照 field2 的最大值取 field1 的值。当我们更新数据时，会写入一行新的数据，例如上面语句中， 通过查询最大的create_time 得到修改后的 score 字段值。  </li>
</ul>
<p>（2）创建视图，方便测试  </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> view_test_a <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    user_id ,</span><br><span class="line">    argMax(score, create_time) <span class="keyword">AS</span> score,</span><br><span class="line">    argMax(deleted, create_time) <span class="keyword">AS</span> deleted,</span><br><span class="line">    <span class="keyword">max</span>(create_time) <span class="keyword">AS</span> ctime</span><br><span class="line"><span class="keyword">FROM</span> test_a</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> user_id</span><br><span class="line"><span class="keyword">HAVING</span> deleted = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>（3）插入重复数据，再次查询  </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#再次插入一条数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">TABLE</span> test_a(user_id,score,create_time)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="number">0</span>,<span class="string">'AAAA'</span>,<span class="keyword">now</span>())</span><br><span class="line"><span class="comment">#再次查询</span></span><br><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> view_test_a</span><br><span class="line"><span class="keyword">WHERE</span> user_id = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>（4）删除数据测试  </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#再次插入一条标记为删除的数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> <span class="keyword">TABLE</span> test_a(user_id,score,deleted,create_time)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="number">0</span>,<span class="string">'AAAA'</span>,<span class="number">1</span>,<span class="keyword">now</span>());</span><br><span class="line"><span class="comment">#再次查询，刚才那条数据看不到了</span></span><br><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> view_test_a</span><br><span class="line"><span class="keyword">WHERE</span> user_id = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<p>这行数据并没有被真正的删除，而是被过滤掉了。在一些合适的场景下，可以结合表级别的 TTL 最终将物理数据删除。  </p>
<h2 id="5-4-通过-FINAL-查询"><a href="#5-4-通过-FINAL-查询" class="headerlink" title="5.4 通过 FINAL 查询"></a>5.4 通过 FINAL 查询</h2><p>在查询语句后增加 FINAL 修饰符， 这样在查询的过程中将会执行 Merge 的特殊逻辑（例如数据去重， 预聚合等）。</p>
<p>但是这种方法在早期版本基本没有人使用，因为在增加 FINAL 之后，我们的查询将会变成一个单线程的执行过程，查询速度非常慢。</p>
<p>在 v20.5.2.7-stable 版本中， FINAL 查询支持多线程执行，并且可以通过 max_final_threads 参数控制单个查询的线程数。 但是目前读取 part 部分的动作依然是串行的。</p>
<p>FINAL 查询最终的性能和很多因素相关，列字段的大小、分区的数量等等都会影响到最终的查询时间，所以还要结合实际场景取舍。</p>
<p>参考链接： <a href="https://github.com/ClickHouse/ClickHouse/pull/10463" target="_blank" rel="noopener">https://github.com/ClickHouse/ClickHouse/pull/10463</a><br>使用 hits_v1 表进行测试：<br>分别安装了 20.4.5.36 和 21.7.3.14 两个版本的 ClickHouse 进行对比。  </p>
<h3 id="5-4-1-老版本测试"><a href="#5-4-1-老版本测试" class="headerlink" title="5.4.1 老版本测试"></a>5.4.1 老版本测试</h3><p>（1） 普通查询语句  </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> visits_v1 <span class="keyword">WHERE</span> StartDate = <span class="string">'2014-03-17'</span> <span class="keyword">limit</span> <span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<p>（2） FINAL 查询  </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> visits_v1 <span class="keyword">FINAL</span> <span class="keyword">WHERE</span> StartDate = <span class="string">'2014-03-17'</span> <span class="keyword">limit</span> <span class="number">100</span>;</span><br></pre></td></tr></table></figure>

<p>先前的并行查询变成了单线程。  </p>
<h3 id="5-4-2-新版本测试"><a href="#5-4-2-新版本测试" class="headerlink" title="5.4.2 新版本测试"></a>5.4.2 新版本测试</h3><p>（1）普通语句查询  </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> visits_v1 <span class="keyword">WHERE</span> StartDate = <span class="string">'2014-03-17'</span> <span class="keyword">limit</span> <span class="number">100</span> <span class="keyword">settings</span> max_threads = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>查看执行计划：  </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> pipeline <span class="keyword">select</span> * <span class="keyword">from</span> visits_v1 <span class="keyword">WHERE</span> StartDate = <span class="string">'2014-03-17'</span></span><br><span class="line"><span class="keyword">limit</span> <span class="number">100</span> <span class="keyword">settings</span> max_threads = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">(Expression)</span><br><span class="line">ExpressionTransform × 2</span><br><span class="line">    (SettingQuotaAndLimits)</span><br><span class="line">        (Limit)</span><br><span class="line">        Limit 2 → 2</span><br><span class="line">        (ReadFromMergeTree)</span><br><span class="line">            MergeTreeThread × 2 0 → 1</span><br></pre></td></tr></table></figure>

<p>明显将由 2 个线程并行读取 part 查询。  </p>
<p>（2） FINAL 查询  </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> visits_v1 <span class="keyword">final</span> <span class="keyword">WHERE</span> StartDate = <span class="string">'2014-03-17'</span> <span class="keyword">limit</span> <span class="number">100</span> <span class="keyword">settings</span> max_final_threads = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>查询速度没有普通的查询快，但是相比之前已经有了一些提升,查看 FINAL 查询的执行<br>计划：  </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">explain</span> pipeline <span class="keyword">select</span> * <span class="keyword">from</span> visits_v1 <span class="keyword">final</span> <span class="keyword">WHERE</span> StartDate = <span class="string">'2014-</span></span><br><span class="line"><span class="string">03-17'</span> <span class="keyword">limit</span> <span class="number">100</span> <span class="keyword">settings</span> max_final_threads = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">(Expression)</span><br><span class="line">ExpressionTransform × 2</span><br><span class="line">	(SettingQuotaAndLimits)</span><br><span class="line">		(Limit)</span><br><span class="line">         Limit 2 → 2</span><br><span class="line">            (ReadFromMergeTree)</span><br><span class="line">                ExpressionTransform × 2</span><br><span class="line">                    CollapsingSortedTransform × 2</span><br><span class="line">                        Copy 1 → 2</span><br><span class="line">                        	AddingSelector</span><br><span class="line">                           	 	ExpressionTransform</span><br><span class="line">                               	 	MergeTree 0 → 1</span><br></pre></td></tr></table></figure>

<p>从 CollapsingSortedTransform 这一步开始已经是多线程执行， 但是读取 part 部分的动作还是串行。  </p>
<h1 id="第-6-章-物化视图"><a href="#第-6-章-物化视图" class="headerlink" title="第 6 章 物化视图"></a>第 6 章 物化视图</h1><p>ClickHouse 的物化视图是一种查询结果的持久化，它确实是给我们带来了查询效率的提升。用户查起来跟表没有区别，它就是一张表，它也像是一张时刻在预计算的表，创建的过程它是用了一个特殊引擎，加上后来 as select， 就是 create 一个 table as select 的写法。“查询结果集”的范围很宽泛，可以是基础表中部分数据的一份简单拷贝，也可以是多表 join 之后产生的结果或其子集，或者原始数据的聚合指标等等。所以，物化视图不会随着基础表的变化而变化，所以它也称为快照（snapshot）  </p>
<h2 id="6-1-概述"><a href="#6-1-概述" class="headerlink" title="6.1 概述"></a>6.1 概述</h2><h3 id="6-1-1-物化视图与普通视图的区别"><a href="#6-1-1-物化视图与普通视图的区别" class="headerlink" title="6.1.1 物化视图与普通视图的区别"></a>6.1.1 物化视图与普通视图的区别</h3><p>普通视图不保存数据，保存的仅仅是查询语句，查询的时候还是从原表读取数据，可以将普通视图理解为是个子查询。 物化视图则是把查询的结果根据相应的引擎存入到了磁盘或内存中，对数据重新进行了组织，你可以理解物化视图是完全的一张新表。  </p>
<h3 id="6-1-2-优缺点"><a href="#6-1-2-优缺点" class="headerlink" title="6.1.2 优缺点"></a>6.1.2 优缺点</h3><p>优点：查询速度快，要是把物化视图这些规则全部写好，它比原数据查询快了很多，总的行数少了，因为都预计算好了。</p>
<p>缺点：它的本质是一个流式数据的使用场景，是累加式的技术，所以要用历史数据做去重、去核这样的分析，在物化视图里面是不太好用的。在某些场景的使用也是有限的。而且如果一张表加了好多物化视图，在写这张表的时候，就会消耗很多机器的资源， 比如数据带宽占满、 存储一下子增加了很多。  </p>
<h3 id="6-1-3-基本语法"><a href="#6-1-3-基本语法" class="headerlink" title="6.1.3 基本语法"></a>6.1.3 基本语法</h3><p>也是 create 语法，会创建一个隐藏的目标表来保存视图数据。 也可以 TO 表名，保存到一张显式的表。 没有加 TO 表名，表名默认就是 .inner.物化视图名  </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> [<span class="keyword">MATERIALIZED</span>] <span class="keyword">VIEW</span> [<span class="keyword">IF</span> <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] [db.]table_name [<span class="keyword">TO</span>[db.]<span class="keyword">name</span>]</span><br><span class="line">[<span class="keyword">ENGINE</span> = <span class="keyword">engine</span>] [POPULATE] <span class="keyword">AS</span> <span class="keyword">SELECT</span> ...</span><br></pre></td></tr></table></figure>

<p>1） 创建物化视图的限制  </p>
<ol>
<li>必须指定物化视图的 engine 用于数据存储</li>
<li>TO [db].[table]语法的时候，不得使用 POPULATE。</li>
<li>查询语句(select）可以包含下面的子句： DISTINCT, GROUP BY, ORDER BY, LIMIT…</li>
<li>物化视图的 alter 操作有些限制，操作起来不大方便。</li>
<li>若物化视图的定义使用了 TO [db.]name 子语句，则可以将目标表的视图 卸载DETACH 再装载 ATTACH  </li>
</ol>
<p>2） 物化视图的数据更新</p>
<ol>
<li>物化视图创建好之后，若源表被写入新数据则物化视图也 会同步更新</li>
<li>POPULATE 关键字决定了物化视图的更新策略：  <ul>
<li>若有 POPULATE 则在创建视图的过程会将源表已经存在的数据一并导入，类似于create table … as</li>
<li>若无 POPULATE 则物化视图在创建之后没有数据，只会在创建只有同步之后写入源表的数据</li>
<li>clickhouse 官方并不推荐使用 POPULATE，因为在创建物化视图的过程中同时写入的数据不能被插入物化视图。  </li>
</ul>
</li>
<li>物化视图不支持同步删除，若源表的数据不存在（删除了）则物化视图的数据仍然保留</li>
<li>物化视图是一种特殊的数据表，可以用 show tables 查看</li>
<li>物化视图数据的删除：</li>
<li>物化视图的删除：  </li>
</ol>
<h2 id="6-2-案例实操"><a href="#6-2-案例实操" class="headerlink" title="6.2 案例实操"></a>6.2 案例实操</h2><p>对于一些确定的数据模型，可将统计指标通过物化视图的方式进行构建，这样可避免查询时重复计算的过程，物化视图会在有新数据插入时进行更新。  </p>
<h3 id="6-2-1-准备测试用表和数据"><a href="#6-2-1-准备测试用表和数据" class="headerlink" title="6.2.1 准备测试用表和数据"></a>6.2.1 准备测试用表和数据</h3><p>1）建表  </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#建表语句</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> hits_test</span><br><span class="line">(</span><br><span class="line">    EventDate <span class="built_in">Date</span>,</span><br><span class="line">    CounterID UInt32,</span><br><span class="line">    UserID UInt64,</span><br><span class="line">    <span class="keyword">URL</span> <span class="keyword">String</span>,</span><br><span class="line">    Income UInt8</span><br><span class="line">)</span><br><span class="line"><span class="keyword">ENGINE</span> = MergeTree()</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> toYYYYMM(EventDate)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> (CounterID, EventDate, intHash32(UserID))</span><br><span class="line"><span class="keyword">SAMPLE</span> <span class="keyword">BY</span> intHash32(UserID)</span><br><span class="line"><span class="keyword">SETTINGS</span> index_granularity = <span class="number">8192</span></span><br></pre></td></tr></table></figure>

<p>2）导入一些数据  </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> hits_test</span><br><span class="line">    <span class="keyword">SELECT</span></span><br><span class="line">    EventDate,</span><br><span class="line">    CounterID,</span><br><span class="line">    UserID,</span><br><span class="line">    <span class="keyword">URL</span>,</span><br><span class="line">    Income</span><br><span class="line"><span class="keyword">FROM</span> hits_v1</span><br><span class="line"><span class="keyword">limit</span> <span class="number">10000</span>;</span><br></pre></td></tr></table></figure>

<h3 id="6-2-2-创建物化视图"><a href="#6-2-2-创建物化视图" class="headerlink" title="6.2.2 创建物化视图"></a>6.2.2 创建物化视图</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#建表语句</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">MATERIALIZED</span> <span class="keyword">VIEW</span> hits_mv</span><br><span class="line"><span class="keyword">ENGINE</span>=SummingMergeTree</span><br><span class="line"><span class="keyword">PARTITION</span> <span class="keyword">BY</span> toYYYYMM(EventDate) <span class="keyword">ORDER</span> <span class="keyword">BY</span> (EventDate, intHash32(UserID))</span><br><span class="line"><span class="keyword">AS</span> <span class="keyword">SELECT</span></span><br><span class="line">UserID,</span><br><span class="line">EventDate,</span><br><span class="line"><span class="keyword">count</span>(<span class="keyword">URL</span>) <span class="keyword">as</span> ClickCount,</span><br><span class="line"><span class="keyword">sum</span>(Income) <span class="keyword">AS</span> IncomeSum</span><br><span class="line"><span class="keyword">FROM</span> hits_test</span><br><span class="line"><span class="keyword">WHERE</span> EventDate &gt;= <span class="string">'2014-03-20'</span> <span class="comment">#设置更新点,该时间点之前的数据可以另外通过</span></span><br><span class="line"><span class="comment">#insert into select …… 的方式进行插入</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> UserID,EventDate;</span><br><span class="line"></span><br><span class="line"><span class="comment">##或者可以用下列语法，表 A 可以是一张 mergetree 表</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">MATERIALIZED</span> <span class="keyword">VIEW</span> 物化视图名 <span class="keyword">TO</span> 表 A</span><br><span class="line"><span class="keyword">AS</span> <span class="keyword">SELECT</span> <span class="keyword">FROM</span> 表 B;</span><br><span class="line"></span><br><span class="line"><span class="comment">#不建议添加 populate 关键字进行全量更新</span></span><br></pre></td></tr></table></figure>

<h3 id="6-3-3-导入增量数据"><a href="#6-3-3-导入增量数据" class="headerlink" title="6.3.3 导入增量数据"></a>6.3.3 导入增量数据</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#导入增量数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> hits_test</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    EventDate,</span><br><span class="line">    CounterID,</span><br><span class="line">    UserID,</span><br><span class="line">    <span class="keyword">URL</span>,</span><br><span class="line">    Income</span><br><span class="line"><span class="keyword">FROM</span> hits_v1</span><br><span class="line"><span class="keyword">WHERE</span> EventDate &gt;= <span class="string">'2014-03-23'</span></span><br><span class="line"><span class="keyword">limit</span> <span class="number">10</span>;</span><br><span class="line"><span class="comment">#查询物化视图</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> hits_mv;</span><br></pre></td></tr></table></figure>

<h3 id="6-3-4-导入历史数据"><a href="#6-3-4-导入历史数据" class="headerlink" title="6.3.4 导入历史数据"></a>6.3.4 导入历史数据</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#导入增量数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> hits_mv</span><br><span class="line"><span class="keyword">SELECT</span></span><br><span class="line">    UserID,</span><br><span class="line">    EventDate,</span><br><span class="line">    <span class="keyword">count</span>(<span class="keyword">URL</span>) <span class="keyword">as</span> ClickCount,</span><br><span class="line">    <span class="keyword">sum</span>(Income) <span class="keyword">AS</span> IncomeSum</span><br><span class="line"><span class="keyword">FROM</span> hits_test</span><br><span class="line"><span class="keyword">WHERE</span> EventDate = <span class="string">'2014-03-20'</span></span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> UserID,EventDate</span><br><span class="line"><span class="comment">#查询物化视图</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> hits_mv;</span><br></pre></td></tr></table></figure>

<h1 id="第-7-章-MaterializeMySQL-引擎"><a href="#第-7-章-MaterializeMySQL-引擎" class="headerlink" title="第 7 章 MaterializeMySQL 引擎"></a>第 7 章 MaterializeMySQL 引擎</h1><h2 id="7-1-概述"><a href="#7-1-概述" class="headerlink" title="7.1 概述"></a>7.1 概述</h2><p>MySQL 的用户群体很大， 为了能够增强数据的实时性， 很多解决方案会利用 binlog 将数据写入到 ClickHouse。为了能够监听 binlog 事件，我们需要用到类似 canal 这样的第三方中间件，这无疑增加了系统的复杂度。</p>
<p>ClickHouse 20.8.2.3 版本新增加了 MaterializeMySQL 的 database 引擎，该 database 能映 射 到 MySQL 中 的 某 个 database ， 并 自 动 在 ClickHouse 中 创 建 对 应 的ReplacingMergeTree。 ClickHouse 服务做为 MySQL 副本，读取 Binlog 并执行 DDL 和 DML 请求，实现了基于 MySQL Binlog 机制的业务数据库实时同步功能。  </p>
<h3 id="7-1-1-特点"><a href="#7-1-1-特点" class="headerlink" title="7.1.1 特点"></a>7.1.1 特点</h3><p>（1） MaterializeMySQL 同时支持全量和增量同步， 在 database 创建之初会全量同步MySQL 中的表和数据， 之后则会通过 binlog 进行增量同步。<br>（2） MaterializeMySQL database 为其所创建的每张 ReplacingMergeTree 自动增加了_sign 和 _version 字段。</p>
<p>其中， _version 用作 ReplacingMergeTree 的 ver 版本参数， 每当监听到 insert、 update和 delete 事件时， 在 databse 内全局自增。而 _sign 则用于标记是否被删除，取值 1 或者 -1。</p>
<p>目前 MaterializeMySQL 支持如下几种 binlog 事件:  </p>
<ul>
<li>MYSQL_WRITE_ROWS_EVENT: <em>sign = 1， _version ++</em></li>
<li>MYSQL_DELETE_ROWS_EVENT: _sign = -1， _version ++</li>
<li>MYSQL_UPDATE_ROWS_EVENT: sign = 1，_version ++</li>
<li>MYSQL_QUERY_EVENT: 支持 CREATE TABLE 、 DROP TABLE 、 RENAME TABLE 等。  </li>
</ul>
<h3 id="7-1-2-使用细则"><a href="#7-1-2-使用细则" class="headerlink" title="7.1.2 使用细则"></a>7.1.2 使用细则</h3><p>（1） DDL 查询<br>MySQL DDL 查询被转换成相应的 ClickHouse DDL 查询（ALTER, CREATE, DROP, RENAME）。如果 ClickHouse 不能解析某些 DDL 查询，该查询将被忽略。</p>
<p>（2） 数据复制<br>MaterializeMySQL 不支持直接插入、删除和更新查询，而是将 DDL 语句进行相应转换：<br>MySQL INSERT 查询被转换为 INSERT with _sign=1。<br>MySQL DELETE 查询被转换为 INSERT with _sign=-1。<br>MySQL UPDATE 查询被转换成 INSERT with _sign=1 和 INSERT with _sign=-1。<br>（3） SELECT 查询<br>如果在 SELECT 查询中没有指定_version，则使用 FINAL 修饰符，返回_version 的最大值对应的数据，即最新版本的数据。<br>如果在 SELECT 查询中没有指定_sign，则默认使用 WHERE _sign=1，即返回未删除状态（_sign=1)的数据。</p>
<p>（4） 索引转换<br>ClickHouse 数据库表会自动将 MySQL 主键和索引子句转换为 ORDER BY 元组。  </p>
<p>ClickHouse 只有一个物理顺序，由 ORDER BY 子句决定。如果需要创建新的物理顺序，请使用物化视图。  </p>
<h2 id="7-2-案例实操"><a href="#7-2-案例实操" class="headerlink" title="7.2 案例实操"></a>7.2 案例实操</h2><h3 id="7-2-1-MySQL-开启-binlog-和-GTID-模式"><a href="#7-2-1-MySQL-开启-binlog-和-GTID-模式" class="headerlink" title="7.2.1 MySQL 开启 binlog 和 GTID 模式"></a>7.2.1 MySQL 开启 binlog 和 GTID 模式</h3><p>（1） 确保 MySQL 开启了 binlog 功能，且格式为 ROW  </p>
<p>打开/etc/my.cnf,在[mysqld]下添加：  </p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">server-id</span>=<span class="string">1</span></span><br><span class="line"><span class="meta">log-bin</span>=<span class="string">mysql-bin</span></span><br><span class="line"><span class="attr">binlog_format</span>=<span class="string">ROW</span></span><br></pre></td></tr></table></figure>

<p>（2）开启 GTID 模式  </p>
<p>如果 clickhouse 使用的是 20.8 prestable 之后发布的版本，那么 MySQL 还需要配置开启 GTID 模式, 这种方式在 mysql 主从模式下可以确保数据同步的一致性(主从切换时)。  </p>
<figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">gtid-mode</span>=<span class="string">on</span></span><br><span class="line"><span class="meta">enforce-gtid-consistency</span>=<span class="string">1 # 设置为主从强一致性</span></span><br><span class="line"><span class="meta">log-slave-updates</span>=<span class="string">1 # 记录日志</span></span><br></pre></td></tr></table></figure>

<p>GTID 是 MySQL 复制增强版，从 MySQL 5.6 版本开始支持，目前已经是 MySQL 主流复制模式。它为每个 event 分配一个全局唯一 ID 和序号，我们可以不用关心 MySQL 集群主从拓扑结构，直接告知 MySQL 这个 GTID 即可。</p>
<p>  （3） 重启 MySQL  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl restart mysqld</span><br></pre></td></tr></table></figure>

<h3 id="7-2-2-准备-MySQL-表和数据"><a href="#7-2-2-准备-MySQL-表和数据" class="headerlink" title="7.2.2 准备 MySQL 表和数据"></a>7.2.2 准备 MySQL 表和数据</h3><p>（1） 在 MySQL 中创建数据表并写入数据  </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> testck;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`testck`</span>.<span class="string">`t_organization`</span> (</span><br><span class="line">    <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    <span class="string">`code`</span> <span class="built_in">int</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    <span class="string">`name`</span> <span class="built_in">text</span> <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">    <span class="string">`updatetime`</span> datetime <span class="keyword">DEFAULT</span> <span class="literal">NULL</span>,</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>),</span><br><span class="line">    <span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> (<span class="string">`code`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> testck.t_organization (code, <span class="keyword">name</span>,updatetime)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="number">1000</span>,<span class="string">'Realinsight'</span>,<span class="keyword">NOW</span>());</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> testck.t_organization (code, <span class="keyword">name</span>,updatetime)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="number">1001</span>, <span class="string">'Realindex'</span>,<span class="keyword">NOW</span>());</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> testck.t_organization (code, <span class="keyword">name</span>,updatetime)</span><br><span class="line"><span class="keyword">VALUES</span>(<span class="number">1002</span>,<span class="string">'EDT'</span>,<span class="keyword">NOW</span>());</span><br></pre></td></tr></table></figure>

<p>（2） 创建第二张表  </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`testck`</span>.<span class="string">`t_user`</span> (</span><br><span class="line">    <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    <span class="string">`code`</span> <span class="built_in">int</span>,</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> testck.t_user (code) <span class="keyword">VALUES</span>(<span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<h3 id="7-2-3-开启-ClickHouse-物化引擎"><a href="#7-2-3-开启-ClickHouse-物化引擎" class="headerlink" title="7.2.3 开启 ClickHouse 物化引擎"></a>7.2.3 开启 ClickHouse 物化引擎</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set allow_experimental_database_materialize_mysql=1;</span><br></pre></td></tr></table></figure>

<h3 id="7-2-4-创建复制管道"><a href="#7-2-4-创建复制管道" class="headerlink" title="7.2.4 创建复制管道"></a>7.2.4 创建复制管道</h3><p>（1） ClickHouse 中创建 MaterializeMySQL 数据库  </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> test_binlog <span class="keyword">ENGINE</span> = MaterializeMySQL(<span class="string">'hadoop1:3306'</span>,<span class="string">'testck'</span>,<span class="string">'root'</span>,<span class="string">'000000'</span>);</span><br></pre></td></tr></table></figure>

<p>其中 4 个参数分别是 MySQL 地址、 databse、 username 和 password。  </p>
<p>（2） 查看 ClickHouse 的数据  </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> test_binlog;</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">tables</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t_organization;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t_user;</span><br></pre></td></tr></table></figure>

<h3 id="7-2-5-修改数据"><a href="#7-2-5-修改数据" class="headerlink" title="7.2.5 修改数据"></a>7.2.5 修改数据</h3><p>（1） 在 MySQL 中修改数据:  </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">update</span> t_organization <span class="keyword">set</span> <span class="keyword">name</span> = <span class="keyword">CONCAT</span>(<span class="keyword">name</span>,<span class="string">'-v1'</span>) <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>（2） 查看 clickhouse 日志可以看到 binlog 监听事件，查询 clickhouse  </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t_organization;</span><br></pre></td></tr></table></figure>

<h3 id="7-2-6-删除数据"><a href="#7-2-6-删除数据" class="headerlink" title="7.2.6 删除数据"></a>7.2.6 删除数据</h3><p>（1） MySQL 删除数据:  </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> t_organization <span class="keyword">where</span> <span class="keyword">id</span> = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>

<p>（2） ClicKHouse， 日志有 DeleteRows 的 binlog 监听事件，查看数据：  </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t_organization;</span><br></pre></td></tr></table></figure>

<p>（3） 在刚才的查询中增加 _sign 和 _version 虚拟字段  </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> *,_sign,_version <span class="keyword">from</span> t_organization <span class="keyword">order</span> <span class="keyword">by</span> _sign <span class="keyword">desc</span>, _version <span class="keyword">desc</span>;</span><br></pre></td></tr></table></figure>

<p><img src="/2024/09/23/ClickHouse%E9%AB%98%E7%BA%A7%E8%BF%9B%E9%98%B6/image-20241022102453303.png" alt="image-20241022102453303"></p>
<p>在查询时，对于已经被删除的数据， _sign=-1， ClickHouse 会自动重写 SQL，将 _sign = -1 的数据过滤掉</p>
<p>对于修改的数据，则自动重写 SQL，为其增加 FINAL 修饰符。  </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t_organization</span><br><span class="line"><span class="comment"># 等同于</span></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t_organization <span class="keyword">final</span> <span class="keyword">where</span> _sign = <span class="number">1</span></span><br></pre></td></tr></table></figure>

<h3 id="7-2-7-删除表"><a href="#7-2-7-删除表" class="headerlink" title="7.2.7 删除表"></a>7.2.7 删除表</h3><p>（1） 在 mysql 执行删除表  </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> t_user;</span><br></pre></td></tr></table></figure>

<p>（2） 此时在 clickhouse 处会同步删除对应表，如果查询会报错  </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> <span class="keyword">tables</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t_user;</span><br><span class="line">DB::Exception: Table scene_mms.scene doesn't exist..</span><br></pre></td></tr></table></figure>

<p>（3） mysql 新建表， clickhouse 可以查询到  </p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`testck`</span>.<span class="string">`t_user`</span> (</span><br><span class="line">    <span class="string">`id`</span> <span class="built_in">int</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    <span class="string">`code`</span> <span class="built_in">int</span>,</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span> (<span class="string">`id`</span>)</span><br><span class="line">) <span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> testck.t_user (code) <span class="keyword">VALUES</span>(<span class="number">1</span>);</span><br><span class="line"><span class="comment">#ClickHouse 查询</span></span><br><span class="line"><span class="keyword">show</span> <span class="keyword">tables</span>;</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> t_user;</span><br></pre></td></tr></table></figure>

<h1 id="第-8-章-常见问题排查"><a href="#第-8-章-常见问题排查" class="headerlink" title="第 8 章 常见问题排查"></a>第 8 章 常见问题排查</h1><h2 id="8-1-分布式-DDL-某数据节点的副本不执行"><a href="#8-1-分布式-DDL-某数据节点的副本不执行" class="headerlink" title="8.1 分布式 DDL 某数据节点的副本不执行"></a>8.1 分布式 DDL 某数据节点的副本不执行</h2><p>（1） 问题： 使用分布式 ddl 执行命令 create table on cluster xxxx 某个节点上没有创建表，但是 client 返回正常，查看日志有如下报错。  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Error&gt; xxx.xxx: Retrying createReplica(), because some other replicas were created at the same time</span><br></pre></td></tr></table></figure>

<p>（2） 解决办法： 重启该不执行的节点。  </p>
<h2 id="8-2-数据副本表和数据不一致"><a href="#8-2-数据副本表和数据不一致" class="headerlink" title="8.2 数据副本表和数据不一致"></a>8.2 数据副本表和数据不一致</h2><p>（1） 问题： 由于某个数据节点副本异常，导致两数据副本表不一致，某个数据副本缺少表，需要将两个数据副本调整一致。  </p>
<p>（2） 解决办法：  </p>
<p>在缺少表的数据副本节点上创建缺少的表，创建为本地表，表结构可以在其他数据副本通过 show crete table xxxx 获取。</p>
<p>表结构创建后， clickhouse 会自动从其他副本同步该表数据，验证数据量是否一致即可。  </p>
<h2 id="8-3-副本节点全量恢复"><a href="#8-3-副本节点全量恢复" class="headerlink" title="8.3 副本节点全量恢复"></a>8.3 副本节点全量恢复</h2><p>（1）问题： 某个数据副本异常无法启动，需要重新搭建副本。</p>
<p>（2）解决办法：<br>清空异常副本节点的 metadata 和 data 目录。</p>
<p>从另一个正常副本将 metadata 目录拷贝过来（这一步之后可以启动数据库，但是只有表结构没有数据）。</p>
<p>执行 sudo -u clickhouse touch /data/clickhouse/flags/force_restore_data</p>
<p>启动数据库。  </p>
<h2 id="8-4-数据副本启动缺少-zk-表"><a href="#8-4-数据副本启动缺少-zk-表" class="headerlink" title="8.4 数据副本启动缺少 zk 表"></a>8.4 数据副本启动缺少 zk 表</h2><p>（1）问题： 某个数据副本表在 zk 上丢失数据，或者不存在，但是 metadata 元数据里存在，导致启动异常，报错：  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Can’ t get data for node /clickhouse/tables/01-</span><br><span class="line">02/xxxxx/xxxxxxx/replicas/xxx/metadata: node doesn’ t exist (No node):</span><br><span class="line">Cannot attach table xxxxxxx</span><br></pre></td></tr></table></figure>

<p>（2）解决办法：  </p>
<p>metadata 中移除该表的结构文件，如果多个表报错都移除</p>
<p>mv metadata/xxxxxx/xxxxxxxx.sql /tmp/</p>
<p>启动数据库</p>
<p>手工创建缺少的表，表结构从其他节点 show create table 获取。</p>
<p>创建后会自动同步数据，验证数据是否一致。  </p>
<h2 id="8-5-ZK-table-replicas-数据未删除，导致重建表报错"><a href="#8-5-ZK-table-replicas-数据未删除，导致重建表报错" class="headerlink" title="8.5 ZK table replicas 数据未删除，导致重建表报错"></a>8.5 ZK table replicas 数据未删除，导致重建表报错</h2><p>（1）问题： 重建表过程中，先使用 drop table xxx on cluster xxx ,各节点在 clickhouse 上table 已物理删除，但是 zk 里面针对某个 clickhouse 节点的 table meta 信息未被删除（低概率事件），因 zk 里仍存在该表的 meta 信息，导致再次创建该表 create table xxx on cluster, 该节点无法创建表(其他节点创建表成功)，报错：</p>
<p>Replica /clickhouse/tables/01-03/xxxxxx/xxx/replicas/xxx already exists..</p>
<p>（2）解决办法：<br>从其他数据副本 cp 该 table 的 metadata sql 过来.</p>
<p>重启节点。  </p>
<h2 id="8-6-Clickhouse-节点意外关闭"><a href="#8-6-Clickhouse-节点意外关闭" class="headerlink" title="8.6 Clickhouse 节点意外关闭"></a>8.6 Clickhouse 节点意外关闭</h2><p>（1）问题： 模拟其中一个节点意外宕机，在大量 insert 数据的情况下，关闭某个节点。</p>
<p>（2） 现象： 数据写入不受影响、数据查询不受影响、建表 DDL 执行到异常节点会卡住，<br>报错：  </p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Code: 159. DB::Exception: Received from localhost:9000. DB::Exception:</span><br><span class="line">Watching task /clickhouse/task_queue/ddl/query-0000565925 is executing</span><br><span class="line">longer than distributed_ddl_task_timeout (=180) seconds. There are 1</span><br><span class="line">unfinished hosts (0 of them are currently active), they are going to</span><br><span class="line">execute the query in background.</span><br></pre></td></tr></table></figure>

<p>（3）解决办法： 启动异常节点，期间其他副本写入数据会自动同步过来，其他副本的建表 DDL 也会同步。  </p>
<h2 id="8-7-其他问题参考"><a href="#8-7-其他问题参考" class="headerlink" title="8.7 其他问题参考"></a>8.7 其他问题参考</h2><p>[点击跳转其他问题参考链接](<a href="https://help.aliyun.com/document_detail/162815.html?spm=a2c4g.11186623.6.652.312e7" target="_blank" rel="noopener">https://help.aliyun.com/document_detail/162815.html?spm=a2c4g.11186623.6.652.312e7</a><br>9bd17U8IO)</p>

    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>Rui Zhang
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://yoursite.com/2024/09/23/ClickHouse%E9%AB%98%E7%BA%A7%E8%BF%9B%E9%98%B6/" title="ClickHouse高级进阶">http://yoursite.com/2024/09/23/ClickHouse高级进阶/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="noopener" target="_blank"><i class="fa fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/ClickHouse/" rel="tag"># ClickHouse</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2024/09/13/ClickHouse%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/" rel="prev" title="ClickHouse基础入门">
      <i class="fa fa-chevron-left"></i> ClickHouse基础入门
    </a></div>
      <div class="post-nav-item">
    <a href="/2024/10/18/Idea%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE/" rel="next" title="Idea常用快捷键">
      Idea常用快捷键 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  

  </div>


          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let activeClass = CONFIG.comments.activeClass;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#第-1-章-Explain-查看执行计划"><span class="nav-number">1.</span> <span class="nav-text">第 1 章 Explain 查看执行计划</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-1-基本语法"><span class="nav-number">1.1.</span> <span class="nav-text">1.1 基本语法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-2-案例实操"><span class="nav-number">1.2.</span> <span class="nav-text">1.2 案例实操</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-1-新版本使用-EXPLAIN"><span class="nav-number">1.2.1.</span> <span class="nav-text">1.2.1 新版本使用 EXPLAIN</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-2-老版本查看执行计划"><span class="nav-number">1.2.2.</span> <span class="nav-text">1.2.2 老版本查看执行计划</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第-2-章-建表优化"><span class="nav-number">2.</span> <span class="nav-text">第 2 章 建表优化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-1-数据类型"><span class="nav-number">2.1.</span> <span class="nav-text">2.1 数据类型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-1-时间字段的类型"><span class="nav-number">2.1.1.</span> <span class="nav-text">2.1.1 时间字段的类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-2-空值存储类型"><span class="nav-number">2.1.2.</span> <span class="nav-text">2.1.2 空值存储类型</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-2-分区和索引"><span class="nav-number">2.2.</span> <span class="nav-text">2.2 分区和索引</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-3-表参数"><span class="nav-number">2.3.</span> <span class="nav-text">2.3 表参数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-4-写入和删除优化"><span class="nav-number">2.4.</span> <span class="nav-text">2.4 写入和删除优化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-5-常见配置"><span class="nav-number">2.5.</span> <span class="nav-text">2.5 常见配置</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-1-CPU-资源"><span class="nav-number">2.5.1.</span> <span class="nav-text">2.5.1 CPU 资源</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-2-内存资源"><span class="nav-number">2.5.2.</span> <span class="nav-text">2.5.2 内存资源</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-3-存储"><span class="nav-number">2.5.3.</span> <span class="nav-text">2.5.3 存储</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第-3-章-ClickHouse-语法优化规则"><span class="nav-number">3.</span> <span class="nav-text">第 3 章 ClickHouse 语法优化规则</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#3-1-准备测试用表"><span class="nav-number">3.1.</span> <span class="nav-text">3.1 准备测试用表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-COUNT-优化"><span class="nav-number">3.2.</span> <span class="nav-text">3.2 COUNT 优化</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-3-消除子查询重复字段"><span class="nav-number">3.3.</span> <span class="nav-text">3.3 消除子查询重复字段</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-4-谓词下推"><span class="nav-number">3.4.</span> <span class="nav-text">3.4 谓词下推</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-5-聚合计算外推"><span class="nav-number">3.5.</span> <span class="nav-text">3.5 聚合计算外推</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-6-聚合函数消除"><span class="nav-number">3.6.</span> <span class="nav-text">3.6 聚合函数消除</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-7-删除重复的-order-by-key"><span class="nav-number">3.7.</span> <span class="nav-text">3.7 删除重复的 order by key</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-8-删除重复的-limit-by-key"><span class="nav-number">3.8.</span> <span class="nav-text">3.8 删除重复的 limit by key</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-9-删除重复的-USING-Key"><span class="nav-number">3.9.</span> <span class="nav-text">3.9 删除重复的 USING Key</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-10-标量替换"><span class="nav-number">3.10.</span> <span class="nav-text">3.10 标量替换</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-11-三元运算优化"><span class="nav-number">3.11.</span> <span class="nav-text">3.11 三元运算优化</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第-4-章-查询优化"><span class="nav-number">4.</span> <span class="nav-text">第 4 章 查询优化</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#4-1-单表查询"><span class="nav-number">4.1.</span> <span class="nav-text">4.1 单表查询</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-1-Prewhere-替代-where"><span class="nav-number">4.1.1.</span> <span class="nav-text">4.1.1 Prewhere 替代 where</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-2-数据采样"><span class="nav-number">4.1.2.</span> <span class="nav-text">4.1.2 数据采样</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-3-列裁剪与分区裁剪"><span class="nav-number">4.1.3.</span> <span class="nav-text">4.1.3 列裁剪与分区裁剪</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-4-orderby-结合-where、-limit"><span class="nav-number">4.1.4.</span> <span class="nav-text">4.1.4 orderby 结合 where、 limit</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-5-避免构建虚拟列"><span class="nav-number">4.1.5.</span> <span class="nav-text">4.1.5 避免构建虚拟列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-6-uniqCombined-替代-distinct"><span class="nav-number">4.1.6.</span> <span class="nav-text">4.1.6 uniqCombined 替代 distinct</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-7-使用物化视图"><span class="nav-number">4.1.7.</span> <span class="nav-text">4.1.7 使用物化视图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-8-其他注意事项"><span class="nav-number">4.1.8.</span> <span class="nav-text">4.1.8 其他注意事项</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-2-多表关联"><span class="nav-number">4.2.</span> <span class="nav-text">4.2 多表关联</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-1-准备表和数据"><span class="nav-number">4.2.1.</span> <span class="nav-text">4.2.1 准备表和数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-2-用-IN-代替-JOIN"><span class="nav-number">4.2.2.</span> <span class="nav-text">4.2.2 用 IN 代替 JOIN</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-3-大小表-JOIN"><span class="nav-number">4.2.3.</span> <span class="nav-text">4.2.3 大小表 JOIN</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-4-注意谓词下推（版本差异）"><span class="nav-number">4.2.4.</span> <span class="nav-text">4.2.4 注意谓词下推（版本差异）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-5-分布式表使用-GLOBAL"><span class="nav-number">4.2.5.</span> <span class="nav-text">4.2.5 分布式表使用 GLOBAL</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-6-使用字典表"><span class="nav-number">4.2.6.</span> <span class="nav-text">4.2.6 使用字典表</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-7-提前过滤"><span class="nav-number">4.2.7.</span> <span class="nav-text">4.2.7 提前过滤</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第-5-章-数据一致性（重点）"><span class="nav-number">5.</span> <span class="nav-text">第 5 章 数据一致性（重点）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#5-1-准备测试表和数据"><span class="nav-number">5.1.</span> <span class="nav-text">5.1 准备测试表和数据</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-2-手动-OPTIMIZE"><span class="nav-number">5.2.</span> <span class="nav-text">5.2 手动 OPTIMIZE</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-3-通过-Group-by-去重"><span class="nav-number">5.3.</span> <span class="nav-text">5.3 通过 Group by 去重</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-4-通过-FINAL-查询"><span class="nav-number">5.4.</span> <span class="nav-text">5.4 通过 FINAL 查询</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-4-1-老版本测试"><span class="nav-number">5.4.1.</span> <span class="nav-text">5.4.1 老版本测试</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-4-2-新版本测试"><span class="nav-number">5.4.2.</span> <span class="nav-text">5.4.2 新版本测试</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第-6-章-物化视图"><span class="nav-number">6.</span> <span class="nav-text">第 6 章 物化视图</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#6-1-概述"><span class="nav-number">6.1.</span> <span class="nav-text">6.1 概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-1-物化视图与普通视图的区别"><span class="nav-number">6.1.1.</span> <span class="nav-text">6.1.1 物化视图与普通视图的区别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-2-优缺点"><span class="nav-number">6.1.2.</span> <span class="nav-text">6.1.2 优缺点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-3-基本语法"><span class="nav-number">6.1.3.</span> <span class="nav-text">6.1.3 基本语法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-2-案例实操"><span class="nav-number">6.2.</span> <span class="nav-text">6.2 案例实操</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-1-准备测试用表和数据"><span class="nav-number">6.2.1.</span> <span class="nav-text">6.2.1 准备测试用表和数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-2-2-创建物化视图"><span class="nav-number">6.2.2.</span> <span class="nav-text">6.2.2 创建物化视图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-3-导入增量数据"><span class="nav-number">6.2.3.</span> <span class="nav-text">6.3.3 导入增量数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-3-4-导入历史数据"><span class="nav-number">6.2.4.</span> <span class="nav-text">6.3.4 导入历史数据</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第-7-章-MaterializeMySQL-引擎"><span class="nav-number">7.</span> <span class="nav-text">第 7 章 MaterializeMySQL 引擎</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#7-1-概述"><span class="nav-number">7.1.</span> <span class="nav-text">7.1 概述</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-1-1-特点"><span class="nav-number">7.1.1.</span> <span class="nav-text">7.1.1 特点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-1-2-使用细则"><span class="nav-number">7.1.2.</span> <span class="nav-text">7.1.2 使用细则</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-2-案例实操"><span class="nav-number">7.2.</span> <span class="nav-text">7.2 案例实操</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-1-MySQL-开启-binlog-和-GTID-模式"><span class="nav-number">7.2.1.</span> <span class="nav-text">7.2.1 MySQL 开启 binlog 和 GTID 模式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-2-准备-MySQL-表和数据"><span class="nav-number">7.2.2.</span> <span class="nav-text">7.2.2 准备 MySQL 表和数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-3-开启-ClickHouse-物化引擎"><span class="nav-number">7.2.3.</span> <span class="nav-text">7.2.3 开启 ClickHouse 物化引擎</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-4-创建复制管道"><span class="nav-number">7.2.4.</span> <span class="nav-text">7.2.4 创建复制管道</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-5-修改数据"><span class="nav-number">7.2.5.</span> <span class="nav-text">7.2.5 修改数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-6-删除数据"><span class="nav-number">7.2.6.</span> <span class="nav-text">7.2.6 删除数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-2-7-删除表"><span class="nav-number">7.2.7.</span> <span class="nav-text">7.2.7 删除表</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#第-8-章-常见问题排查"><span class="nav-number">8.</span> <span class="nav-text">第 8 章 常见问题排查</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#8-1-分布式-DDL-某数据节点的副本不执行"><span class="nav-number">8.1.</span> <span class="nav-text">8.1 分布式 DDL 某数据节点的副本不执行</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-2-数据副本表和数据不一致"><span class="nav-number">8.2.</span> <span class="nav-text">8.2 数据副本表和数据不一致</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-3-副本节点全量恢复"><span class="nav-number">8.3.</span> <span class="nav-text">8.3 副本节点全量恢复</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-4-数据副本启动缺少-zk-表"><span class="nav-number">8.4.</span> <span class="nav-text">8.4 数据副本启动缺少 zk 表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-5-ZK-table-replicas-数据未删除，导致重建表报错"><span class="nav-number">8.5.</span> <span class="nav-text">8.5 ZK table replicas 数据未删除，导致重建表报错</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-6-Clickhouse-节点意外关闭"><span class="nav-number">8.6.</span> <span class="nav-text">8.6 Clickhouse 节点意外关闭</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#8-7-其他问题参考"><span class="nav-number">8.7.</span> <span class="nav-text">8.7 其他问题参考</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Rui Zhang"
      src="/images/head.jpg">
  <p class="site-author-name" itemprop="name">Rui Zhang</p>
  <div class="site-description" itemprop="description">不在沉默中爆发，就在沉默中灭亡</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">52</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">22</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">22</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="cc-license motion-element" itemprop="license">
    <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" rel="noopener" target="_blank"><img src="/images/cc-by-nc-sa.svg" alt="Creative Commons"></a>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 2021 – 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Rui Zhang</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
      <span class="post-meta-item-text">站点总字数：</span>
    <span title="站点总字数">1.7m</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">25:10</span>
</div>




        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"model":{"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"position":"right","width":120,"height":230},"mobile":{"show":true},"log":false,"pluginJsPath":"lib/","pluginModelPath":"assets/","pluginRootPath":"live2dw/","tagMode":false});</script></body>
</html>
<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/src/clicklove.js"></script>
